{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/demo/echarts.html","path":"demo/echarts.html","modified":0,"renderable":0},{"_id":"themes/stun/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/stun/source/js/header.js","path":"js/header.js","modified":0,"renderable":1},{"_id":"themes/stun/source/js/scroll.js","path":"js/scroll.js","modified":0,"renderable":1},{"_id":"themes/stun/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"themes/stun/source/js/stun-boot.js","path":"js/stun-boot.js","modified":0,"renderable":1},{"_id":"themes/stun/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/stun/source/images/algolia.svg","path":"images/algolia.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/loading.svg","path":"images/loading.svg","modified":0,"renderable":1},{"_id":"themes/stun/source/images/icons/favicon-16x16.png","path":"images/icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/stun/source/images/icons/favicon-32x32.png","path":"images/icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/stun/source/images/icons/stun-logo.svg","path":"images/icons/stun-logo.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"34a315decbe5830abdb2308972f7d343d2b5d2b7","modified":1635556829400},{"_id":"source/_posts/axios封装.md","hash":"d3ae81e68a5c71273ecba1710c907c52df91b485","modified":1635495201043},{"_id":"source/_posts/css面试题.md","hash":"e1efd09775f0e96618a24e86d50bf0697d12c934","modified":1639988571664},{"_id":"source/_posts/canvas使用.md","hash":"d0f1187c013b726f64c9076469bfeabfdb54bb6e","modified":1635518022718},{"_id":"source/.DS_Store","hash":"b188db7e3abc63d120864f3dcf3462b70d0fa852","modified":1637112472960},{"_id":"source/_posts/docker使用介绍.md","hash":"1c5c82ae4733f1068d71b1e2044c6bbe34f9b619","modified":1635490261860},{"_id":"source/_posts/echarts使用介绍.md","hash":"11ea2e0554846d4202c86bf7a3d9405934583676","modified":1635604975576},{"_id":"source/_posts/es6入门.md","hash":"ff63e18aec15e002ac2145ac1e18ae73b6ff3732","modified":1635848128093},{"_id":"source/_posts/flex使用介绍.md","hash":"632dabbf1490ee1f4913488fb3777d0f634b8039","modified":1636018006735},{"_id":"source/_posts/express使用介绍.md","hash":"cb51344bd07089612fffafd05d603142dfdfbf40","modified":1635488814348},{"_id":"source/_posts/github代码管理.md","hash":"085b97421dc8f92c65b4f30b21666df2a4375bb8","modified":1635597386994},{"_id":"source/_posts/http介绍.md","hash":"317cbdcc47a09d7003756b4f67d4e8ae58fd1b69","modified":1636014058401},{"_id":"source/_posts/hexo搭建博客.md","hash":"624955847a0a2f984b724bb42cb490a40056acc2","modified":1635936839029},{"_id":"source/_posts/javascript入门教程.md","hash":"10fa1055cbaf9ee80f9eb5001c7c8b436b6ded83","modified":1639994830877},{"_id":"source/_posts/javascript面试题.md","hash":"17bf69fba4ccd9c54ea56d2be351d87133c10076","modified":1636079234881},{"_id":"source/_posts/jwt使用介绍.md","hash":"8eb51d6e072375d2c5260e993392d56f26f86196","modified":1635488873934},{"_id":"source/_posts/mongodb使用介绍.md","hash":"c5f45f679f0adb1e70dfe17000e4b419fac2a523","modified":1635488893639},{"_id":"source/_posts/mysql入门.md","hash":"e13327e2bd8ca4ecf17aa61c0117a88f513e26a3","modified":1636071732753},{"_id":"source/_posts/react-hooks.md","hash":"a02471ff1442bbe98bd5a970c3ae9217351071f8","modified":1635762756870},{"_id":"source/_posts/koa使用介绍.md","hash":"e60841e99262c7fdfdd918774b20eb6d1342bab4","modified":1635849894907},{"_id":"source/_posts/react入门教程.md","hash":"3b31ac36db101c1e1bc6de5cb55267f0d898f6e3","modified":1636357801686},{"_id":"source/_posts/react后台管理系统.md","hash":"5790ccd1ab0aff584a45b313055ad68eea56f2b0","modified":1635488233206},{"_id":"source/_posts/react面试题.md","hash":"8107c0cb1d1ae703e7879aa96c321e036807e0ef","modified":1639989150346},{"_id":"source/_posts/typescript使用.md","hash":"74896a13b27e55830d6a526eac7cf75ca78fc75a","modified":1635490681065},{"_id":"source/_posts/uniapp开发管理APP.md","hash":"55035b856d84e087bc5fd480d1849e2b704ba1b3","modified":1635488400848},{"_id":"source/_posts/vue3入门教程.md","hash":"3414ddbf7328161c252060b7bf1becce4547a868","modified":1635729357267},{"_id":"source/_posts/vue入门教程.md","hash":"20a8c7966506563933ecb9efc325ba87be76bb0e","modified":1636509879203},{"_id":"source/_posts/vue组件库开发.md","hash":"6223cbc7be3fd75d8a2b4e694cdb031d443be347","modified":1635488466389},{"_id":"source/_posts/vue面试题.md","hash":"190877b157b03c4b445a666b1ea894b2204fd394","modified":1639989187074},{"_id":"source/_posts/webpack使用介绍.md","hash":"d13c1c0e7600e95b07e50e2353a10262adbe5dde","modified":1635495301573},{"_id":"source/_posts/前端综合面试题.md","hash":"1cbc1e61d385f74bada4c8cbd52cc66dd14999c7","modified":1637373059301},{"_id":"source/_posts/基于vue开发的CRM系统.md","hash":"966d3a2f4a67373692e828760037d0b906072897","modified":1637373059305},{"_id":"source/_posts/大屏数据可视化项目开发.md","hash":"f615b73fd03840bc86b7fe4d4bae82b546cc9f1e","modified":1637373119824},{"_id":"source/_posts/微信小程序入门.md","hash":"2164ce6b35a7430f208d069d774acfec7227e6de","modified":1636360673891},{"_id":"source/demo/.DS_Store","hash":"7b05b1bb3b88d70397b354e58bb2886dcee8a12a","modified":1637042227957},{"_id":"source/demo/echarts.html","hash":"2878668298046210335b3d051ca7b69cf04fdb95","modified":1635605451947},{"_id":"source/_posts/echarts使用介绍/bar.png","hash":"255e69bbc186b6aaf6e30df4a20afaca5e62bdcb","modified":1635601707611},{"_id":"source/_posts/echarts使用介绍/line.png","hash":"94a4bc6f72ffe24765c52e470634ff6bfb69f8a3","modified":1635603923490},{"_id":"source/_posts/echarts使用介绍/pie.png","hash":"84fd342ec101f53b67991ab548b3ee536fd2b1df","modified":1635604959882},{"_id":"source/_posts/http介绍/httpmessage.jpeg","hash":"e904165bc50bc37477449ff8b339610be5f82fa1","modified":1636009604758},{"_id":"source/_posts/flex使用介绍/flex_1.png","hash":"1ecaac9b18d66edf3ab7aeaadde91dd7b47ac4f5","modified":1636014763141},{"_id":"source/_posts/flex使用介绍/flex_2.png","hash":"20fe8f5dad5fa18bf4d7f1971d922ca43087db4a","modified":1636016807490},{"_id":"source/_posts/flex使用介绍/flex_3.png","hash":"49ec2f8667a4908eb703ecfc53bfcbda645c2c5c","modified":1636017691169},{"_id":"source/_posts/flex使用介绍/flex_4.png","hash":"28068f3962f468c5276e09c12eac4f370fd3d026","modified":1636017820495},{"_id":"source/_posts/flex使用介绍/flex_5.png","hash":"caf8db94cfd01a729a0c55b3b0b6811cc522dd83","modified":1636017959034},{"_id":"source/_posts/vue入门教程/lifecycle.png","hash":"53345be1363e09b3e43e34d27c030c4f376b060a","modified":1635730974460},{"_id":"source/_posts/vue入门教程/vue.png","hash":"7071337f9071f93ebf85639ede38b0f40fd75d98","modified":1636444582585},{"_id":"source/_posts/前端综合面试题/csrf.jpeg","hash":"f5a8dc04304bf47b66a2a1486dcec6f1713e31bc","modified":1636349677959},{"_id":"themes/stun/package.json","hash":"3a8970ff8499ddd68a3d23ce16c0eb73074a2ccd","modified":1638439684730},{"_id":"themes/stun/scripts/engine.js","hash":"a63a57c9206a77a79f93dbd86e86204447d7d904","modified":1638439684731},{"_id":"themes/stun/scripts/merge-config.js","hash":"bb914100129c5ca2d1a9e087fffd7bedcb6ae6a6","modified":1638439684733},{"_id":"themes/stun/_config.yml","hash":"01d7a55e9e98bdc0d6d6ae9731122d4963cf0225","modified":1638440530235},{"_id":"themes/stun/languages/en.yml","hash":"e1348852aa00d2d57f5215c83709f6428f8e8a71","modified":1638439684708},{"_id":"themes/stun/languages/zh-CN.yml","hash":"8535e2d34d24769067ba7bd3d9c0b94d1fd01cc7","modified":1638439684709},{"_id":"themes/stun/languages/es.yml","hash":"e150c8a1f56ae9ed065611951aa124fb548577fc","modified":1638439684709},{"_id":"themes/stun/layout/_layout.pug","hash":"5052ee5040ae736d78ad208df7352be69b61b0d1","modified":1638439684710},{"_id":"themes/stun/languages/zh-HK.yml","hash":"aef25f329cc05dbe8e38753fccd98d63c9fcd174","modified":1638439684710},{"_id":"themes/stun/layout/index.pug","hash":"df40cf1f051fd29f0f51ace74e9f7394f6ea2ab7","modified":1638439684729},{"_id":"themes/stun/layout/archive.pug","hash":"d45d078ae4196add83e21fcaed3ef168b237af90","modified":1638439684729},{"_id":"themes/stun/layout/category.pug","hash":"24153408b2971542d177227f09e93da7754bf75e","modified":1638439684729},{"_id":"themes/stun/layout/page.pug","hash":"22ba5928bd9ae8c56b3242b7caa5fc3ec471b082","modified":1638439684730},{"_id":"themes/stun/scripts/filters/external-link.js","hash":"f5369becfd8cc6e43d6dc3595b1edbe014d9aa7c","modified":1638439684731},{"_id":"themes/stun/scripts/filters/image-setting.js","hash":"412318b6d189d5355dbcc52c9762072f7ecdaad4","modified":1638439684731},{"_id":"themes/stun/layout/post.pug","hash":"a4d16dbb919df5d4ffdb5a1d0114a4e1c8c21197","modified":1638439684730},{"_id":"themes/stun/scripts/filters/lazyload.js","hash":"d5baf39faeff5368182be1f59fb598d023985cde","modified":1638439684732},{"_id":"themes/stun/scripts/filters/post-heading.js","hash":"b504aa047e3f080fc3f95f3e96fad88bbbce20cb","modified":1638439684732},{"_id":"themes/stun/scripts/filters/shake-file.js","hash":"159dff6e4f7020545c9b151108398cd383d613e2","modified":1638439684732},{"_id":"themes/stun/layout/tag.pug","hash":"46f956ad7e2aed879999ddf5e768d80c4bbe5b5f","modified":1638439684730},{"_id":"themes/stun/scripts/filters/wrap-table.js","hash":"888c9eaaddcdb9b88d07837a9091aa39ed3fe677","modified":1638439684732},{"_id":"themes/stun/scripts/tags/friends.js","hash":"c2fe1e8e128f464d772bcb7534efef54ad224310","modified":1638439684733},{"_id":"themes/stun/scripts/tags/note.js","hash":"b436593a56e3bab8dd59c71e73ac9efbc8fa29d4","modified":1638439684733},{"_id":"themes/stun/scripts/tags/table.js","hash":"177061e1bfb296981a101643f51a27ccc1469307","modified":1638439684733},{"_id":"themes/stun/source/css/index.styl","hash":"8a75ec81fb064b0da2f978a064cc5bec2395f27d","modified":1638439684753},{"_id":"themes/stun/source/js/header.js","hash":"63d407ee6f80114e220171ba829b79b28d420fe0","modified":1638439684757},{"_id":"themes/stun/source/js/scroll.js","hash":"8926ab87181a49c730ce5132518b608c54b8cdb1","modified":1638439684757},{"_id":"themes/stun/source/js/sidebar.js","hash":"20adff7f54bcd8299d32690d41ebc7a4eb7a8728","modified":1638439684757},{"_id":"themes/stun/source/js/stun-boot.js","hash":"8358ac0d879c0ca340c52e4de606523c2a91e156","modified":1638439684758},{"_id":"themes/stun/source/js/utils.js","hash":"b570eafe77e47d7701348f172a4dbaaba6fa8123","modified":1638439684758},{"_id":"themes/stun/source/images/algolia.svg","hash":"90322f80db6ad0daf26ea3ec71dea6f691a8b2f1","modified":1638439684753},{"_id":"themes/stun/source/images/cc-by-nc-nd.svg","hash":"017ad912874686a982ebceae359299b8f2a492e2","modified":1638439684754},{"_id":"themes/stun/source/images/cc-by-nc-sa.svg","hash":"71d035c34219f924dbf1bf852166ee8fb58d2f24","modified":1638439684754},{"_id":"themes/stun/source/images/cc-by-nc.svg","hash":"4608189edbe7636dd651df65473298a3c5afb20d","modified":1638439684754},{"_id":"themes/stun/source/images/cc-by-nd.svg","hash":"20c66ae3c393903e6eab3bc8cf7c3be6d753f9f8","modified":1638439684754},{"_id":"themes/stun/source/images/cc-by-sa.svg","hash":"0455a8857ba096925d4145a56e8d10537fccb378","modified":1638439684754},{"_id":"themes/stun/source/images/cc-by.svg","hash":"77f74c241902447424207869c74cb9d9264bdced","modified":1638439684755},{"_id":"themes/stun/source/images/loading.svg","hash":"32a6e770d217ae6c0cf0f6beef3172f1b5b9a0a2","modified":1638439684756},{"_id":"themes/stun/layout/_mixins/menu-item.pug","hash":"93c4454e48a6f1456c29aeb9d1332be186b49d4f","modified":1638439684711},{"_id":"themes/stun/layout/_mixins/gallery.pug","hash":"3054e2c09bc205173c517fb1c36321f7c4c0db63","modified":1638439684711},{"_id":"themes/stun/layout/_mixins/meta-item.pug","hash":"3d74dc8ba8651efd4a605e56a21e314678d04057","modified":1638439684711},{"_id":"themes/stun/layout/_mixins/post-header.pug","hash":"9486d07e56acf7bcc5d691bef93c19e2e5c98022","modified":1638439684711},{"_id":"themes/stun/layout/_mixins/timeline.pug","hash":"4e19a670f002d3c6bc740a2d6ef03964e6b59c09","modified":1638439684712},{"_id":"themes/stun/layout/_scripts/vendors.pug","hash":"62a6831d3b1d90d6c8335ce3402efc50e141eafb","modified":1638439684721},{"_id":"themes/stun/layout/_scripts/stun.pug","hash":"961554914427578b57ea3912d751d398f4eb381d","modified":1638439684720},{"_id":"themes/stun/layout/_third-party/pjax.pug","hash":"4a786459a8e6a4f378a9d834502f8b11aa66f185","modified":1638439684727},{"_id":"themes/stun/layout/_third-party/quicklink.pug","hash":"2bed65ed4d314dc587e2359e20ae099b46181ed5","modified":1638439684727},{"_id":"themes/stun/layout/_partials/config.pug","hash":"4fb832652485161148ea957067c06d50ed11578b","modified":1638439684712},{"_id":"themes/stun/source/css/_common/index.styl","hash":"86057db6cb18263866d62a6669feee8752882398","modified":1638439684749},{"_id":"themes/stun/source/css/_common/responsive.styl","hash":"618c6005f1bc7c482fa37ae3ce15729a64044d9d","modified":1638439684750},{"_id":"themes/stun/source/css/_mixins/index.styl","hash":"f3060519f3acd05cb4b26bb5f6a5c6b857cb0d68","modified":1638439684752},{"_id":"themes/stun/source/css/_variables/index.styl","hash":"c81aac4285eb058026b255e31282d35f55a820ab","modified":1638439684753},{"_id":"themes/stun/source/css/_custom/index.styl","hash":"0d1adc70250941074c742f94f7801b3b43a7f1db","modified":1638439684752},{"_id":"themes/stun/source/images/icons/favicon-16x16.png","hash":"7bfd64eac26e17ea162f0c399a4a40164c26b412","modified":1638439684755},{"_id":"themes/stun/source/images/icons/favicon-32x32.png","hash":"02fead07726920400ede57ddfdbf071dd7203fd5","modified":1638439684756},{"_id":"themes/stun/source/images/icons/stun-logo.svg","hash":"069dc7590ad152373f1c346d892e32faa2bbdd87","modified":1638439684756},{"_id":"themes/stun/layout/_third-party/advertising/google-adsense.pug","hash":"e489020f1130976d3ec2245915ede6319d89b89c","modified":1638439684721},{"_id":"themes/stun/layout/_third-party/advertising/index.pug","hash":"1285cd65a873f688ae3c51846c1284447f502adc","modified":1638439684721},{"_id":"themes/stun/layout/_third-party/analytics/baidu-analytics.pug","hash":"f7300991a29dbe2e8091a588dfa8c65c3dee6302","modified":1638439684722},{"_id":"themes/stun/layout/_third-party/analytics/busuanzi.pug","hash":"78a4fc9c9380e31536f5b500638f2d005accd361","modified":1638439684722},{"_id":"themes/stun/layout/_third-party/analytics/google-analytics.pug","hash":"4eef66fbb8a8ad55e0868cf4b77a6b7bca0e7f35","modified":1638439684722},{"_id":"themes/stun/layout/_third-party/analytics/index.pug","hash":"0d72f844bf9532b3be644c27b0af7cb4331fc46c","modified":1638439684722},{"_id":"themes/stun/layout/_third-party/analytics/tencent-analytics.pug","hash":"f88fb0f085812db6023c30308ba3458da7742993","modified":1638439684723},{"_id":"themes/stun/layout/_third-party/comments/disqus.pug","hash":"57bcbaac3d237d9168dd8f4b682f34351f11d250","modified":1638439684723},{"_id":"themes/stun/layout/_third-party/comments/fbcomments.pug","hash":"fb651812c87dc5e2134d7fb7d8f98d4d4227f1f6","modified":1638439684723},{"_id":"themes/stun/layout/_third-party/comments/gitalk.pug","hash":"c2a90e80c51b5b99e6804dbed5457a071b980bbd","modified":1638439684723},{"_id":"themes/stun/layout/_third-party/comments/index.pug","hash":"bec4d9c8ea360637e7da3314fa987e33facd8071","modified":1638439684724},{"_id":"themes/stun/layout/_third-party/comments/livere.pug","hash":"687f74a998519608944b40a41f3a98ccf4535139","modified":1638439684724},{"_id":"themes/stun/layout/_third-party/comments/minivaline.pug","hash":"5584ade7dd19deca418373115bde9d563d37d826","modified":1638439684724},{"_id":"themes/stun/layout/_third-party/comments/utterances.pug","hash":"6418baeb3aedcddb02a64bd89b26ac12e18551c8","modified":1638439684725},{"_id":"themes/stun/layout/_third-party/comments/valine.pug","hash":"b519a6948d6ef37c037385e3e3f9590c17f7ad62","modified":1638439684725},{"_id":"themes/stun/layout/_third-party/comments/waline.pug","hash":"fd4c958b13777752f176556c7b109b7dede7cc68","modified":1638439684725},{"_id":"themes/stun/layout/_third-party/math/index.pug","hash":"e952be6c736545e73c0e02f833f87a4f8c5a2582","modified":1638439684726},{"_id":"themes/stun/layout/_third-party/math/katex.pug","hash":"345c59fe76a7c83b529328e5144d1036cb14f533","modified":1638439684726},{"_id":"themes/stun/layout/_third-party/math/mathjax.pug","hash":"72d51538cc85f01c8c64db74b9219ccaf334c9e9","modified":1638439684726},{"_id":"themes/stun/layout/_third-party/search/algolia.pug","hash":"54233748e22ceae063f70ee49b44c4bd0a78f391","modified":1638439684728},{"_id":"themes/stun/layout/_third-party/search/index.pug","hash":"0f84aa013a96e7eb3bb25b87f20bab9b7ac55538","modified":1638439684728},{"_id":"themes/stun/layout/_third-party/search/localsearch.pug","hash":"d98db7ed7e3e4c574212fa9d75adba681f3d0687","modified":1638439684728},{"_id":"themes/stun/layout/_partials/analytics/busuanzi.pug","hash":"80d2f4f8706a96b367ac1e89f5b56ada4684d571","modified":1638439684712},{"_id":"themes/stun/layout/_partials/footer/footer.pug","hash":"9a8e56bcc504f251c13ee3d0d18a08142fb7ee43","modified":1638439684713},{"_id":"themes/stun/layout/_partials/head/head.pug","hash":"c7909a6a50c7a76a6c1810b700a5d72bcb1e20c9","modified":1638439684713},{"_id":"themes/stun/layout/_partials/head/kill-old-ie.pug","hash":"427a95d02844f29e63c5e9f014ede3609aec1a5b","modified":1638439684714},{"_id":"themes/stun/layout/_partials/header/header.pug","hash":"7ecbe18da15d3a52c56f69c542540291b6178763","modified":1638439684714},{"_id":"themes/stun/layout/_partials/post/post-list.pug","hash":"c049078009aa251fc76cd948837c7a5efdd39cb2","modified":1638439684714},{"_id":"themes/stun/layout/_partials/search/algolia.pug","hash":"61181bece0e27929fe00df5204fefd8dee31a354","modified":1638439684715},{"_id":"themes/stun/layout/_partials/search/assist-btns.pug","hash":"7e6dc0d975ccbe291116487b15277d27a391fb9a","modified":1638439684715},{"_id":"themes/stun/layout/_partials/search/index.pug","hash":"0f84aa013a96e7eb3bb25b87f20bab9b7ac55538","modified":1638439684715},{"_id":"themes/stun/layout/_partials/search/localsearch.pug","hash":"4d8e0bc33f92a603e0b2a5f4296af6bcc7cc31b8","modified":1638439684716},{"_id":"themes/stun/layout/_partials/sidebar/sidebar.pug","hash":"18173a2acf99db39748c392f2e669acd805b4090","modified":1638439684716},{"_id":"themes/stun/layout/_partials/widgets/comments.pug","hash":"af1b16be74c7e1242e0f57986672dc73e93546e2","modified":1638439684717},{"_id":"themes/stun/layout/_partials/widgets/copyright.pug","hash":"0938c885697f6eb388b28ddbf88f5631d024fe73","modified":1638439684718},{"_id":"themes/stun/layout/_partials/widgets/back2top.pug","hash":"48b7fedeb472bd01fd1f3317359a10e83ca919e1","modified":1638439684717},{"_id":"themes/stun/layout/_partials/widgets/loading-bar.pug","hash":"6cda7866f9589c9ffc05ce4a3d7c33b706e70324","modified":1638439684718},{"_id":"themes/stun/layout/_partials/widgets/night-mode.pug","hash":"c7f9bd67cd231b9bd40a84123644e009ac8d8ef3","modified":1638439684718},{"_id":"themes/stun/layout/_partials/widgets/paginator.pug","hash":"b0045dcb9b151ee31f1db5b7d741f10ef3b74be0","modified":1638439684719},{"_id":"themes/stun/layout/_partials/widgets/reward.pug","hash":"c9081c1dcf0ca18df06d23638654d8f43b28d55c","modified":1638439684719},{"_id":"themes/stun/layout/_partials/widgets/share.pug","hash":"1bb3d25298b7ee6a28150aa286ed6b0ae42ead4f","modified":1638439684719},{"_id":"themes/stun/layout/_partials/widgets/sticky-top.pug","hash":"bf86b2f9f4b1471afb8b31965d3230f6088682ae","modified":1638439684720},{"_id":"themes/stun/source/css/_common/components/index.styl","hash":"a54720db94121efd1a34ac88d344197c8206837e","modified":1638439684738},{"_id":"themes/stun/source/css/_common/outline/index.styl","hash":"467d4171c0690a95d40fbecea02e6b212b7c74f1","modified":1638439684749},{"_id":"themes/stun/source/css/_common/outline/macro.styl","hash":"13b96f239de15e1cfdc14d9c80e6959506556dd2","modified":1638439684749},{"_id":"themes/stun/source/css/_common/scaffolding/base.styl","hash":"4064a7e2c3f71d2ed72a47edd60e9be01af6c354","modified":1638439684750},{"_id":"themes/stun/source/css/_common/scaffolding/index.styl","hash":"e750f2dae9eb3385039ee018ff8001b0e6ec3b64","modified":1638439684751},{"_id":"themes/stun/source/css/_common/scaffolding/normalize.styl","hash":"c15a9616fddb267431416304d709185aeb3d45f5","modified":1638439684751},{"_id":"themes/stun/source/css/_common/scaffolding/utils.styl","hash":"7e62f34521ea539a25a101f25e1684e3a3ac4be8","modified":1638439684751},{"_id":"themes/stun/source/css/_common/components/analytics/busuanzi.styl","hash":"d196c88ea2e9b851e8d8f9c5a315dfc2929eb897","modified":1638439684734},{"_id":"themes/stun/source/css/_common/components/analytics/index.styl","hash":"339a43fd5ee97a77775b723118f6ab1af754fed4","modified":1638439684735},{"_id":"themes/stun/source/css/_common/components/footer/index.styl","hash":"14464841145cf3ecab66f1094653daa033c261eb","modified":1638439684735},{"_id":"themes/stun/source/css/_common/components/header/index.styl","hash":"904af0e73cdf0767ec781271856d7b5b63e043ef","modified":1638439684736},{"_id":"themes/stun/source/css/_common/components/highlight/diff.styl","hash":"056e70f6dfe45ec50427d7ab293d33361c9b956f","modified":1638439684736},{"_id":"themes/stun/source/css/_common/components/highlight/highlight.styl","hash":"bc0b01021a0d19b2c98f0c5c9fa1af96d67c1099","modified":1638439684737},{"_id":"themes/stun/source/css/_common/components/highlight/index.styl","hash":"85848179cbc78152d2521b601ac9f888dea4e255","modified":1638439684737},{"_id":"themes/stun/source/css/_common/components/highlight/theme.styl","hash":"dfc99b05302f8203040431e563c9f63d63da46de","modified":1638439684737},{"_id":"themes/stun/source/css/_common/components/pages/index.styl","hash":"463a4e6a92ec5f757e167fbeb171e4e92e83a822","modified":1638439684738},{"_id":"themes/stun/source/css/_common/components/pages/page.styl","hash":"df732e267dfd9f1bda6a8cf1ede3198a205925f9","modified":1638439684739},{"_id":"themes/stun/source/css/_common/components/pages/timeline.styl","hash":"21e9c8def1613030f0927e2ce80f4ecc721f078e","modified":1638439684739},{"_id":"themes/stun/source/css/_common/components/plugins/index.styl","hash":"c35d0cf421c6669ee0458c2f0264dca05769c01d","modified":1638439684740},{"_id":"themes/stun/source/css/_common/components/plugins/friends.styl","hash":"bdb015173f8e5fa391fc4fb2b2a8d42787022c4b","modified":1638439684739},{"_id":"themes/stun/source/css/_common/components/plugins/note.styl","hash":"ae0ad9b44a87839d220792336478a9ae6db11c47","modified":1638439684740},{"_id":"themes/stun/source/css/_common/components/plugins/table.styl","hash":"98cacc91e42f5e45279e2174a90ab26171085e2f","modified":1638439684740},{"_id":"themes/stun/source/css/_common/components/post/index.styl","hash":"08aad11e329cda0550efef226e0c4d0bb4540454","modified":1638439684740},{"_id":"themes/stun/source/css/_common/components/post/post-list.styl","hash":"d0ed844e28533f832cbd9b3f09203d16936628f7","modified":1638439684741},{"_id":"themes/stun/source/css/_common/components/post/post.styl","hash":"8b7b22225b40d028efee689d3700a9796291cb8d","modified":1638439684741},{"_id":"themes/stun/source/css/_common/components/search/algolia.styl","hash":"fb62e4baf25a66e46c27783be5d79353ec394b44","modified":1638439684741},{"_id":"themes/stun/source/css/_common/components/search/common.styl","hash":"1939b7dfbcf557794a188fbf8fec4ef2b5afa437","modified":1638439684741},{"_id":"themes/stun/source/css/_common/components/search/index.styl","hash":"1990d2c2a9bfe8e09d656f0c2ae6cf0c9f7f5542","modified":1638439684742},{"_id":"themes/stun/source/css/_common/components/widgets/back2top.styl","hash":"b3da5ea71a9947e781056d1bd7d42e4045fa2aca","modified":1638439684743},{"_id":"themes/stun/source/css/_common/components/search/localsearch.styl","hash":"bf1ac1b8ee8c4daaa7e6b47eec097a176624e6d0","modified":1638439684742},{"_id":"themes/stun/source/css/_common/components/sidebar/index.styl","hash":"02138647437f7e8ee8927cae225d41072d936bdc","modified":1638439684743},{"_id":"themes/stun/source/css/_common/components/widgets/comments.styl","hash":"41d229ac4fa02a3a8b46687ccbafa7a608008e2f","modified":1638439684744},{"_id":"themes/stun/source/css/_common/components/widgets/copyright.styl","hash":"1d28fc8f76f7164a306ed81a9ede21c0a2b0f7cd","modified":1638439684744},{"_id":"themes/stun/source/css/_common/components/widgets/copy-button.styl","hash":"378961fa7c986e3313053814806902bf76204a93","modified":1638439684744},{"_id":"themes/stun/source/css/_common/components/widgets/fancybox.styl","hash":"3d677c0323d77199bb9fbfefd65e97d8b882d7b3","modified":1638439684745},{"_id":"themes/stun/source/css/_common/components/widgets/ending.styl","hash":"63985ca9a3f6c481cc60207966fa1267de14d945","modified":1638439684744},{"_id":"themes/stun/source/css/_common/components/widgets/gallery-image.styl","hash":"99b1cc42f38816083f93233778b299422b6d8f32","modified":1638439684745},{"_id":"themes/stun/source/css/_common/components/widgets/index.styl","hash":"03ffdc55fd5fb64c3158bc222d0e8e9d7844686b","modified":1638439684745},{"_id":"themes/stun/source/css/_common/components/widgets/font-icon.styl","hash":"bdda0953611378e93a8d6387cbdc93e1de4f7f0a","modified":1638439684745},{"_id":"themes/stun/source/css/_common/components/widgets/lazyload.styl","hash":"eced96235f0ff5dc6a8fd068d4ed05934a29b430","modified":1638439684746},{"_id":"themes/stun/source/css/_common/components/widgets/loading-bar.styl","hash":"9f23e8762d01fb4a3cbf5e786fdead2926849e8a","modified":1638439684746},{"_id":"themes/stun/source/css/_common/components/widgets/night-mode.styl","hash":"9caeef13a913aba38976f082e1f0ca191bffc64e","modified":1638439684746},{"_id":"themes/stun/source/css/_common/components/widgets/paginator.styl","hash":"71ddb6a1e9664a4fde04a0ce143b8786ba6e0089","modified":1638439684746},{"_id":"themes/stun/source/css/_common/components/widgets/reward.styl","hash":"de1130ec3765879884cbdc77a15b458da6e37bcc","modified":1638439684746},{"_id":"themes/stun/source/css/_common/components/widgets/share.styl","hash":"fe32e3434107d92cefd7aacfdcef526a93c4b865","modified":1638439684748},{"_id":"themes/stun/source/css/_common/components/widgets/sticky-top.styl","hash":"f0e37944168a74a64b18dc54c6fde2308e4bf023","modified":1638439684748},{"_id":"themes/stun/source/css/_common/components/widgets/zoom-image.styl","hash":"40f832a199320642debabe32910c1168e3c6e40c","modified":1638439684748},{"_id":"source/_posts/vue原理初探.md","hash":"88e3bea9e84be0e727b34739a727e0368579e6a2","modified":1639987825698},{"_id":"source/_posts/快速入门react.md","hash":"66e141ad96f93d115a7aef9869bf0b19bd67f04a","modified":1639987314221},{"_id":"source/_posts/快速入门vue.md","hash":"2a4740e1abdd7cd499078039eb7a81e68eb6a9e5","modified":1639987283692},{"_id":"source/_posts/vue原理初探/vue原理1.png","hash":"7071337f9071f93ebf85639ede38b0f40fd75d98","modified":1639986833003},{"_id":"source/_posts/前端工程化最佳实践.md","hash":"7cff17f863d0f7e2de939bf18de8f31e54ccf62f","modified":1639989902612},{"_id":"source/_posts/如何用vue造轮子.md","hash":"6223cbc7be3fd75d8a2b4e694cdb031d443be347","modified":1639986914833},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1635388120893},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1635388120892},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1635388120895},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1635388120895},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1635388120897},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1635388120896},{"_id":"themes/landscape/_config.yml","hash":"b07a4fa731f2a789ed1fbda6e77bcf4e4f142a90","modified":1635403410264},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1635388120897},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1635388120898},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1635388120898},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1635388120898},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1635388120898},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1635388120899},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1635388120899},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1635388120899},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1635388120899},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1635388120899},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1635388120899},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1635388120900},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1635388120900},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1635388120900},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1635388120901},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1635388120901},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1635388120901},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1635388120901},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1635388120905},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1635388120907},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1635388120905},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1635388120905},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1635388120907},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1635388120907},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1635388120908},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1635388120908},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1635388120908},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1635388120909},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1635388120903},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1635388120898},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1635388120909},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1635388120911},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1635388120909},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1635388120909},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1635388120924},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1635388120924},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1635388120921},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1635388120923},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1635388120903},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1635388120921},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1635388120921},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1635388120923},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1635388120921},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1635388120923},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1635388120923},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1635388120920},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1635388120924},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1635388120913},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1635388120912},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1635388120911},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1635388120912},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1635388120913},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1635388120913},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1635388120924},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1635388120930},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1635388120930},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1635388120930},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1635388120931},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1635388120931},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1635388120931},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1635388120933},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1635388120933},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1635388120932},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1635388120920},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1635388120926},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1635388120934},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1635388120926},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1635388120935},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1635388120925},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1635388120933},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1635388120935},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1635388120925},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1635388120926},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1635388120926},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1635388120912},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1635388120934},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1635388120935},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1635388120932},{"_id":"source/_posts/快速学会echarts.md","hash":"33983f88505ff64990ef57d4c221429d451b58f0","modified":1639988618927},{"_id":"source/_posts/三分钟了解gitactions.md","hash":"e0b04e557d199db871feaca8d9e5a0fd6dea8fa7","modified":1639994360625},{"_id":"public/about/index.html","hash":"97b42d8b8a01c42a5bedffcfd951a3945c2e638b","modified":1639995601303},{"_id":"public/2021/12/01/三分钟了解gitactions/index.html","hash":"d2eb175a2788590f5e65b0de381c5ecde7a83139","modified":1639995601303},{"_id":"public/2021/11/20/前端工程化最佳实践/index.html","hash":"0128607c87510d3e58b14d256fb4126e1b4c83b4","modified":1639995601303},{"_id":"public/2021/10/31/快速入门react/index.html","hash":"94b7303392f97e5eb9591f4199984c7750e662de","modified":1639995601303},{"_id":"public/2021/10/30/react-hooks/index.html","hash":"1404618ac5141eaa66385ac4a5575c41eb8e8a4f","modified":1639995601303},{"_id":"public/2021/10/29/前端综合面试题/index.html","hash":"893412c8a344cc4c205ceb771aae3f0b4d2193a4","modified":1639995601303},{"_id":"public/2021/10/29/大屏数据可视化项目开发/index.html","hash":"1c58b70a0462b98af524ada82118fc1c9e815406","modified":1639995601303},{"_id":"public/2021/10/29/http介绍/index.html","hash":"ad62faba8a11d6398d20e4ff57f809485faa5d7c","modified":1639995601303},{"_id":"public/2021/10/29/flex使用介绍/index.html","hash":"b9968104afde8c7382f7bd142288b7127517ca78","modified":1639995601303},{"_id":"public/2021/10/29/koa使用介绍/index.html","hash":"6e4e38726bc6d15afcffdf91e89e51eadfc50232","modified":1639995601303},{"_id":"public/2021/10/29/如何用vue造轮子/index.html","hash":"96a6ba666e818b148c522d53f9055b97429ac134","modified":1639995601303},{"_id":"public/2021/10/29/hexo搭建博客/index.html","hash":"6d041aec2ec78f51625912e9819d394e6c145fda","modified":1639995601303},{"_id":"public/2021/06/29/vue原理初探/index.html","hash":"209d32eeceaeb2c0725dc8285936c303b5c3ccda","modified":1639995601303},{"_id":"public/2021/05/20/react面试题/index.html","hash":"018d33070e2847a675fe5239cc7287b2af3e5941","modified":1639995601303},{"_id":"public/2021/02/20/快速学会echarts/index.html","hash":"fd4d0c7aec6baa7eeb42c75e4f0f76001660b09f","modified":1639995601303},{"_id":"public/2021/01/10/vue面试题/index.html","hash":"be4965a251101119167b2b86ea45d969973a21c1","modified":1639995601303},{"_id":"public/2020/10/29/css面试题/index.html","hash":"d4219266ed408b54a20cc64b1876451061a418ec","modified":1639995601303},{"_id":"public/2020/01/30/javascript入门教程/index.html","hash":"7ecd36b04cc15a4541ed722515f53d15e066e115","modified":1639995601303},{"_id":"public/archives/index.html","hash":"cf6d3ac2c9a0024f410dc7a3961ead7a9660779c","modified":1639995601303},{"_id":"public/archives/page/2/index.html","hash":"859d534648f02d8987c779f10a4db20888396caa","modified":1639995601303},{"_id":"public/archives/2020/index.html","hash":"6007fab535fb4efe95498a8e5ac7bca8779bc2a3","modified":1639995601303},{"_id":"public/archives/2020/01/index.html","hash":"1820d37c76722cfe3e118868fb19929c6c8f71e3","modified":1639995601303},{"_id":"public/archives/2020/10/index.html","hash":"243b6910fac874a109ac5d2dc060eb950c8016f1","modified":1639995601303},{"_id":"public/archives/2021/index.html","hash":"603433e1e0bd474636f078aef8c82d3ed99d2854","modified":1639995601303},{"_id":"public/archives/2021/page/2/index.html","hash":"09a8798cf7d73e376b470636511d0c415e4caf60","modified":1639995601303},{"_id":"public/archives/2021/01/index.html","hash":"9746c956f737053b081f257a1ea8ad69ddb217d6","modified":1639995601303},{"_id":"public/archives/2021/02/index.html","hash":"76ade6f32d9f44d317e0ec78d8c83e18f1254c1b","modified":1639995601303},{"_id":"public/archives/2021/05/index.html","hash":"976cbf0bbcf2ab3d590d878b3c7599142336d2da","modified":1639995601303},{"_id":"public/archives/2021/06/index.html","hash":"896694274be8f06551ef8b3b051fb76ad444c323","modified":1639995601303},{"_id":"public/archives/2021/10/index.html","hash":"859e7ee4140d07260657b3a60a59dea26f2782ff","modified":1639995601303},{"_id":"public/archives/2021/10/page/2/index.html","hash":"2b2d9ce11c9f34bb47fafb3476d762ed9829cc9d","modified":1639995601303},{"_id":"public/archives/2021/11/index.html","hash":"b8338c9a29e6af89605821d258bd5e650ba19ae8","modified":1639995601303},{"_id":"public/archives/2021/12/index.html","hash":"031b889817378cf1f12e70f743b2a2c9863d8afa","modified":1639995601303},{"_id":"public/2021/10/31/快速入门vue/index.html","hash":"cce52ebf40cfe16b6f45bf5d70de5209000843f0","modified":1639995601303},{"_id":"public/2021/10/29/es6入门/index.html","hash":"e9e1a91b2a89c2687d261410e640b6ec13b5eb05","modified":1639995601303},{"_id":"public/2021/10/29/基于vue开发的CRM系统/index.html","hash":"bc0ae5d8b4f424d5e5841d27f9651ca6c8890cda","modified":1639995601303},{"_id":"public/index.html","hash":"ff121e52bcaa5d3d4d9bbd5596eab7dd8cc98a08","modified":1639995601303},{"_id":"public/page/2/index.html","hash":"3cf0dddb18f51d17839c84c0942466468ccc3569","modified":1639995601303},{"_id":"public/demo/echarts.html","hash":"2878668298046210335b3d051ca7b69cf04fdb95","modified":1639995601303},{"_id":"public/images/algolia.svg","hash":"90322f80db6ad0daf26ea3ec71dea6f691a8b2f1","modified":1639995601303},{"_id":"public/images/cc-by-nc.svg","hash":"4608189edbe7636dd651df65473298a3c5afb20d","modified":1639995601303},{"_id":"public/images/cc-by-nc-sa.svg","hash":"71d035c34219f924dbf1bf852166ee8fb58d2f24","modified":1639995601303},{"_id":"public/images/cc-by-nc-nd.svg","hash":"017ad912874686a982ebceae359299b8f2a492e2","modified":1639995601303},{"_id":"public/images/cc-by.svg","hash":"77f74c241902447424207869c74cb9d9264bdced","modified":1639995601303},{"_id":"public/images/cc-by-sa.svg","hash":"0455a8857ba096925d4145a56e8d10537fccb378","modified":1639995601303},{"_id":"public/images/icons/favicon-16x16.png","hash":"7bfd64eac26e17ea162f0c399a4a40164c26b412","modified":1639995601303},{"_id":"public/images/loading.svg","hash":"32a6e770d217ae6c0cf0f6beef3172f1b5b9a0a2","modified":1639995601303},{"_id":"public/images/icons/favicon-32x32.png","hash":"02fead07726920400ede57ddfdbf071dd7203fd5","modified":1639995601303},{"_id":"public/images/icons/stun-logo.svg","hash":"069dc7590ad152373f1c346d892e32faa2bbdd87","modified":1639995601303},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1639995601303},{"_id":"public/images/cc-by-nd.svg","hash":"20c66ae3c393903e6eab3bc8cf7c3be6d753f9f8","modified":1639995601303},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1639995601303},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1639995601303},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1639995601303},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1639995601303},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1639995601303},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1639995601303},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1639995601303},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1639995601303},{"_id":"public/2021/10/29/flex使用介绍/flex_3.png","hash":"49ec2f8667a4908eb703ecfc53bfcbda645c2c5c","modified":1639995601303},{"_id":"public/2021/10/29/flex使用介绍/flex_1.png","hash":"1ecaac9b18d66edf3ab7aeaadde91dd7b47ac4f5","modified":1639995601303},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1639995601303},{"_id":"public/2021/10/29/flex使用介绍/flex_5.png","hash":"caf8db94cfd01a729a0c55b3b0b6811cc522dd83","modified":1639995601303},{"_id":"public/2021/10/29/flex使用介绍/flex_2.png","hash":"20fe8f5dad5fa18bf4d7f1971d922ca43087db4a","modified":1639995601303},{"_id":"public/2021/10/29/flex使用介绍/flex_4.png","hash":"28068f3962f468c5276e09c12eac4f370fd3d026","modified":1639995601303},{"_id":"public/2021/10/29/http介绍/httpmessage.jpeg","hash":"e904165bc50bc37477449ff8b339610be5f82fa1","modified":1639995601303},{"_id":"public/2021/06/29/vue原理初探/vue原理1.png","hash":"7071337f9071f93ebf85639ede38b0f40fd75d98","modified":1639995601303},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1639995601303},{"_id":"public/js/sidebar.js","hash":"20adff7f54bcd8299d32690d41ebc7a4eb7a8728","modified":1639995601303},{"_id":"public/js/header.js","hash":"63d407ee6f80114e220171ba829b79b28d420fe0","modified":1639995601303},{"_id":"public/css/index.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639995601303},{"_id":"public/js/scroll.js","hash":"8926ab87181a49c730ce5132518b608c54b8cdb1","modified":1639995601303},{"_id":"public/js/stun-boot.js","hash":"8358ac0d879c0ca340c52e4de606523c2a91e156","modified":1639995601303},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1639995601303},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1639995601303},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1639995601303},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1639995601303},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1639995601303},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1639995601303},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1639995601303},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1639995601303},{"_id":"public/2021/10/29/前端综合面试题/csrf.jpeg","hash":"f5a8dc04304bf47b66a2a1486dcec6f1713e31bc","modified":1639995601303},{"_id":"public/js/utils.js","hash":"b570eafe77e47d7701348f172a4dbaaba6fa8123","modified":1639995601303},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1639995601303},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1639995601303},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1639995601303},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1639995601303}],"Category":[],"Data":[],"Page":[{"_content":"##### 关于我\n\n##### 职业：前端开发\n\n##### 技术栈：html css javascript vue react webpack node.js \n\n##### 邮箱：carrlu@163.com\n\n##### github: \n\n##### gitee:\n\n##### 个人博客: https://www.carrlu.cn\n\n","source":"about/index.md","raw":"##### 关于我\n\n##### 职业：前端开发\n\n##### 技术栈：html css javascript vue react webpack node.js \n\n##### 邮箱：carrlu@163.com\n\n##### github: \n\n##### gitee:\n\n##### 个人博客: https://www.carrlu.cn\n\n","date":"2021-10-30T01:20:29.400Z","updated":"2021-10-30T01:20:29.400Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"ckwou9u4t00009hwnf9hw419n","content":"\n        <h5 id=\"关于我\">\n          <a href=\"#关于我\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h5>\n      \n        <h5 id=\"职业：前端开发\">\n          <a href=\"#职业：前端开发\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#职业：前端开发\" class=\"headerlink\" title=\"职业：前端开发\"></a>职业：前端开发</h5>\n      \n        <h5 id=\"技术栈：html-css-javascript-vue-react-webpack-node-js\">\n          <a href=\"#技术栈：html-css-javascript-vue-react-webpack-node-js\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#技术栈：html-css-javascript-vue-react-webpack-node-js\" class=\"headerlink\" title=\"技术栈：html css javascript vue react webpack node.js\"></a>技术栈：html css javascript vue react webpack node.js</h5>\n      \n        <h5 id=\"邮箱：-x63-x61-x72-114-x6c-x75-64-x31-x36-51-x2e-99-x6f-109\">\n          <a href=\"#邮箱：-x63-x61-x72-114-x6c-x75-64-x31-x36-51-x2e-99-x6f-109\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#邮箱：-x63-x61-x72-114-x6c-x75-64-x31-x36-51-x2e-99-x6f-109\" class=\"headerlink\" title=\"邮箱：&#x63;&#x61;&#x72;&#114;&#x6c;&#x75;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;\"></a>邮箱：<span class=\"exturl\"><a class=\"exturl__link\" href=\"mailto:&#x63;&#x61;&#x72;&#114;&#x6c;&#x75;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;\">&#x63;&#x61;&#x72;&#114;&#x6c;&#x75;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></h5>\n      \n        <h5 id=\"github\">\n          <a href=\"#github\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#github\" class=\"headerlink\" title=\"github:\"></a>github:</h5>\n      \n        <h5 id=\"gitee\">\n          <a href=\"#gitee\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#gitee\" class=\"headerlink\" title=\"gitee:\"></a>gitee:</h5>\n      \n        <h5 id=\"个人博客-https-www-carrlu-cn\">\n          <a href=\"#个人博客-https-www-carrlu-cn\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#个人博客-https-www-carrlu-cn\" class=\"headerlink\" title=\"个人博客: https://www.carrlu.cn\"></a>个人博客: <span class=\"exturl\"><a class=\"exturl__link\" href=\"https://www.carrlu.cn/\">https://www.carrlu.cn</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></h5>\n      ","site":{"data":{}},"excerpt":"","more":"\n        <h5 id=\"关于我\">\n          <a href=\"#关于我\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h5>\n      \n        <h5 id=\"职业：前端开发\">\n          <a href=\"#职业：前端开发\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#职业：前端开发\" class=\"headerlink\" title=\"职业：前端开发\"></a>职业：前端开发</h5>\n      \n        <h5 id=\"技术栈：html-css-javascript-vue-react-webpack-node-js\">\n          <a href=\"#技术栈：html-css-javascript-vue-react-webpack-node-js\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#技术栈：html-css-javascript-vue-react-webpack-node-js\" class=\"headerlink\" title=\"技术栈：html css javascript vue react webpack node.js\"></a>技术栈：html css javascript vue react webpack node.js</h5>\n      \n        <h5 id=\"邮箱：-x63-x61-x72-114-x6c-x75-64-x31-x36-51-x2e-99-x6f-109\">\n          <a href=\"#邮箱：-x63-x61-x72-114-x6c-x75-64-x31-x36-51-x2e-99-x6f-109\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#邮箱：-x63-x61-x72-114-x6c-x75-64-x31-x36-51-x2e-99-x6f-109\" class=\"headerlink\" title=\"邮箱：&#x63;&#x61;&#x72;&#114;&#x6c;&#x75;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;\"></a>邮箱：<span class=\"exturl\"><a class=\"exturl__link\" href=\"mailto:&#x63;&#x61;&#x72;&#114;&#x6c;&#x75;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;\">&#x63;&#x61;&#x72;&#114;&#x6c;&#x75;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></h5>\n      \n        <h5 id=\"github\">\n          <a href=\"#github\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#github\" class=\"headerlink\" title=\"github:\"></a>github:</h5>\n      \n        <h5 id=\"gitee\">\n          <a href=\"#gitee\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#gitee\" class=\"headerlink\" title=\"gitee:\"></a>gitee:</h5>\n      \n        <h5 id=\"个人博客-https-www-carrlu-cn\">\n          <a href=\"#个人博客-https-www-carrlu-cn\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#个人博客-https-www-carrlu-cn\" class=\"headerlink\" title=\"个人博客: https://www.carrlu.cn\"></a>个人博客: <span class=\"exturl\"><a class=\"exturl__link\" href=\"https://www.carrlu.cn/\">https://www.carrlu.cn</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></h5>\n      "}],"Post":[{"title":"css面试题","date":"2020-10-29T06:25:25.000Z","_content":"\n##### 1.清除浮动的方法？\n\n##### 2.关于BFC?\n（1）什么时BFC\nBFC（Block Formatting Context）格式化上下文，是web页面中盒模型布局的CSS渲染模式\n，指一个独立的渲染区域或者说是一个隔离的独立容器，如果一个元素符合触发BFC的条件，则该元素中的布局\n不受外部影响\n\n（2）形成BFC的条件\n- 浮动元素：float = left | right | inherit\n- 绝对定位元素： position = absolute ｜ fixed\n- display = inline-block ｜ table-cell ｜ table-caption\n- overflow = hidden ｜ auto｜scroll\n\n（3）BFC特性\n- 内部的BOX会在垂直方向上一个接一个的放置\n- 垂直方向上的距离由margin决定\n- bfc的区域不会与float的元素区域重叠\n- 计算bfc高度时，浮动元素也参与计算\n- bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素\n\n\n##### 3.未知宽高元素上下左右居中\n\n##### 4.已知元素的上下左右居中\n\n##### 5.display:none 和 visibility: hidden的区别？\ndisplay:none 元素后代以及它的所有后代元素都会隐藏，隐藏后元素无法点击，占据的空间消失\n\nvisibility: hidden 隐藏元素仍需占据空间，父元素设置visibility: hidden，子元素也会\n继承这个属性\n\n##### 6.列举css的几种单位\n相对长度\n- em    它是描述相对于应用在当前元素的字体尺寸\n- rem   是根 em（root em）的缩写，rem作用于非根元素时，相对于根元素字体大小\n- vh    viewpoint height，视窗高度，1vh=视窗高度的1%\n- vw    viewpoint width，视窗宽度，1vw=视窗宽度的1%\n- vmin  vw和vh中较小的那个\n- vmax  vw和vh中较大的那个\n- %     相对父元素   \n\n绝对长度\n- cm    厘米\n- mm    毫米\n- in    英寸\n- px    像素\n- pt    point，大约1/72英寸\n","source":"_posts/css面试题.md","raw":"---\ntitle: css面试题\ndate: 2020-10-29 14:25:25\ntags:\n---\n\n##### 1.清除浮动的方法？\n\n##### 2.关于BFC?\n（1）什么时BFC\nBFC（Block Formatting Context）格式化上下文，是web页面中盒模型布局的CSS渲染模式\n，指一个独立的渲染区域或者说是一个隔离的独立容器，如果一个元素符合触发BFC的条件，则该元素中的布局\n不受外部影响\n\n（2）形成BFC的条件\n- 浮动元素：float = left | right | inherit\n- 绝对定位元素： position = absolute ｜ fixed\n- display = inline-block ｜ table-cell ｜ table-caption\n- overflow = hidden ｜ auto｜scroll\n\n（3）BFC特性\n- 内部的BOX会在垂直方向上一个接一个的放置\n- 垂直方向上的距离由margin决定\n- bfc的区域不会与float的元素区域重叠\n- 计算bfc高度时，浮动元素也参与计算\n- bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素\n\n\n##### 3.未知宽高元素上下左右居中\n\n##### 4.已知元素的上下左右居中\n\n##### 5.display:none 和 visibility: hidden的区别？\ndisplay:none 元素后代以及它的所有后代元素都会隐藏，隐藏后元素无法点击，占据的空间消失\n\nvisibility: hidden 隐藏元素仍需占据空间，父元素设置visibility: hidden，子元素也会\n继承这个属性\n\n##### 6.列举css的几种单位\n相对长度\n- em    它是描述相对于应用在当前元素的字体尺寸\n- rem   是根 em（root em）的缩写，rem作用于非根元素时，相对于根元素字体大小\n- vh    viewpoint height，视窗高度，1vh=视窗高度的1%\n- vw    viewpoint width，视窗宽度，1vw=视窗宽度的1%\n- vmin  vw和vh中较小的那个\n- vmax  vw和vh中较大的那个\n- %     相对父元素   \n\n绝对长度\n- cm    厘米\n- mm    毫米\n- in    英寸\n- px    像素\n- pt    point，大约1/72英寸\n","slug":"css面试题","published":1,"updated":"2021-12-20T08:22:50.830Z","_id":"ckwou9u5a00039hwn9ei4f1sf","comments":1,"layout":"post","photos":[],"link":"","content":"<h5 id=\"1-清除浮动的方法？\"><a href=\"#1-清除浮动的方法？\" class=\"headerlink\" title=\"1.清除浮动的方法？\"></a>1.清除浮动的方法？</h5><h5 id=\"2-关于BFC\"><a href=\"#2-关于BFC\" class=\"headerlink\" title=\"2.关于BFC?\"></a>2.关于BFC?</h5><p>（1）什么时BFC<br>BFC（Block Formatting Context）格式化上下文，是web页面中盒模型布局的CSS渲染模式<br>，指一个独立的渲染区域或者说是一个隔离的独立容器，如果一个元素符合触发BFC的条件，则该元素中的布局<br>不受外部影响</p>\n<p>（2）形成BFC的条件</p>\n<ul>\n<li>浮动元素：float = left | right | inherit</li>\n<li>绝对定位元素： position = absolute ｜ fixed</li>\n<li>display = inline-block ｜ table-cell ｜ table-caption</li>\n<li>overflow = hidden ｜ auto｜scroll</li>\n</ul>\n<p>（3）BFC特性</p>\n<ul>\n<li>内部的BOX会在垂直方向上一个接一个的放置</li>\n<li>垂直方向上的距离由margin决定</li>\n<li>bfc的区域不会与float的元素区域重叠</li>\n<li>计算bfc高度时，浮动元素也参与计算</li>\n<li>bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素</li>\n</ul>\n<h5 id=\"3-未知宽高元素上下左右居中\"><a href=\"#3-未知宽高元素上下左右居中\" class=\"headerlink\" title=\"3.未知宽高元素上下左右居中\"></a>3.未知宽高元素上下左右居中</h5><h5 id=\"4-已知元素的上下左右居中\"><a href=\"#4-已知元素的上下左右居中\" class=\"headerlink\" title=\"4.已知元素的上下左右居中\"></a>4.已知元素的上下左右居中</h5><h5 id=\"5-display-none-和-visibility-hidden的区别？\"><a href=\"#5-display-none-和-visibility-hidden的区别？\" class=\"headerlink\" title=\"5.display:none 和 visibility: hidden的区别？\"></a>5.display:none 和 visibility: hidden的区别？</h5><p>display:none 元素后代以及它的所有后代元素都会隐藏，隐藏后元素无法点击，占据的空间消失</p>\n<p>visibility: hidden 隐藏元素仍需占据空间，父元素设置visibility: hidden，子元素也会<br>继承这个属性</p>\n<h5 id=\"6-列举css的几种单位\"><a href=\"#6-列举css的几种单位\" class=\"headerlink\" title=\"6.列举css的几种单位\"></a>6.列举css的几种单位</h5><p>相对长度</p>\n<ul>\n<li>em    它是描述相对于应用在当前元素的字体尺寸</li>\n<li>rem   是根 em（root em）的缩写，rem作用于非根元素时，相对于根元素字体大小</li>\n<li>vh    viewpoint height，视窗高度，1vh=视窗高度的1%</li>\n<li>vw    viewpoint width，视窗宽度，1vw=视窗宽度的1%</li>\n<li>vmin  vw和vh中较小的那个</li>\n<li>vmax  vw和vh中较大的那个</li>\n<li>%     相对父元素   </li>\n</ul>\n<p>绝对长度</p>\n<ul>\n<li>cm    厘米</li>\n<li>mm    毫米</li>\n<li>in    英寸</li>\n<li>px    像素</li>\n<li>pt    point，大约1/72英寸</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"1-清除浮动的方法？\"><a href=\"#1-清除浮动的方法？\" class=\"headerlink\" title=\"1.清除浮动的方法？\"></a>1.清除浮动的方法？</h5><h5 id=\"2-关于BFC\"><a href=\"#2-关于BFC\" class=\"headerlink\" title=\"2.关于BFC?\"></a>2.关于BFC?</h5><p>（1）什么时BFC<br>BFC（Block Formatting Context）格式化上下文，是web页面中盒模型布局的CSS渲染模式<br>，指一个独立的渲染区域或者说是一个隔离的独立容器，如果一个元素符合触发BFC的条件，则该元素中的布局<br>不受外部影响</p>\n<p>（2）形成BFC的条件</p>\n<ul>\n<li>浮动元素：float = left | right | inherit</li>\n<li>绝对定位元素： position = absolute ｜ fixed</li>\n<li>display = inline-block ｜ table-cell ｜ table-caption</li>\n<li>overflow = hidden ｜ auto｜scroll</li>\n</ul>\n<p>（3）BFC特性</p>\n<ul>\n<li>内部的BOX会在垂直方向上一个接一个的放置</li>\n<li>垂直方向上的距离由margin决定</li>\n<li>bfc的区域不会与float的元素区域重叠</li>\n<li>计算bfc高度时，浮动元素也参与计算</li>\n<li>bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素</li>\n</ul>\n<h5 id=\"3-未知宽高元素上下左右居中\"><a href=\"#3-未知宽高元素上下左右居中\" class=\"headerlink\" title=\"3.未知宽高元素上下左右居中\"></a>3.未知宽高元素上下左右居中</h5><h5 id=\"4-已知元素的上下左右居中\"><a href=\"#4-已知元素的上下左右居中\" class=\"headerlink\" title=\"4.已知元素的上下左右居中\"></a>4.已知元素的上下左右居中</h5><h5 id=\"5-display-none-和-visibility-hidden的区别？\"><a href=\"#5-display-none-和-visibility-hidden的区别？\" class=\"headerlink\" title=\"5.display:none 和 visibility: hidden的区别？\"></a>5.display:none 和 visibility: hidden的区别？</h5><p>display:none 元素后代以及它的所有后代元素都会隐藏，隐藏后元素无法点击，占据的空间消失</p>\n<p>visibility: hidden 隐藏元素仍需占据空间，父元素设置visibility: hidden，子元素也会<br>继承这个属性</p>\n<h5 id=\"6-列举css的几种单位\"><a href=\"#6-列举css的几种单位\" class=\"headerlink\" title=\"6.列举css的几种单位\"></a>6.列举css的几种单位</h5><p>相对长度</p>\n<ul>\n<li>em    它是描述相对于应用在当前元素的字体尺寸</li>\n<li>rem   是根 em（root em）的缩写，rem作用于非根元素时，相对于根元素字体大小</li>\n<li>vh    viewpoint height，视窗高度，1vh=视窗高度的1%</li>\n<li>vw    viewpoint width，视窗宽度，1vw=视窗宽度的1%</li>\n<li>vmin  vw和vh中较小的那个</li>\n<li>vmax  vw和vh中较大的那个</li>\n<li>%     相对父元素   </li>\n</ul>\n<p>绝对长度</p>\n<ul>\n<li>cm    厘米</li>\n<li>mm    毫米</li>\n<li>in    英寸</li>\n<li>px    像素</li>\n<li>pt    point，大约1/72英寸</li>\n</ul>\n"},{"title":"es6入门","date":"2021-10-29T06:25:17.000Z","_content":"\n##### 1. let const\n(1) let用于定义变量，const用于定义常量\n(2) let、const存在块级作用域\n(3) let不与许在同作用域内重复声明\n(4) const一旦声明不可改变\n(5) const声明不可重复\n(6) 不存在变量提升，必须先声明再使用\n\n##### 2. 解构赋值\n（1）数组解构赋值\n```\nlet [a, b, c] = [1, 2, 3]\nlet [x, , y] = [1, 2, 3]\nlet [head, ...tail] = [1, 2, 3, 4]\n```\n\n（2）对象解构赋值\n```\nlet {foo, bar} = { foo: 'aaa', bar: 'bbb' }\nvar {}x, y = 5} = {x: 1}\n```\n\n（3）字符串解构赋值\n```\nconst [a, b, c, d, e] = 'hello'\na   // 'h'\nb   // 'e'\nc   // 'l'\nd   // 'l'\ne   // 'o'\n```\n\n（4）函数参数解构赋值\n```\nfunction add ([x, y]) {\n    return x + y\n}\nadd([1, 2])\n```\n\n##### 3. 函数扩展\n\n（1）函数参数默认值\n```\nfunction log (x, y = 'world') {\n    console.log(x, y)\n}\nlog('Hello')    // Hello World\nlog('Hello', 'China')   // Hello China\n```\n注意：\n- 不能有同名参数\n- 参数变量是默认声明的，不能用let或const再次声明\n\n（2）rest参数\n```\nfunction add (...values) {\n    let sum = 0\n    for (var val of values) {\n        sum +=val\n    }\n}\nadd(2, 5, 3)\n```\n\n（3）箭头函数\n```\nvar f = v => v;\n\n// 等同于\nvar f = function (v) {\n  return v;\n};\n\n// 没有参数\nvar f = () => return 200\n\n// 一个参数\nvar f = v => v\n\n// 多个参数\nvar sum = (num1, num2) => num1 + num2\n\n// 代码块内有多句代码\nvar check = (x, y) => {\n    console.log(x, y)\n    return x + y\n}\n```\n注意：\n- 箭头函数没有自己的this对象\n- 不可以当作构造函数\n- 不可以使用arguments对象\n- 不可以使用yield命令，因此箭头函数不能用作 Generator 函数\n\n##### 4. 数组扩展\n（1）复制数组\n```\nconst a1 = [1,2]\nconst a2 =[...a1]   // 这种复制属于深拷贝\n```\n\n（2）合并数组\n```\nconst arr1 = ['a', 'c']\nconst arr2 = ['d,']\n[...arr1, ...arr2]  // ['a', 'c', 'd']\n```\n\n（3）Array.from()\nArray.from方法用于将两类对象转为真正的数组\n\n（4）Array.of()\n##### 5. 对象扩展\n（1）属性的简洁表示\n```\n\n```\n\n##### 6. 扩展运算符\n\n##### 7. symbol\n\n##### 8. 迭代器\n\n##### 9. 生成器\n\n##### 10. promise\n（1）含义\nPromise 是异步编程的一种解决方案，所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果\n\n（2）Promise对象有两个特点\n- 对象的状态不受外界影响\n\n- 一旦状态改变，就不会再变，任何时候都可以得到这个结果\n\n（3）基本用法\n```\nconst promise = new Promise((resolve, reject) => {\n    if (/* 异步操作成功 */) {\n        resolve(value)\n    } else {\n        reject(error)\n    }\n})\n```\n- Promise对象是一个构造函数，用来生成Promise实例\n- Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject\n- resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n- reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n##### 11. set map\n\n##### 12. class\n（1）含义\nES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已\n\n（2）定义一个class\n```\nclass point {\n    // 构造方法\n    constructor (x, y) {\n        this.x = x\n        this.y = y\n    }\n    toString () {\n        return '(' + this.x + ', ' + this.y + ')';\n    }\n}\n```\nES6 的类，完全可以看作构造函数的另一种写法\n```\nclass Point {\n  // ...\n}\n\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor // true\n```\n类的数据类型就是函数，类本身就指向构造函数\n```\nclass Bar {\n  doStuff() {\n    console.log('stuff');\n  }\n}\n\nconst b = new Bar();\nb.doStuff() // \"stuff\"\n```\n构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面\n```\nclass Point {\n  constructor() {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n\n  toValue() {\n    // ...\n  }\n}\n\n// 等同于\n\nPoint.prototype = {\n  constructor() {},\n  toString() {},\n  toValue() {},\n};\n```\n\n（2）constructor方法\nconstructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加\n```\nclass Point {\n}\n\n// 等同于\nclass Point {\n  constructor() {}\n}\n```\n\n（3）类的实例\n```\n/定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n```\n\n##### 13. proxy\n（1）含义\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写\n\n（2）Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”\n```\nvar obj = new Proxy(P{}, {\n    get: function (target, proKey, receiver) {\n        return Relect.get(target, propKey, receiver)\n    },\n    set: function (target, proKey, value, receiver) {\n        return Relect.set(target, propKey, receiver)\n    }\n})\n```\n\n14. async函数\n（1）含义\nES2017 标准引入了 async 函数，它就是 Generator 函数的语法糖\nGenerator 函数\n\n```\nconst fs = require('fs');\n\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\nasync函数\n\n```\nconst asyncReadFile = async function () {\n  const f1 = await readFile('/etc/fstab');\n  const f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n（2）基本用法\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句\n\n\n本文参考：[ECMAScript 6 入门](https://es6.ruanyifeng.com/#docs)","source":"_posts/es6入门.md","raw":"---\ntitle: es6入门\ndate: 2021-10-29 14:25:17\ntags:\n---\n\n##### 1. let const\n(1) let用于定义变量，const用于定义常量\n(2) let、const存在块级作用域\n(3) let不与许在同作用域内重复声明\n(4) const一旦声明不可改变\n(5) const声明不可重复\n(6) 不存在变量提升，必须先声明再使用\n\n##### 2. 解构赋值\n（1）数组解构赋值\n```\nlet [a, b, c] = [1, 2, 3]\nlet [x, , y] = [1, 2, 3]\nlet [head, ...tail] = [1, 2, 3, 4]\n```\n\n（2）对象解构赋值\n```\nlet {foo, bar} = { foo: 'aaa', bar: 'bbb' }\nvar {}x, y = 5} = {x: 1}\n```\n\n（3）字符串解构赋值\n```\nconst [a, b, c, d, e] = 'hello'\na   // 'h'\nb   // 'e'\nc   // 'l'\nd   // 'l'\ne   // 'o'\n```\n\n（4）函数参数解构赋值\n```\nfunction add ([x, y]) {\n    return x + y\n}\nadd([1, 2])\n```\n\n##### 3. 函数扩展\n\n（1）函数参数默认值\n```\nfunction log (x, y = 'world') {\n    console.log(x, y)\n}\nlog('Hello')    // Hello World\nlog('Hello', 'China')   // Hello China\n```\n注意：\n- 不能有同名参数\n- 参数变量是默认声明的，不能用let或const再次声明\n\n（2）rest参数\n```\nfunction add (...values) {\n    let sum = 0\n    for (var val of values) {\n        sum +=val\n    }\n}\nadd(2, 5, 3)\n```\n\n（3）箭头函数\n```\nvar f = v => v;\n\n// 等同于\nvar f = function (v) {\n  return v;\n};\n\n// 没有参数\nvar f = () => return 200\n\n// 一个参数\nvar f = v => v\n\n// 多个参数\nvar sum = (num1, num2) => num1 + num2\n\n// 代码块内有多句代码\nvar check = (x, y) => {\n    console.log(x, y)\n    return x + y\n}\n```\n注意：\n- 箭头函数没有自己的this对象\n- 不可以当作构造函数\n- 不可以使用arguments对象\n- 不可以使用yield命令，因此箭头函数不能用作 Generator 函数\n\n##### 4. 数组扩展\n（1）复制数组\n```\nconst a1 = [1,2]\nconst a2 =[...a1]   // 这种复制属于深拷贝\n```\n\n（2）合并数组\n```\nconst arr1 = ['a', 'c']\nconst arr2 = ['d,']\n[...arr1, ...arr2]  // ['a', 'c', 'd']\n```\n\n（3）Array.from()\nArray.from方法用于将两类对象转为真正的数组\n\n（4）Array.of()\n##### 5. 对象扩展\n（1）属性的简洁表示\n```\n\n```\n\n##### 6. 扩展运算符\n\n##### 7. symbol\n\n##### 8. 迭代器\n\n##### 9. 生成器\n\n##### 10. promise\n（1）含义\nPromise 是异步编程的一种解决方案，所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果\n\n（2）Promise对象有两个特点\n- 对象的状态不受外界影响\n\n- 一旦状态改变，就不会再变，任何时候都可以得到这个结果\n\n（3）基本用法\n```\nconst promise = new Promise((resolve, reject) => {\n    if (/* 异步操作成功 */) {\n        resolve(value)\n    } else {\n        reject(error)\n    }\n})\n```\n- Promise对象是一个构造函数，用来生成Promise实例\n- Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject\n- resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n- reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n##### 11. set map\n\n##### 12. class\n（1）含义\nES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已\n\n（2）定义一个class\n```\nclass point {\n    // 构造方法\n    constructor (x, y) {\n        this.x = x\n        this.y = y\n    }\n    toString () {\n        return '(' + this.x + ', ' + this.y + ')';\n    }\n}\n```\nES6 的类，完全可以看作构造函数的另一种写法\n```\nclass Point {\n  // ...\n}\n\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor // true\n```\n类的数据类型就是函数，类本身就指向构造函数\n```\nclass Bar {\n  doStuff() {\n    console.log('stuff');\n  }\n}\n\nconst b = new Bar();\nb.doStuff() // \"stuff\"\n```\n构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面\n```\nclass Point {\n  constructor() {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n\n  toValue() {\n    // ...\n  }\n}\n\n// 等同于\n\nPoint.prototype = {\n  constructor() {},\n  toString() {},\n  toValue() {},\n};\n```\n\n（2）constructor方法\nconstructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加\n```\nclass Point {\n}\n\n// 等同于\nclass Point {\n  constructor() {}\n}\n```\n\n（3）类的实例\n```\n/定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n```\n\n##### 13. proxy\n（1）含义\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写\n\n（2）Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”\n```\nvar obj = new Proxy(P{}, {\n    get: function (target, proKey, receiver) {\n        return Relect.get(target, propKey, receiver)\n    },\n    set: function (target, proKey, value, receiver) {\n        return Relect.set(target, propKey, receiver)\n    }\n})\n```\n\n14. async函数\n（1）含义\nES2017 标准引入了 async 函数，它就是 Generator 函数的语法糖\nGenerator 函数\n\n```\nconst fs = require('fs');\n\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\nasync函数\n\n```\nconst asyncReadFile = async function () {\n  const f1 = await readFile('/etc/fstab');\n  const f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n\n（2）基本用法\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句\n\n\n本文参考：[ECMAScript 6 入门](https://es6.ruanyifeng.com/#docs)","slug":"es6入门","published":1,"updated":"2021-11-02T10:15:28.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwou9u5d00069hwn88g0alou","content":"\n        <h5 id=\"1-let-const\">\n          <a href=\"#1-let-const\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-let-const\" class=\"headerlink\" title=\"1. let const\"></a>1. let const</h5>\n      <p>(1) let用于定义变量，const用于定义常量<br>(2) let、const存在块级作用域<br>(3) let不与许在同作用域内重复声明<br>(4) const一旦声明不可改变<br>(5) const声明不可重复<br>(6) 不存在变量提升，必须先声明再使用</p>\n\n        <h5 id=\"2-解构赋值\">\n          <a href=\"#2-解构赋值\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-解构赋值\" class=\"headerlink\" title=\"2. 解构赋值\"></a>2. 解构赋值</h5>\n      <p>（1）数组解构赋值</p>\n<pre><code>let [a, b, c] = [1, 2, 3]\nlet [x, , y] = [1, 2, 3]\nlet [head, ...tail] = [1, 2, 3, 4]\n</code></pre>\n<p>（2）对象解构赋值</p>\n<pre><code>let &#123;foo, bar&#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;\nvar &#123;&#125;x, y = 5&#125; = &#123;x: 1&#125;\n</code></pre>\n<p>（3）字符串解构赋值</p>\n<pre><code>const [a, b, c, d, e] = &#39;hello&#39;\na   // &#39;h&#39;\nb   // &#39;e&#39;\nc   // &#39;l&#39;\nd   // &#39;l&#39;\ne   // &#39;o&#39;\n</code></pre>\n<p>（4）函数参数解构赋值</p>\n<pre><code>function add ([x, y]) &#123;\n    return x + y\n&#125;\nadd([1, 2])\n</code></pre>\n\n        <h5 id=\"3-函数扩展\">\n          <a href=\"#3-函数扩展\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-函数扩展\" class=\"headerlink\" title=\"3. 函数扩展\"></a>3. 函数扩展</h5>\n      <p>（1）函数参数默认值</p>\n<pre><code>function log (x, y = &#39;world&#39;) &#123;\n    console.log(x, y)\n&#125;\nlog(&#39;Hello&#39;)    // Hello World\nlog(&#39;Hello&#39;, &#39;China&#39;)   // Hello China\n</code></pre>\n<p>注意：</p>\n<ul>\n<li>不能有同名参数</li>\n<li>参数变量是默认声明的，不能用let或const再次声明</li>\n</ul>\n<p>（2）rest参数</p>\n<pre><code>function add (...values) &#123;\n    let sum = 0\n    for (var val of values) &#123;\n        sum +=val\n    &#125;\n&#125;\nadd(2, 5, 3)\n</code></pre>\n<p>（3）箭头函数</p>\n<pre><code>var f = v =&gt; v;\n\n// 等同于\nvar f = function (v) &#123;\n  return v;\n&#125;;\n\n// 没有参数\nvar f = () =&gt; return 200\n\n// 一个参数\nvar f = v =&gt; v\n\n// 多个参数\nvar sum = (num1, num2) =&gt; num1 + num2\n\n// 代码块内有多句代码\nvar check = (x, y) =&gt; &#123;\n    console.log(x, y)\n    return x + y\n&#125;\n</code></pre>\n<p>注意：</p>\n<ul>\n<li>箭头函数没有自己的this对象</li>\n<li>不可以当作构造函数</li>\n<li>不可以使用arguments对象</li>\n<li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数</li>\n</ul>\n\n        <h5 id=\"4-数组扩展\">\n          <a href=\"#4-数组扩展\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-数组扩展\" class=\"headerlink\" title=\"4. 数组扩展\"></a>4. 数组扩展</h5>\n      <p>（1）复制数组</p>\n<pre><code>const a1 = [1,2]\nconst a2 =[...a1]   // 这种复制属于深拷贝\n</code></pre>\n<p>（2）合并数组</p>\n<pre><code>const arr1 = [&#39;a&#39;, &#39;c&#39;]\nconst arr2 = [&#39;d,&#39;]\n[...arr1, ...arr2]  // [&#39;a&#39;, &#39;c&#39;, &#39;d&#39;]\n</code></pre>\n<p>（3）Array.from()<br>Array.from方法用于将两类对象转为真正的数组</p>\n<p>（4）Array.of()</p>\n\n        <h5 id=\"5-对象扩展\">\n          <a href=\"#5-对象扩展\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-对象扩展\" class=\"headerlink\" title=\"5. 对象扩展\"></a>5. 对象扩展</h5>\n      <p>（1）属性的简洁表示</p>\n<pre><code>\n</code></pre>\n\n        <h5 id=\"6-扩展运算符\">\n          <a href=\"#6-扩展运算符\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-扩展运算符\" class=\"headerlink\" title=\"6. 扩展运算符\"></a>6. 扩展运算符</h5>\n      \n        <h5 id=\"7-symbol\">\n          <a href=\"#7-symbol\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-symbol\" class=\"headerlink\" title=\"7. symbol\"></a>7. symbol</h5>\n      \n        <h5 id=\"8-迭代器\">\n          <a href=\"#8-迭代器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-迭代器\" class=\"headerlink\" title=\"8. 迭代器\"></a>8. 迭代器</h5>\n      \n        <h5 id=\"9-生成器\">\n          <a href=\"#9-生成器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-生成器\" class=\"headerlink\" title=\"9. 生成器\"></a>9. 生成器</h5>\n      \n        <h5 id=\"10-promise\">\n          <a href=\"#10-promise\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#10-promise\" class=\"headerlink\" title=\"10. promise\"></a>10. promise</h5>\n      <p>（1）含义<br>Promise 是异步编程的一种解决方案，所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果</p>\n<p>（2）Promise对象有两个特点</p>\n<ul>\n<li><p>对象的状态不受外界影响</p>\n</li>\n<li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果</p>\n</li>\n</ul>\n<p>（3）基本用法</p>\n<pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;\n    if (/* 异步操作成功 */) &#123;\n        resolve(value)\n    &#125; else &#123;\n        reject(error)\n    &#125;\n&#125;)\n</code></pre>\n<ul>\n<li>Promise对象是一个构造函数，用来生成Promise实例</li>\n<li>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject</li>\n<li>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li>\n<li>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>\n</ul>\n\n        <h5 id=\"11-set-map\">\n          <a href=\"#11-set-map\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#11-set-map\" class=\"headerlink\" title=\"11. set map\"></a>11. set map</h5>\n      \n        <h5 id=\"12-class\">\n          <a href=\"#12-class\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#12-class\" class=\"headerlink\" title=\"12. class\"></a>12. class</h5>\n      <p>（1）含义<br>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已</p>\n<p>（2）定义一个class</p>\n<pre><code>class point &#123;\n    // 构造方法\n    constructor (x, y) &#123;\n        this.x = x\n        this.y = y\n    &#125;\n    toString () &#123;\n        return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n    &#125;\n&#125;\n</code></pre>\n<p>ES6 的类，完全可以看作构造函数的另一种写法</p>\n<pre><code>class Point &#123;\n  // ...\n&#125;\n\ntypeof Point // &quot;function&quot;\nPoint === Point.prototype.constructor // true\n</code></pre>\n<p>类的数据类型就是函数，类本身就指向构造函数</p>\n<pre><code>class Bar &#123;\n  doStuff() &#123;\n    console.log(&#39;stuff&#39;);\n  &#125;\n&#125;\n\nconst b = new Bar();\nb.doStuff() // &quot;stuff&quot;\n</code></pre>\n<p>构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面</p>\n<pre><code>class Point &#123;\n  constructor() &#123;\n    // ...\n  &#125;\n\n  toString() &#123;\n    // ...\n  &#125;\n\n  toValue() &#123;\n    // ...\n  &#125;\n&#125;\n\n// 等同于\n\nPoint.prototype = &#123;\n  constructor() &#123;&#125;,\n  toString() &#123;&#125;,\n  toValue() &#123;&#125;,\n&#125;;\n</code></pre>\n<p>（2）constructor方法<br>constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加</p>\n<pre><code>class Point &#123;\n&#125;\n\n// 等同于\nclass Point &#123;\n  constructor() &#123;&#125;\n&#125;\n</code></pre>\n<p>（3）类的实例</p>\n<pre><code>/定义类\nclass Point &#123;\n\n  constructor(x, y) &#123;\n    this.x = x;\n    this.y = y;\n  &#125;\n\n  toString() &#123;\n    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n  &#125;\n\n&#125;\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty(&#39;x&#39;) // true\npoint.hasOwnProperty(&#39;y&#39;) // true\npoint.hasOwnProperty(&#39;toString&#39;) // false\npoint.__proto__.hasOwnProperty(&#39;toString&#39;) // true\n</code></pre>\n\n        <h5 id=\"13-proxy\">\n          <a href=\"#13-proxy\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#13-proxy\" class=\"headerlink\" title=\"13. proxy\"></a>13. proxy</h5>\n      <p>（1）含义<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</p>\n<p>（2）Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”</p>\n<pre><code>var obj = new Proxy(P&#123;&#125;, &#123;\n    get: function (target, proKey, receiver) &#123;\n        return Relect.get(target, propKey, receiver)\n    &#125;,\n    set: function (target, proKey, value, receiver) &#123;\n        return Relect.set(target, propKey, receiver)\n    &#125;\n&#125;)\n</code></pre>\n<ol start=\"14\">\n<li>async函数<br>（1）含义<br>ES2017 标准引入了 async 函数，它就是 Generator 函数的语法糖<br>Generator 函数</li>\n</ol>\n<pre><code>const fs = require(&#39;fs&#39;);\n\nconst readFile = function (fileName) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    fs.readFile(fileName, function(error, data) &#123;\n      if (error) return reject(error);\n      resolve(data);\n    &#125;);\n  &#125;);\n&#125;;\n\nconst gen = function* () &#123;\n  const f1 = yield readFile(&#39;/etc/fstab&#39;);\n  const f2 = yield readFile(&#39;/etc/shells&#39;);\n  console.log(f1.toString());\n  console.log(f2.toString());\n&#125;;\n</code></pre>\n<p>async函数</p>\n<pre><code>const asyncReadFile = async function () &#123;\n  const f1 = await readFile(&#39;/etc/fstab&#39;);\n  const f2 = await readFile(&#39;/etc/shells&#39;);\n  console.log(f1.toString());\n  console.log(f2.toString());\n&#125;;\n</code></pre>\n<p>（2）基本用法<br>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</p>\n<p>本文参考：<span class=\"exturl\"><a class=\"exturl__link\" href=\"https://es6.ruanyifeng.com/#docs\">ECMAScript 6 入门</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n","site":{"data":{}},"excerpt":"","more":"\n        <h5 id=\"1-let-const\">\n          <a href=\"#1-let-const\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-let-const\" class=\"headerlink\" title=\"1. let const\"></a>1. let const</h5>\n      <p>(1) let用于定义变量，const用于定义常量<br>(2) let、const存在块级作用域<br>(3) let不与许在同作用域内重复声明<br>(4) const一旦声明不可改变<br>(5) const声明不可重复<br>(6) 不存在变量提升，必须先声明再使用</p>\n\n        <h5 id=\"2-解构赋值\">\n          <a href=\"#2-解构赋值\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-解构赋值\" class=\"headerlink\" title=\"2. 解构赋值\"></a>2. 解构赋值</h5>\n      <p>（1）数组解构赋值</p>\n<pre><code>let [a, b, c] = [1, 2, 3]\nlet [x, , y] = [1, 2, 3]\nlet [head, ...tail] = [1, 2, 3, 4]\n</code></pre>\n<p>（2）对象解构赋值</p>\n<pre><code>let &#123;foo, bar&#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;\nvar &#123;&#125;x, y = 5&#125; = &#123;x: 1&#125;\n</code></pre>\n<p>（3）字符串解构赋值</p>\n<pre><code>const [a, b, c, d, e] = &#39;hello&#39;\na   // &#39;h&#39;\nb   // &#39;e&#39;\nc   // &#39;l&#39;\nd   // &#39;l&#39;\ne   // &#39;o&#39;\n</code></pre>\n<p>（4）函数参数解构赋值</p>\n<pre><code>function add ([x, y]) &#123;\n    return x + y\n&#125;\nadd([1, 2])\n</code></pre>\n\n        <h5 id=\"3-函数扩展\">\n          <a href=\"#3-函数扩展\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-函数扩展\" class=\"headerlink\" title=\"3. 函数扩展\"></a>3. 函数扩展</h5>\n      <p>（1）函数参数默认值</p>\n<pre><code>function log (x, y = &#39;world&#39;) &#123;\n    console.log(x, y)\n&#125;\nlog(&#39;Hello&#39;)    // Hello World\nlog(&#39;Hello&#39;, &#39;China&#39;)   // Hello China\n</code></pre>\n<p>注意：</p>\n<ul>\n<li>不能有同名参数</li>\n<li>参数变量是默认声明的，不能用let或const再次声明</li>\n</ul>\n<p>（2）rest参数</p>\n<pre><code>function add (...values) &#123;\n    let sum = 0\n    for (var val of values) &#123;\n        sum +=val\n    &#125;\n&#125;\nadd(2, 5, 3)\n</code></pre>\n<p>（3）箭头函数</p>\n<pre><code>var f = v =&gt; v;\n\n// 等同于\nvar f = function (v) &#123;\n  return v;\n&#125;;\n\n// 没有参数\nvar f = () =&gt; return 200\n\n// 一个参数\nvar f = v =&gt; v\n\n// 多个参数\nvar sum = (num1, num2) =&gt; num1 + num2\n\n// 代码块内有多句代码\nvar check = (x, y) =&gt; &#123;\n    console.log(x, y)\n    return x + y\n&#125;\n</code></pre>\n<p>注意：</p>\n<ul>\n<li>箭头函数没有自己的this对象</li>\n<li>不可以当作构造函数</li>\n<li>不可以使用arguments对象</li>\n<li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数</li>\n</ul>\n\n        <h5 id=\"4-数组扩展\">\n          <a href=\"#4-数组扩展\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-数组扩展\" class=\"headerlink\" title=\"4. 数组扩展\"></a>4. 数组扩展</h5>\n      <p>（1）复制数组</p>\n<pre><code>const a1 = [1,2]\nconst a2 =[...a1]   // 这种复制属于深拷贝\n</code></pre>\n<p>（2）合并数组</p>\n<pre><code>const arr1 = [&#39;a&#39;, &#39;c&#39;]\nconst arr2 = [&#39;d,&#39;]\n[...arr1, ...arr2]  // [&#39;a&#39;, &#39;c&#39;, &#39;d&#39;]\n</code></pre>\n<p>（3）Array.from()<br>Array.from方法用于将两类对象转为真正的数组</p>\n<p>（4）Array.of()</p>\n\n        <h5 id=\"5-对象扩展\">\n          <a href=\"#5-对象扩展\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-对象扩展\" class=\"headerlink\" title=\"5. 对象扩展\"></a>5. 对象扩展</h5>\n      <p>（1）属性的简洁表示</p>\n<pre><code>\n</code></pre>\n\n        <h5 id=\"6-扩展运算符\">\n          <a href=\"#6-扩展运算符\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-扩展运算符\" class=\"headerlink\" title=\"6. 扩展运算符\"></a>6. 扩展运算符</h5>\n      \n        <h5 id=\"7-symbol\">\n          <a href=\"#7-symbol\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-symbol\" class=\"headerlink\" title=\"7. symbol\"></a>7. symbol</h5>\n      \n        <h5 id=\"8-迭代器\">\n          <a href=\"#8-迭代器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-迭代器\" class=\"headerlink\" title=\"8. 迭代器\"></a>8. 迭代器</h5>\n      \n        <h5 id=\"9-生成器\">\n          <a href=\"#9-生成器\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#9-生成器\" class=\"headerlink\" title=\"9. 生成器\"></a>9. 生成器</h5>\n      \n        <h5 id=\"10-promise\">\n          <a href=\"#10-promise\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#10-promise\" class=\"headerlink\" title=\"10. promise\"></a>10. promise</h5>\n      <p>（1）含义<br>Promise 是异步编程的一种解决方案，所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果</p>\n<p>（2）Promise对象有两个特点</p>\n<ul>\n<li><p>对象的状态不受外界影响</p>\n</li>\n<li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果</p>\n</li>\n</ul>\n<p>（3）基本用法</p>\n<pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;\n    if (/* 异步操作成功 */) &#123;\n        resolve(value)\n    &#125; else &#123;\n        reject(error)\n    &#125;\n&#125;)\n</code></pre>\n<ul>\n<li>Promise对象是一个构造函数，用来生成Promise实例</li>\n<li>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject</li>\n<li>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li>\n<li>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>\n</ul>\n\n        <h5 id=\"11-set-map\">\n          <a href=\"#11-set-map\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#11-set-map\" class=\"headerlink\" title=\"11. set map\"></a>11. set map</h5>\n      \n        <h5 id=\"12-class\">\n          <a href=\"#12-class\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#12-class\" class=\"headerlink\" title=\"12. class\"></a>12. class</h5>\n      <p>（1）含义<br>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已</p>\n<p>（2）定义一个class</p>\n<pre><code>class point &#123;\n    // 构造方法\n    constructor (x, y) &#123;\n        this.x = x\n        this.y = y\n    &#125;\n    toString () &#123;\n        return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n    &#125;\n&#125;\n</code></pre>\n<p>ES6 的类，完全可以看作构造函数的另一种写法</p>\n<pre><code>class Point &#123;\n  // ...\n&#125;\n\ntypeof Point // &quot;function&quot;\nPoint === Point.prototype.constructor // true\n</code></pre>\n<p>类的数据类型就是函数，类本身就指向构造函数</p>\n<pre><code>class Bar &#123;\n  doStuff() &#123;\n    console.log(&#39;stuff&#39;);\n  &#125;\n&#125;\n\nconst b = new Bar();\nb.doStuff() // &quot;stuff&quot;\n</code></pre>\n<p>构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面</p>\n<pre><code>class Point &#123;\n  constructor() &#123;\n    // ...\n  &#125;\n\n  toString() &#123;\n    // ...\n  &#125;\n\n  toValue() &#123;\n    // ...\n  &#125;\n&#125;\n\n// 等同于\n\nPoint.prototype = &#123;\n  constructor() &#123;&#125;,\n  toString() &#123;&#125;,\n  toValue() &#123;&#125;,\n&#125;;\n</code></pre>\n<p>（2）constructor方法<br>constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加</p>\n<pre><code>class Point &#123;\n&#125;\n\n// 等同于\nclass Point &#123;\n  constructor() &#123;&#125;\n&#125;\n</code></pre>\n<p>（3）类的实例</p>\n<pre><code>/定义类\nclass Point &#123;\n\n  constructor(x, y) &#123;\n    this.x = x;\n    this.y = y;\n  &#125;\n\n  toString() &#123;\n    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n  &#125;\n\n&#125;\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty(&#39;x&#39;) // true\npoint.hasOwnProperty(&#39;y&#39;) // true\npoint.hasOwnProperty(&#39;toString&#39;) // false\npoint.__proto__.hasOwnProperty(&#39;toString&#39;) // true\n</code></pre>\n\n        <h5 id=\"13-proxy\">\n          <a href=\"#13-proxy\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#13-proxy\" class=\"headerlink\" title=\"13. proxy\"></a>13. proxy</h5>\n      <p>（1）含义<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</p>\n<p>（2）Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”</p>\n<pre><code>var obj = new Proxy(P&#123;&#125;, &#123;\n    get: function (target, proKey, receiver) &#123;\n        return Relect.get(target, propKey, receiver)\n    &#125;,\n    set: function (target, proKey, value, receiver) &#123;\n        return Relect.set(target, propKey, receiver)\n    &#125;\n&#125;)\n</code></pre>\n<ol start=\"14\">\n<li>async函数<br>（1）含义<br>ES2017 标准引入了 async 函数，它就是 Generator 函数的语法糖<br>Generator 函数</li>\n</ol>\n<pre><code>const fs = require(&#39;fs&#39;);\n\nconst readFile = function (fileName) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    fs.readFile(fileName, function(error, data) &#123;\n      if (error) return reject(error);\n      resolve(data);\n    &#125;);\n  &#125;);\n&#125;;\n\nconst gen = function* () &#123;\n  const f1 = yield readFile(&#39;/etc/fstab&#39;);\n  const f2 = yield readFile(&#39;/etc/shells&#39;);\n  console.log(f1.toString());\n  console.log(f2.toString());\n&#125;;\n</code></pre>\n<p>async函数</p>\n<pre><code>const asyncReadFile = async function () &#123;\n  const f1 = await readFile(&#39;/etc/fstab&#39;);\n  const f2 = await readFile(&#39;/etc/shells&#39;);\n  console.log(f1.toString());\n  console.log(f2.toString());\n&#125;;\n</code></pre>\n<p>（2）基本用法<br>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</p>\n<p>本文参考：<span class=\"exturl\"><a class=\"exturl__link\" href=\"https://es6.ruanyifeng.com/#docs\">ECMAScript 6 入门</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n"},{"title":"flex使用介绍","date":"2021-10-29T06:30:23.000Z","_content":"\n##### 1. Flex布局是什么？\nFlex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性\n\n##### 2. 基本概念\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"\n![flex](flex_1.png)\n水平的主轴（main axis）\n垂直的交叉轴（cross axis\n主轴的开始位置  main start\n结束位置    main end\n交叉轴的开始位置    cross start\n个项目占据的主轴空间    main size\n占据的交叉轴空间    cross size\n\n##### 3.容器的属性\n- flex-direction\n- flex-wrap\n- flex-flow\n- justify-content\n- align-items\n- align-content\n\n（1）flex-direction\nflex-direction属性决定主轴的方向（即项目的排列方向）\n```\n.box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n- row（默认值）：主轴为水平方向，起点在左端。\n- row-reverse：主轴为水平方向，起点在右端。\n- column：主轴为垂直方向，起点在上沿。\n- column-reverse：主轴为垂直方向，起点在下沿。\n![flex](flex_2.png)\n\n（2）flex-wrap属性\n默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行\n```\n.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n- nowrap（默认）：不换行\n- wrap：换行，第一行在上方\n- wrap-reverse：换行，第一行在下方\n\n（3）flex-flow\nlex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n```\n.box {\n  flex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n（4）justify-content属性\njustify-content属性定义了项目在主轴上的对齐方式\n```\n.box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n- flex-start（默认值）：左对齐\n- flex-end：右对齐\n- center： 居中\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n![flex](flex_3.png)\n\n（5）align-items属性\nalign-items属性定义项目在交叉轴上如何对齐。\n```\n.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n![flex](flex_4.png)\n\n（6）align-content属性\nalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用\n\n- flex-start：与交叉轴的起点对齐。\n- flex-end：与交叉轴的终点对齐。\n- center：与交叉轴的中点对齐。\n- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- stretch（默认值）：轴线占满整个交叉轴。\n![flex](flex_5.png)\n\n##### 特别说明：\n[本文转载自：Flex 布局教程](https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)","source":"_posts/flex使用介绍.md","raw":"---\ntitle: flex使用介绍\ndate: 2021-10-29 14:30:23\ntags:\n---\n\n##### 1. Flex布局是什么？\nFlex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性\n\n##### 2. 基本概念\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"\n![flex](flex_1.png)\n水平的主轴（main axis）\n垂直的交叉轴（cross axis\n主轴的开始位置  main start\n结束位置    main end\n交叉轴的开始位置    cross start\n个项目占据的主轴空间    main size\n占据的交叉轴空间    cross size\n\n##### 3.容器的属性\n- flex-direction\n- flex-wrap\n- flex-flow\n- justify-content\n- align-items\n- align-content\n\n（1）flex-direction\nflex-direction属性决定主轴的方向（即项目的排列方向）\n```\n.box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n```\n- row（默认值）：主轴为水平方向，起点在左端。\n- row-reverse：主轴为水平方向，起点在右端。\n- column：主轴为垂直方向，起点在上沿。\n- column-reverse：主轴为垂直方向，起点在下沿。\n![flex](flex_2.png)\n\n（2）flex-wrap属性\n默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行\n```\n.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n- nowrap（默认）：不换行\n- wrap：换行，第一行在上方\n- wrap-reverse：换行，第一行在下方\n\n（3）flex-flow\nlex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n```\n.box {\n  flex-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n（4）justify-content属性\njustify-content属性定义了项目在主轴上的对齐方式\n```\n.box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n- flex-start（默认值）：左对齐\n- flex-end：右对齐\n- center： 居中\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n![flex](flex_3.png)\n\n（5）align-items属性\nalign-items属性定义项目在交叉轴上如何对齐。\n```\n.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n![flex](flex_4.png)\n\n（6）align-content属性\nalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用\n\n- flex-start：与交叉轴的起点对齐。\n- flex-end：与交叉轴的终点对齐。\n- center：与交叉轴的中点对齐。\n- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- stretch（默认值）：轴线占满整个交叉轴。\n![flex](flex_5.png)\n\n##### 特别说明：\n[本文转载自：Flex 布局教程](https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)","slug":"flex使用介绍","published":1,"updated":"2021-11-04T09:26:46.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwou9u5h00089hwnfku32rr6","content":"\n        <h5 id=\"1-Flex布局是什么？\">\n          <a href=\"#1-Flex布局是什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-Flex布局是什么？\" class=\"headerlink\" title=\"1. Flex布局是什么？\"></a>1. Flex布局是什么？</h5>\n      <p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性</p>\n\n        <h5 id=\"2-基本概念\">\n          <a href=\"#2-基本概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-基本概念\" class=\"headerlink\" title=\"2. 基本概念\"></a>2. 基本概念</h5>\n      <p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”<br><img src=\"/2021/10/29/flex%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/flex_1.png\" alt=\"flex\"><br>水平的主轴（main axis）<br>垂直的交叉轴（cross axis<br>主轴的开始位置  main start<br>结束位置    main end<br>交叉轴的开始位置    cross start<br>个项目占据的主轴空间    main size<br>占据的交叉轴空间    cross size</p>\n\n        <h5 id=\"3-容器的属性\">\n          <a href=\"#3-容器的属性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-容器的属性\" class=\"headerlink\" title=\"3.容器的属性\"></a>3.容器的属性</h5>\n      <ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n<p>（1）flex-direction<br>flex-direction属性决定主轴的方向（即项目的排列方向）</p>\n<pre><code>.box &#123;\n  flex-direction: row | row-reverse | column | column-reverse;\n&#125;\n</code></pre>\n<ul>\n<li>row（默认值）：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿。<br><img src=\"/2021/10/29/flex%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/flex_2.png\" alt=\"flex\"></li>\n</ul>\n<p>（2）flex-wrap属性<br>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行</p>\n<pre><code>.box&#123;\n  flex-wrap: nowrap | wrap | wrap-reverse;\n&#125;\n</code></pre>\n<ul>\n<li>nowrap（默认）：不换行</li>\n<li>wrap：换行，第一行在上方</li>\n<li>wrap-reverse：换行，第一行在下方</li>\n</ul>\n<p>（3）flex-flow<br>lex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</p>\n<pre><code>.box &#123;\n  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;\n&#125;\n</code></pre>\n<p>（4）justify-content属性<br>justify-content属性定义了项目在主轴上的对齐方式</p>\n<pre><code>.box &#123;\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n&#125;\n</code></pre>\n<ul>\n<li>flex-start（默认值）：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。<br><img src=\"/2021/10/29/flex%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/flex_3.png\" alt=\"flex\"></li>\n</ul>\n<p>（5）align-items属性<br>align-items属性定义项目在交叉轴上如何对齐。</p>\n<pre><code>.box &#123;\n  align-items: flex-start | flex-end | center | baseline | stretch;\n&#125;\n</code></pre>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。<br><img src=\"/2021/10/29/flex%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/flex_4.png\" alt=\"flex\"></li>\n</ul>\n<p>（6）align-content属性<br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。<br><img src=\"/2021/10/29/flex%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/flex_5.png\" alt=\"flex\"></li>\n</ul>\n\n        <h5 id=\"特别说明：\">\n          <a href=\"#特别说明：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#特别说明：\" class=\"headerlink\" title=\"特别说明：\"></a>特别说明：</h5>\n      <p><span class=\"exturl\"><a class=\"exturl__link\" href=\"https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\">本文转载自：Flex 布局教程</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n","site":{"data":{}},"excerpt":"","more":"\n        <h5 id=\"1-Flex布局是什么？\">\n          <a href=\"#1-Flex布局是什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-Flex布局是什么？\" class=\"headerlink\" title=\"1. Flex布局是什么？\"></a>1. Flex布局是什么？</h5>\n      <p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性</p>\n\n        <h5 id=\"2-基本概念\">\n          <a href=\"#2-基本概念\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-基本概念\" class=\"headerlink\" title=\"2. 基本概念\"></a>2. 基本概念</h5>\n      <p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”<br><img src=\"/2021/10/29/flex%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/flex_1.png\" alt=\"flex\"><br>水平的主轴（main axis）<br>垂直的交叉轴（cross axis<br>主轴的开始位置  main start<br>结束位置    main end<br>交叉轴的开始位置    cross start<br>个项目占据的主轴空间    main size<br>占据的交叉轴空间    cross size</p>\n\n        <h5 id=\"3-容器的属性\">\n          <a href=\"#3-容器的属性\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-容器的属性\" class=\"headerlink\" title=\"3.容器的属性\"></a>3.容器的属性</h5>\n      <ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n<p>（1）flex-direction<br>flex-direction属性决定主轴的方向（即项目的排列方向）</p>\n<pre><code>.box &#123;\n  flex-direction: row | row-reverse | column | column-reverse;\n&#125;\n</code></pre>\n<ul>\n<li>row（默认值）：主轴为水平方向，起点在左端。</li>\n<li>row-reverse：主轴为水平方向，起点在右端。</li>\n<li>column：主轴为垂直方向，起点在上沿。</li>\n<li>column-reverse：主轴为垂直方向，起点在下沿。<br><img src=\"/2021/10/29/flex%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/flex_2.png\" alt=\"flex\"></li>\n</ul>\n<p>（2）flex-wrap属性<br>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行</p>\n<pre><code>.box&#123;\n  flex-wrap: nowrap | wrap | wrap-reverse;\n&#125;\n</code></pre>\n<ul>\n<li>nowrap（默认）：不换行</li>\n<li>wrap：换行，第一行在上方</li>\n<li>wrap-reverse：换行，第一行在下方</li>\n</ul>\n<p>（3）flex-flow<br>lex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</p>\n<pre><code>.box &#123;\n  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;\n&#125;\n</code></pre>\n<p>（4）justify-content属性<br>justify-content属性定义了项目在主轴上的对齐方式</p>\n<pre><code>.box &#123;\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n&#125;\n</code></pre>\n<ul>\n<li>flex-start（默认值）：左对齐</li>\n<li>flex-end：右对齐</li>\n<li>center： 居中</li>\n<li>space-between：两端对齐，项目之间的间隔都相等。</li>\n<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。<br><img src=\"/2021/10/29/flex%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/flex_3.png\" alt=\"flex\"></li>\n</ul>\n<p>（5）align-items属性<br>align-items属性定义项目在交叉轴上如何对齐。</p>\n<pre><code>.box &#123;\n  align-items: flex-start | flex-end | center | baseline | stretch;\n&#125;\n</code></pre>\n<ul>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。<br><img src=\"/2021/10/29/flex%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/flex_4.png\" alt=\"flex\"></li>\n</ul>\n<p>（6）align-content属性<br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p>\n<ul>\n<li>flex-start：与交叉轴的起点对齐。</li>\n<li>flex-end：与交叉轴的终点对齐。</li>\n<li>center：与交叉轴的中点对齐。</li>\n<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li>stretch（默认值）：轴线占满整个交叉轴。<br><img src=\"/2021/10/29/flex%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/flex_5.png\" alt=\"flex\"></li>\n</ul>\n\n        <h5 id=\"特别说明：\">\n          <a href=\"#特别说明：\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#特别说明：\" class=\"headerlink\" title=\"特别说明：\"></a>特别说明：</h5>\n      <p><span class=\"exturl\"><a class=\"exturl__link\" href=\"https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\">本文转载自：Flex 布局教程</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n"},{"title":"hexo搭建博客","date":"2021-10-29T06:14:50.000Z","_content":"\n##### 1. hexo介绍\n（1）hexo时什么？\nHexo 是一个快速、简洁且高效的博客框架\n\n（2）安装\n```\nnpm install -g hexo-cli\n```\n\n（3）初始化一个网站项目\n```\nhexo init <folder>\ncd <folder>\nnpm install\n```\n（3）项目文件目录\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n\n（4）文件介绍\n_config.yml 网站的配置信息\nscaffolds   模版文件夹，当您新建文章时，Hexo 会根据 scaffold 来建立文件\nsource  资源文件夹是存放用户资源的地方\nthemes  主题 文件夹，Hexo 会根据主题来生成静态页面\n\n（5）配置\n_config.yml\n\n|  参数  | 描述  |\n|  ----  | ---- | \n| title  | 网站标题 |\n| subtitle  | 网站副标题 |\n| description  | 网站描述 |\n| keywords  | 网站的关键词。支持多个关键词。 |\n| author  | 您的名字 |\n| language  | 网站使用的语言，常见的有 zh-Hans和 zh-CN |\n| timezone  | 网站时区，中国大陆地区可以使用 Asia/Shanghai |\n\n（6）指令\ninit 新建一个网站\n```\nhexo init [folder]\n```\n\nnew 新建一篇文章\n```\nhexo new [layout] <title>\n```\n\ngenerate 生成静态文件\n```\nhexo generate\n```\n\npublish 发表草稿\n```\n hexo publish [layout] <filename>\n```\n\nserver 启动服务器。默认情况下，访问网址为： http://localhost:4000/\n```\nhexo server\n```\n参数：\n-p, --port\t重设端口\n-s, --static\t只使用静态文件\n-l, --log\t启动日记记录，使用覆盖记录格式\n\ndeploy 部署网站\n```\nhexo deploy\n```\n参数：\ng, --generate\t部署之前预先生成静态文件\n\nclean 除缓存文件 (db.json) 和已生成的静态文件 (public)\n```\nhexo clean\n```\n\n\n##### 2. 搭建博客\n\n##### 3. 关于Github Actions\n（1）github actions是什么？\n一种持续集成服务，持续集成由很多操作组成，比如登陆远程服务器，发布内容到第三方服务等，Github把这些操作称为actions\n\n（2）基本概念\n- workflow（工作流程）：持续集成一次运行的的过程，就是一个workflow\n- job（任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务\n- step（步骤）：每个 job 由多个 step 构成，一步步完成\n- action（动作）：每个 step 可以依次执行一个或多个命令（action）、\n\n（3）workflow文件\nGitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录\n配置字段\n- name\nname字段是 workflow 的名称\n\n- on    \non字段指定触发 workflow 的条件，通常是某些事件\n\n- on.<push|pull_request>.<tags|branches>\n指定触发事件时，可以限定分支或标签\n```\non:\n  push:\n    branches:    \n      - master\n```\n\n- jobs.<job_id>.name\nworkflow 文件的主体是jobs字段，表示要执行的一项或多项任务\n```\njobs:\n  my_first_job:\n    name: My first job\n  my_second_job:\n    name: My second job\n```\n\n- jobs.<job_id>.needs\nneeds字段指定当前任务的依赖关系，即运行顺序\n```\njobs:\n  job1:\n  job2:\n    needs: job1\n  job3:\n    needs: [job1, job2]\n```\n\n- jobs.<job_id>.runs-on\nruns-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下\n```\nubuntu-latest，ubuntu-18.04或ubuntu-16.04\nwindows-latest，windows-2019或windows-2016\nmacOS-latest或macOS-10.14\n```\n\n- jobs.<job_id>.steps\nsteps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段\n```\njobs.<job_id>.steps.name：步骤名称。\njobs.<job_id>.steps.run：该步骤运行的命令或者 action。\njobs.<job_id>.steps.env：该步骤所需的环境变量。\n```\n##### 4. 部署到ECS\n（1）购买一台ECS服务器\n\n（2）创建一个用户\n\n（3）设置用户免密码登陆\n\n（4）执行github actions上传代码到ECS\n\n（5）申请域名\n\n（6）配置nginx\n\n（7）设置ECS\n\n（8）配置https\n\n（9）安全防护","source":"_posts/hexo搭建博客.md","raw":"---\ntitle: hexo搭建博客\ndate: 2021-10-29 14:14:50\ntags:\n---\n\n##### 1. hexo介绍\n（1）hexo时什么？\nHexo 是一个快速、简洁且高效的博客框架\n\n（2）安装\n```\nnpm install -g hexo-cli\n```\n\n（3）初始化一个网站项目\n```\nhexo init <folder>\ncd <folder>\nnpm install\n```\n（3）项目文件目录\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n\n（4）文件介绍\n_config.yml 网站的配置信息\nscaffolds   模版文件夹，当您新建文章时，Hexo 会根据 scaffold 来建立文件\nsource  资源文件夹是存放用户资源的地方\nthemes  主题 文件夹，Hexo 会根据主题来生成静态页面\n\n（5）配置\n_config.yml\n\n|  参数  | 描述  |\n|  ----  | ---- | \n| title  | 网站标题 |\n| subtitle  | 网站副标题 |\n| description  | 网站描述 |\n| keywords  | 网站的关键词。支持多个关键词。 |\n| author  | 您的名字 |\n| language  | 网站使用的语言，常见的有 zh-Hans和 zh-CN |\n| timezone  | 网站时区，中国大陆地区可以使用 Asia/Shanghai |\n\n（6）指令\ninit 新建一个网站\n```\nhexo init [folder]\n```\n\nnew 新建一篇文章\n```\nhexo new [layout] <title>\n```\n\ngenerate 生成静态文件\n```\nhexo generate\n```\n\npublish 发表草稿\n```\n hexo publish [layout] <filename>\n```\n\nserver 启动服务器。默认情况下，访问网址为： http://localhost:4000/\n```\nhexo server\n```\n参数：\n-p, --port\t重设端口\n-s, --static\t只使用静态文件\n-l, --log\t启动日记记录，使用覆盖记录格式\n\ndeploy 部署网站\n```\nhexo deploy\n```\n参数：\ng, --generate\t部署之前预先生成静态文件\n\nclean 除缓存文件 (db.json) 和已生成的静态文件 (public)\n```\nhexo clean\n```\n\n\n##### 2. 搭建博客\n\n##### 3. 关于Github Actions\n（1）github actions是什么？\n一种持续集成服务，持续集成由很多操作组成，比如登陆远程服务器，发布内容到第三方服务等，Github把这些操作称为actions\n\n（2）基本概念\n- workflow（工作流程）：持续集成一次运行的的过程，就是一个workflow\n- job（任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务\n- step（步骤）：每个 job 由多个 step 构成，一步步完成\n- action（动作）：每个 step 可以依次执行一个或多个命令（action）、\n\n（3）workflow文件\nGitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录\n配置字段\n- name\nname字段是 workflow 的名称\n\n- on    \non字段指定触发 workflow 的条件，通常是某些事件\n\n- on.<push|pull_request>.<tags|branches>\n指定触发事件时，可以限定分支或标签\n```\non:\n  push:\n    branches:    \n      - master\n```\n\n- jobs.<job_id>.name\nworkflow 文件的主体是jobs字段，表示要执行的一项或多项任务\n```\njobs:\n  my_first_job:\n    name: My first job\n  my_second_job:\n    name: My second job\n```\n\n- jobs.<job_id>.needs\nneeds字段指定当前任务的依赖关系，即运行顺序\n```\njobs:\n  job1:\n  job2:\n    needs: job1\n  job3:\n    needs: [job1, job2]\n```\n\n- jobs.<job_id>.runs-on\nruns-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下\n```\nubuntu-latest，ubuntu-18.04或ubuntu-16.04\nwindows-latest，windows-2019或windows-2016\nmacOS-latest或macOS-10.14\n```\n\n- jobs.<job_id>.steps\nsteps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段\n```\njobs.<job_id>.steps.name：步骤名称。\njobs.<job_id>.steps.run：该步骤运行的命令或者 action。\njobs.<job_id>.steps.env：该步骤所需的环境变量。\n```\n##### 4. 部署到ECS\n（1）购买一台ECS服务器\n\n（2）创建一个用户\n\n（3）设置用户免密码登陆\n\n（4）执行github actions上传代码到ECS\n\n（5）申请域名\n\n（6）配置nginx\n\n（7）设置ECS\n\n（8）配置https\n\n（9）安全防护","slug":"hexo搭建博客","published":1,"updated":"2021-11-03T10:53:59.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwou9u5j000a9hwn90fvbfij","content":"\n        <h5 id=\"1-hexo介绍\">\n          <a href=\"#1-hexo介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-hexo介绍\" class=\"headerlink\" title=\"1. hexo介绍\"></a>1. hexo介绍</h5>\n      <p>（1）hexo时什么？<br>Hexo 是一个快速、简洁且高效的博客框架</p>\n<p>（2）安装</p>\n<pre><code>npm install -g hexo-cli\n</code></pre>\n<p>（3）初始化一个网站项目</p>\n<pre><code>hexo init &lt;folder&gt;\ncd &lt;folder&gt;\nnpm install\n</code></pre>\n<p>（3）项目文件目录<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes</p>\n<p>（4）文件介绍<br>_config.yml 网站的配置信息<br>scaffolds   模版文件夹，当您新建文章时，Hexo 会根据 scaffold 来建立文件<br>source  资源文件夹是存放用户资源的地方<br>themes  主题 文件夹，Hexo 会根据主题来生成静态页面</p>\n<p>（5）配置<br>_config.yml</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>网站标题</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>网站副标题</td>\n</tr>\n<tr>\n<td>description</td>\n<td>网站描述</td>\n</tr>\n<tr>\n<td>keywords</td>\n<td>网站的关键词。支持多个关键词。</td>\n</tr>\n<tr>\n<td>author</td>\n<td>您的名字</td>\n</tr>\n<tr>\n<td>language</td>\n<td>网站使用的语言，常见的有 zh-Hans和 zh-CN</td>\n</tr>\n<tr>\n<td>timezone</td>\n<td>网站时区，中国大陆地区可以使用 Asia/Shanghai</td>\n</tr>\n</tbody></table></div>\n<p>（6）指令<br>init 新建一个网站</p>\n<pre><code>hexo init [folder]\n</code></pre>\n<p>new 新建一篇文章</p>\n<pre><code>hexo new [layout] &lt;title&gt;\n</code></pre>\n<p>generate 生成静态文件</p>\n<pre><code>hexo generate\n</code></pre>\n<p>publish 发表草稿</p>\n<pre><code> hexo publish [layout] &lt;filename&gt;\n</code></pre>\n<p>server 启动服务器。默认情况下，访问网址为： <span class=\"exturl\"><a class=\"exturl__link\" href=\"http://localhost:4000/\">http://localhost:4000/</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<pre><code>hexo server\n</code></pre>\n<p>参数：<br>-p, –port    重设端口<br>-s, –static    只使用静态文件<br>-l, –log    启动日记记录，使用覆盖记录格式</p>\n<p>deploy 部署网站</p>\n<pre><code>hexo deploy\n</code></pre>\n<p>参数：<br>g, –generate    部署之前预先生成静态文件</p>\n<p>clean 除缓存文件 (db.json) 和已生成的静态文件 (public)</p>\n<pre><code>hexo clean\n</code></pre>\n\n        <h5 id=\"2-搭建博客\">\n          <a href=\"#2-搭建博客\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-搭建博客\" class=\"headerlink\" title=\"2. 搭建博客\"></a>2. 搭建博客</h5>\n      \n        <h5 id=\"3-关于Github-Actions\">\n          <a href=\"#3-关于Github-Actions\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-关于Github-Actions\" class=\"headerlink\" title=\"3. 关于Github Actions\"></a>3. 关于Github Actions</h5>\n      <p>（1）github actions是什么？<br>一种持续集成服务，持续集成由很多操作组成，比如登陆远程服务器，发布内容到第三方服务等，Github把这些操作称为actions</p>\n<p>（2）基本概念</p>\n<ul>\n<li>workflow（工作流程）：持续集成一次运行的的过程，就是一个workflow</li>\n<li>job（任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务</li>\n<li>step（步骤）：每个 job 由多个 step 构成，一步步完成</li>\n<li>action（动作）：每个 step 可以依次执行一个或多个命令（action）、</li>\n</ul>\n<p>（3）workflow文件<br>GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录<br>配置字段</p>\n<ul>\n<li><p>name<br>name字段是 workflow 的名称</p>\n</li>\n<li><p>on<br>on字段指定触发 workflow 的条件，通常是某些事件</p>\n</li>\n<li><p>on.&lt;push|pull_request&gt;.&lt;tags|branches&gt;<br>指定触发事件时，可以限定分支或标签</p>\n<pre><code>on:\npush:\n  branches:    \n    - master\n</code></pre>\n</li>\n<li><p>jobs.<job_id>.name<br>workflow 文件的主体是jobs字段，表示要执行的一项或多项任务</job_id></p>\n<pre><code>jobs:\nmy_first_job:\n  name: My first job\nmy_second_job:\n  name: My second job\n</code></pre>\n</li>\n<li><p>jobs.<job_id>.needs<br>needs字段指定当前任务的依赖关系，即运行顺序</job_id></p>\n<pre><code>jobs:\njob1:\njob2:\n  needs: job1\njob3:\n  needs: [job1, job2]\n</code></pre>\n</li>\n<li><p>jobs.<job_id>.runs-on<br>runs-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下</job_id></p>\n<pre><code>ubuntu-latest，ubuntu-18.04或ubuntu-16.04\nwindows-latest，windows-2019或windows-2016\nmacOS-latest或macOS-10.14\n</code></pre>\n</li>\n<li><p>jobs.<job_id>.steps<br>steps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段</job_id></p>\n<pre><code>jobs.&lt;job_id&gt;.steps.name：步骤名称。\njobs.&lt;job_id&gt;.steps.run：该步骤运行的命令或者 action。\njobs.&lt;job_id&gt;.steps.env：该步骤所需的环境变量。\n</code></pre>\n\n        <h5 id=\"4-部署到ECS\">\n          <a href=\"#4-部署到ECS\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-部署到ECS\" class=\"headerlink\" title=\"4. 部署到ECS\"></a>4. 部署到ECS</h5>\n      <p>（1）购买一台ECS服务器</p>\n</li>\n</ul>\n<p>（2）创建一个用户</p>\n<p>（3）设置用户免密码登陆</p>\n<p>（4）执行github actions上传代码到ECS</p>\n<p>（5）申请域名</p>\n<p>（6）配置nginx</p>\n<p>（7）设置ECS</p>\n<p>（8）配置https</p>\n<p>（9）安全防护</p>\n","site":{"data":{}},"excerpt":"","more":"\n        <h5 id=\"1-hexo介绍\">\n          <a href=\"#1-hexo介绍\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-hexo介绍\" class=\"headerlink\" title=\"1. hexo介绍\"></a>1. hexo介绍</h5>\n      <p>（1）hexo时什么？<br>Hexo 是一个快速、简洁且高效的博客框架</p>\n<p>（2）安装</p>\n<pre><code>npm install -g hexo-cli\n</code></pre>\n<p>（3）初始化一个网站项目</p>\n<pre><code>hexo init &lt;folder&gt;\ncd &lt;folder&gt;\nnpm install\n</code></pre>\n<p>（3）项目文件目录<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes</p>\n<p>（4）文件介绍<br>_config.yml 网站的配置信息<br>scaffolds   模版文件夹，当您新建文章时，Hexo 会根据 scaffold 来建立文件<br>source  资源文件夹是存放用户资源的地方<br>themes  主题 文件夹，Hexo 会根据主题来生成静态页面</p>\n<p>（5）配置<br>_config.yml</p>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>title</td>\n<td>网站标题</td>\n</tr>\n<tr>\n<td>subtitle</td>\n<td>网站副标题</td>\n</tr>\n<tr>\n<td>description</td>\n<td>网站描述</td>\n</tr>\n<tr>\n<td>keywords</td>\n<td>网站的关键词。支持多个关键词。</td>\n</tr>\n<tr>\n<td>author</td>\n<td>您的名字</td>\n</tr>\n<tr>\n<td>language</td>\n<td>网站使用的语言，常见的有 zh-Hans和 zh-CN</td>\n</tr>\n<tr>\n<td>timezone</td>\n<td>网站时区，中国大陆地区可以使用 Asia/Shanghai</td>\n</tr>\n</tbody></table></div>\n<p>（6）指令<br>init 新建一个网站</p>\n<pre><code>hexo init [folder]\n</code></pre>\n<p>new 新建一篇文章</p>\n<pre><code>hexo new [layout] &lt;title&gt;\n</code></pre>\n<p>generate 生成静态文件</p>\n<pre><code>hexo generate\n</code></pre>\n<p>publish 发表草稿</p>\n<pre><code> hexo publish [layout] &lt;filename&gt;\n</code></pre>\n<p>server 启动服务器。默认情况下，访问网址为： <span class=\"exturl\"><a class=\"exturl__link\" href=\"http://localhost:4000/\">http://localhost:4000/</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span></p>\n<pre><code>hexo server\n</code></pre>\n<p>参数：<br>-p, –port    重设端口<br>-s, –static    只使用静态文件<br>-l, –log    启动日记记录，使用覆盖记录格式</p>\n<p>deploy 部署网站</p>\n<pre><code>hexo deploy\n</code></pre>\n<p>参数：<br>g, –generate    部署之前预先生成静态文件</p>\n<p>clean 除缓存文件 (db.json) 和已生成的静态文件 (public)</p>\n<pre><code>hexo clean\n</code></pre>\n\n        <h5 id=\"2-搭建博客\">\n          <a href=\"#2-搭建博客\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-搭建博客\" class=\"headerlink\" title=\"2. 搭建博客\"></a>2. 搭建博客</h5>\n      \n        <h5 id=\"3-关于Github-Actions\">\n          <a href=\"#3-关于Github-Actions\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-关于Github-Actions\" class=\"headerlink\" title=\"3. 关于Github Actions\"></a>3. 关于Github Actions</h5>\n      <p>（1）github actions是什么？<br>一种持续集成服务，持续集成由很多操作组成，比如登陆远程服务器，发布内容到第三方服务等，Github把这些操作称为actions</p>\n<p>（2）基本概念</p>\n<ul>\n<li>workflow（工作流程）：持续集成一次运行的的过程，就是一个workflow</li>\n<li>job（任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务</li>\n<li>step（步骤）：每个 job 由多个 step 构成，一步步完成</li>\n<li>action（动作）：每个 step 可以依次执行一个或多个命令（action）、</li>\n</ul>\n<p>（3）workflow文件<br>GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录<br>配置字段</p>\n<ul>\n<li><p>name<br>name字段是 workflow 的名称</p>\n</li>\n<li><p>on<br>on字段指定触发 workflow 的条件，通常是某些事件</p>\n</li>\n<li><p>on.&lt;push|pull_request&gt;.&lt;tags|branches&gt;<br>指定触发事件时，可以限定分支或标签</p>\n<pre><code>on:\npush:\n  branches:    \n    - master\n</code></pre>\n</li>\n<li><p>jobs.<job_id>.name<br>workflow 文件的主体是jobs字段，表示要执行的一项或多项任务</job_id></p>\n<pre><code>jobs:\nmy_first_job:\n  name: My first job\nmy_second_job:\n  name: My second job\n</code></pre>\n</li>\n<li><p>jobs.<job_id>.needs<br>needs字段指定当前任务的依赖关系，即运行顺序</job_id></p>\n<pre><code>jobs:\njob1:\njob2:\n  needs: job1\njob3:\n  needs: [job1, job2]\n</code></pre>\n</li>\n<li><p>jobs.<job_id>.runs-on<br>runs-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下</job_id></p>\n<pre><code>ubuntu-latest，ubuntu-18.04或ubuntu-16.04\nwindows-latest，windows-2019或windows-2016\nmacOS-latest或macOS-10.14\n</code></pre>\n</li>\n<li><p>jobs.<job_id>.steps<br>steps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段</job_id></p>\n<pre><code>jobs.&lt;job_id&gt;.steps.name：步骤名称。\njobs.&lt;job_id&gt;.steps.run：该步骤运行的命令或者 action。\njobs.&lt;job_id&gt;.steps.env：该步骤所需的环境变量。\n</code></pre>\n\n        <h5 id=\"4-部署到ECS\">\n          <a href=\"#4-部署到ECS\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-部署到ECS\" class=\"headerlink\" title=\"4. 部署到ECS\"></a>4. 部署到ECS</h5>\n      <p>（1）购买一台ECS服务器</p>\n</li>\n</ul>\n<p>（2）创建一个用户</p>\n<p>（3）设置用户免密码登陆</p>\n<p>（4）执行github actions上传代码到ECS</p>\n<p>（5）申请域名</p>\n<p>（6）配置nginx</p>\n<p>（7）设置ECS</p>\n<p>（8）配置https</p>\n<p>（9）安全防护</p>\n"},{"title":"http介绍","date":"2021-10-29T06:48:44.000Z","_content":"\n##### 1.简介\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，HTTP是一个基于TCP/IP通信协议来传递数据\n\n##### 2.HTTP工作原理\n- HTTP协议工作于客户端-服务端架构上\n- Web服务器根据接收到的请求后，向客户端发送响应信息\n- HTTP默认端口号为80\n\n##### 3.HTTP三个特点\n- HTTP是无连接，无连接的含义是限制每次连接只处理一个请求\n- HTTP是媒体独立的，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送\n- HTTP是无状态，无状态是指协议对于事务处理没有记忆能力\n\n##### 4.请求消息\n- 请求行（request line）\n- 请求头部（header）\n- 空行\n- 请求数据\n\n##### 5.响应消息\n- 状态行\n- 消息报头\n- 空行\n- 响应正文\n![响应消息结构](httpmessage.jpeg)\n\n##### 6.请求方法\n|方法|描述|\n|----|----|\n|GET|请求指定的页面信息，并返回实体主体。|\n|HEAD|类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头|\n|POST|向指定资源提交数据进行处理请求（例如提交表单或者上传文件）|\n|PUT|从客户端向服务器传送的数据取代指定的文档的内容。|\n|DELETE|请求服务器删除指定的页面。|\n|CONNECT|HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。|\n|OPTIONS|允许客户端查看服务器的性能。|\n|TRACE|回显服务器收到的请求，主要用于测试或诊断。|\n|PATCH|是对 PUT 方法的补充，用来对已知资源进行局部更新 。|\n\n##### 7.响应头信息\n\n|应答头|说明|\n|----|----|\n|Allow|服务器支持哪些请求方法（如GET、POST等）|\n|Content-Encoding|文档的编码（Encode）方法|\n|Content-Length|表示内容长度|\n|Content-Type|表示后面的文档属于什么MIME类型|\n|Date|当前的GMT时间|\n|Expires|应该在什么时候认为文档已经过期，从而不再缓存它？|\n|Last-Modified|文档的最后改动时间。|\n|Location|表示客户应当到哪里去提取文档|\n|Refresh|表示浏览器应该在多少时间之后刷新文档|\n|Server|服务器名字|\n|Set-Cookie|设置和页面关联的Cookie|\n\n##### 8.状态码\n- 200   请求成功\n- 300   资源（网页等）被永久转移到其它URL\n- 400   请求的资源（网页等）不存在\n- 500    内部服务器错误\n\n|状态码|描述|\n|----|----|\n|100|继续|\n|101|切换协议|\n|200|请求成功。一般用于GET与POST请求|\n|201|已创建。成功请求并创建了新的资源|\n|202|已接受。已经接受请求，但未处理完成|\n|203|非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本|\n|204|无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档|\n|300|多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择|\n|301|永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替|\n|302|时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI|\n|400|客户端请求的语法错误，服务器无法理解|\n|401|请求要求用户的身份认证|\n|402|保留，将来使用|\n|403|服务器理解请求客户端的请求，但是拒绝执行此请求|\n|500|服务器内部错误，无法完成请求|\n|501|服务器不支持请求的功能，无法完成请求|\n|502|作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应|","source":"_posts/http介绍.md","raw":"---\ntitle: http介绍\ndate: 2021-10-29 14:48:44\ntags:\n---\n\n##### 1.简介\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，HTTP是一个基于TCP/IP通信协议来传递数据\n\n##### 2.HTTP工作原理\n- HTTP协议工作于客户端-服务端架构上\n- Web服务器根据接收到的请求后，向客户端发送响应信息\n- HTTP默认端口号为80\n\n##### 3.HTTP三个特点\n- HTTP是无连接，无连接的含义是限制每次连接只处理一个请求\n- HTTP是媒体独立的，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送\n- HTTP是无状态，无状态是指协议对于事务处理没有记忆能力\n\n##### 4.请求消息\n- 请求行（request line）\n- 请求头部（header）\n- 空行\n- 请求数据\n\n##### 5.响应消息\n- 状态行\n- 消息报头\n- 空行\n- 响应正文\n![响应消息结构](httpmessage.jpeg)\n\n##### 6.请求方法\n|方法|描述|\n|----|----|\n|GET|请求指定的页面信息，并返回实体主体。|\n|HEAD|类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头|\n|POST|向指定资源提交数据进行处理请求（例如提交表单或者上传文件）|\n|PUT|从客户端向服务器传送的数据取代指定的文档的内容。|\n|DELETE|请求服务器删除指定的页面。|\n|CONNECT|HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。|\n|OPTIONS|允许客户端查看服务器的性能。|\n|TRACE|回显服务器收到的请求，主要用于测试或诊断。|\n|PATCH|是对 PUT 方法的补充，用来对已知资源进行局部更新 。|\n\n##### 7.响应头信息\n\n|应答头|说明|\n|----|----|\n|Allow|服务器支持哪些请求方法（如GET、POST等）|\n|Content-Encoding|文档的编码（Encode）方法|\n|Content-Length|表示内容长度|\n|Content-Type|表示后面的文档属于什么MIME类型|\n|Date|当前的GMT时间|\n|Expires|应该在什么时候认为文档已经过期，从而不再缓存它？|\n|Last-Modified|文档的最后改动时间。|\n|Location|表示客户应当到哪里去提取文档|\n|Refresh|表示浏览器应该在多少时间之后刷新文档|\n|Server|服务器名字|\n|Set-Cookie|设置和页面关联的Cookie|\n\n##### 8.状态码\n- 200   请求成功\n- 300   资源（网页等）被永久转移到其它URL\n- 400   请求的资源（网页等）不存在\n- 500    内部服务器错误\n\n|状态码|描述|\n|----|----|\n|100|继续|\n|101|切换协议|\n|200|请求成功。一般用于GET与POST请求|\n|201|已创建。成功请求并创建了新的资源|\n|202|已接受。已经接受请求，但未处理完成|\n|203|非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本|\n|204|无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档|\n|300|多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择|\n|301|永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替|\n|302|时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI|\n|400|客户端请求的语法错误，服务器无法理解|\n|401|请求要求用户的身份认证|\n|402|保留，将来使用|\n|403|服务器理解请求客户端的请求，但是拒绝执行此请求|\n|500|服务器内部错误，无法完成请求|\n|501|服务器不支持请求的功能，无法完成请求|\n|502|作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应|","slug":"http介绍","published":1,"updated":"2021-11-04T08:20:58.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwou9u5o000b9hwn6te2f186","content":"\n        <h5 id=\"1-简介\">\n          <a href=\"#1-简介\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h5>\n      <p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，HTTP是一个基于TCP/IP通信协议来传递数据</p>\n\n        <h5 id=\"2-HTTP工作原理\">\n          <a href=\"#2-HTTP工作原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-HTTP工作原理\" class=\"headerlink\" title=\"2.HTTP工作原理\"></a>2.HTTP工作原理</h5>\n      <ul>\n<li>HTTP协议工作于客户端-服务端架构上</li>\n<li>Web服务器根据接收到的请求后，向客户端发送响应信息</li>\n<li>HTTP默认端口号为80</li>\n</ul>\n\n        <h5 id=\"3-HTTP三个特点\">\n          <a href=\"#3-HTTP三个特点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-HTTP三个特点\" class=\"headerlink\" title=\"3.HTTP三个特点\"></a>3.HTTP三个特点</h5>\n      <ul>\n<li>HTTP是无连接，无连接的含义是限制每次连接只处理一个请求</li>\n<li>HTTP是媒体独立的，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送</li>\n<li>HTTP是无状态，无状态是指协议对于事务处理没有记忆能力</li>\n</ul>\n\n        <h5 id=\"4-请求消息\">\n          <a href=\"#4-请求消息\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-请求消息\" class=\"headerlink\" title=\"4.请求消息\"></a>4.请求消息</h5>\n      <ul>\n<li>请求行（request line）</li>\n<li>请求头部（header）</li>\n<li>空行</li>\n<li>请求数据</li>\n</ul>\n\n        <h5 id=\"5-响应消息\">\n          <a href=\"#5-响应消息\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-响应消息\" class=\"headerlink\" title=\"5.响应消息\"></a>5.响应消息</h5>\n      <ul>\n<li>状态行</li>\n<li>消息报头</li>\n<li>空行</li>\n<li>响应正文<br><img src=\"httpmessage.jpeg\" alt=\"响应消息结构\"></li>\n</ul>\n\n        <h5 id=\"6-请求方法\">\n          <a href=\"#6-请求方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-请求方法\" class=\"headerlink\" title=\"6.请求方法\"></a>6.请求方法</h5>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n<tr>\n<td>PATCH</td>\n<td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>\n</tr>\n</tbody></table></div>\n\n        <h5 id=\"7-响应头信息\">\n          <a href=\"#7-响应头信息\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-响应头信息\" class=\"headerlink\" title=\"7.响应头信息\"></a>7.响应头信息</h5>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>应答头</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Allow</td>\n<td>服务器支持哪些请求方法（如GET、POST等）</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>文档的编码（Encode）方法</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>表示内容长度</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>表示后面的文档属于什么MIME类型</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>当前的GMT时间</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>应该在什么时候认为文档已经过期，从而不再缓存它？</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>文档的最后改动时间。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>表示客户应当到哪里去提取文档</td>\n</tr>\n<tr>\n<td>Refresh</td>\n<td>表示浏览器应该在多少时间之后刷新文档</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器名字</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置和页面关联的Cookie</td>\n</tr>\n</tbody></table></div>\n\n        <h5 id=\"8-状态码\">\n          <a href=\"#8-状态码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-状态码\" class=\"headerlink\" title=\"8.状态码\"></a>8.状态码</h5>\n      <ul>\n<li>200   请求成功</li>\n<li>300   资源（网页等）被永久转移到其它URL</li>\n<li>400   请求的资源（网页等）不存在</li>\n<li>500    内部服务器错误</li>\n</ul>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>100</td>\n<td>继续</td>\n</tr>\n<tr>\n<td>101</td>\n<td>切换协议</td>\n</tr>\n<tr>\n<td>200</td>\n<td>请求成功。一般用于GET与POST请求</td>\n</tr>\n<tr>\n<td>201</td>\n<td>已创建。成功请求并创建了新的资源</td>\n</tr>\n<tr>\n<td>202</td>\n<td>已接受。已经接受请求，但未处理完成</td>\n</tr>\n<tr>\n<td>203</td>\n<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>\n</tr>\n<tr>\n<td>204</td>\n<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>\n</tr>\n<tr>\n<td>300</td>\n<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>\n</tr>\n<tr>\n<td>301</td>\n<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>\n</tr>\n<tr>\n<td>302</td>\n<td>时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>\n</tr>\n<tr>\n<td>400</td>\n<td>客户端请求的语法错误，服务器无法理解</td>\n</tr>\n<tr>\n<td>401</td>\n<td>请求要求用户的身份认证</td>\n</tr>\n<tr>\n<td>402</td>\n<td>保留，将来使用</td>\n</tr>\n<tr>\n<td>403</td>\n<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>\n</tr>\n<tr>\n<td>500</td>\n<td>服务器内部错误，无法完成请求</td>\n</tr>\n<tr>\n<td>501</td>\n<td>服务器不支持请求的功能，无法完成请求</td>\n</tr>\n<tr>\n<td>502</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>\n</tr>\n</tbody></table></div>\n","site":{"data":{}},"excerpt":"","more":"\n        <h5 id=\"1-简介\">\n          <a href=\"#1-简介\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h5>\n      <p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议，HTTP是一个基于TCP/IP通信协议来传递数据</p>\n\n        <h5 id=\"2-HTTP工作原理\">\n          <a href=\"#2-HTTP工作原理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-HTTP工作原理\" class=\"headerlink\" title=\"2.HTTP工作原理\"></a>2.HTTP工作原理</h5>\n      <ul>\n<li>HTTP协议工作于客户端-服务端架构上</li>\n<li>Web服务器根据接收到的请求后，向客户端发送响应信息</li>\n<li>HTTP默认端口号为80</li>\n</ul>\n\n        <h5 id=\"3-HTTP三个特点\">\n          <a href=\"#3-HTTP三个特点\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-HTTP三个特点\" class=\"headerlink\" title=\"3.HTTP三个特点\"></a>3.HTTP三个特点</h5>\n      <ul>\n<li>HTTP是无连接，无连接的含义是限制每次连接只处理一个请求</li>\n<li>HTTP是媒体独立的，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送</li>\n<li>HTTP是无状态，无状态是指协议对于事务处理没有记忆能力</li>\n</ul>\n\n        <h5 id=\"4-请求消息\">\n          <a href=\"#4-请求消息\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-请求消息\" class=\"headerlink\" title=\"4.请求消息\"></a>4.请求消息</h5>\n      <ul>\n<li>请求行（request line）</li>\n<li>请求头部（header）</li>\n<li>空行</li>\n<li>请求数据</li>\n</ul>\n\n        <h5 id=\"5-响应消息\">\n          <a href=\"#5-响应消息\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-响应消息\" class=\"headerlink\" title=\"5.响应消息\"></a>5.响应消息</h5>\n      <ul>\n<li>状态行</li>\n<li>消息报头</li>\n<li>空行</li>\n<li>响应正文<br><img src=\"httpmessage.jpeg\" alt=\"响应消息结构\"></li>\n</ul>\n\n        <h5 id=\"6-请求方法\">\n          <a href=\"#6-请求方法\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-请求方法\" class=\"headerlink\" title=\"6.请求方法\"></a>6.请求方法</h5>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>HEAD</td>\n<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>CONNECT</td>\n<td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n<tr>\n<td>PATCH</td>\n<td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>\n</tr>\n</tbody></table></div>\n\n        <h5 id=\"7-响应头信息\">\n          <a href=\"#7-响应头信息\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-响应头信息\" class=\"headerlink\" title=\"7.响应头信息\"></a>7.响应头信息</h5>\n      <div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>应答头</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Allow</td>\n<td>服务器支持哪些请求方法（如GET、POST等）</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>文档的编码（Encode）方法</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>表示内容长度</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>表示后面的文档属于什么MIME类型</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>当前的GMT时间</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>应该在什么时候认为文档已经过期，从而不再缓存它？</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>文档的最后改动时间。</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>表示客户应当到哪里去提取文档</td>\n</tr>\n<tr>\n<td>Refresh</td>\n<td>表示浏览器应该在多少时间之后刷新文档</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>服务器名字</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置和页面关联的Cookie</td>\n</tr>\n</tbody></table></div>\n\n        <h5 id=\"8-状态码\">\n          <a href=\"#8-状态码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-状态码\" class=\"headerlink\" title=\"8.状态码\"></a>8.状态码</h5>\n      <ul>\n<li>200   请求成功</li>\n<li>300   资源（网页等）被永久转移到其它URL</li>\n<li>400   请求的资源（网页等）不存在</li>\n<li>500    内部服务器错误</li>\n</ul>\n<div class=\"table-container\"><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>100</td>\n<td>继续</td>\n</tr>\n<tr>\n<td>101</td>\n<td>切换协议</td>\n</tr>\n<tr>\n<td>200</td>\n<td>请求成功。一般用于GET与POST请求</td>\n</tr>\n<tr>\n<td>201</td>\n<td>已创建。成功请求并创建了新的资源</td>\n</tr>\n<tr>\n<td>202</td>\n<td>已接受。已经接受请求，但未处理完成</td>\n</tr>\n<tr>\n<td>203</td>\n<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>\n</tr>\n<tr>\n<td>204</td>\n<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>\n</tr>\n<tr>\n<td>300</td>\n<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>\n</tr>\n<tr>\n<td>301</td>\n<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>\n</tr>\n<tr>\n<td>302</td>\n<td>时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>\n</tr>\n<tr>\n<td>400</td>\n<td>客户端请求的语法错误，服务器无法理解</td>\n</tr>\n<tr>\n<td>401</td>\n<td>请求要求用户的身份认证</td>\n</tr>\n<tr>\n<td>402</td>\n<td>保留，将来使用</td>\n</tr>\n<tr>\n<td>403</td>\n<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>\n</tr>\n<tr>\n<td>500</td>\n<td>服务器内部错误，无法完成请求</td>\n</tr>\n<tr>\n<td>501</td>\n<td>服务器不支持请求的功能，无法完成请求</td>\n</tr>\n<tr>\n<td>502</td>\n<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>\n</tr>\n</tbody></table></div>\n"},{"title":"javascript入门教程","date":"2020-01-30T15:13:02.000Z","_content":"\n##### 1. 关于javascript\n    JavaScript 是互联网上最流行的脚本语言\n\n##### 2. 历史版本\n    1997    ECMAScript1\n    1998    ECMAScript2\n    1999    ECMAScript3\n    2009    ECMAScript5\n    2011    ECMAScript5.1\n    2015    ECMAScript6\n    2016    ECMAScript7\n\n##### 3. 数据类型\n   值类型（基本类型）：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol\n\n   引用数据类型：对象(Object)、数组(Array)、函数(Function) \n\n   null表示一个空对象引用\n   undefined表示未定义、未初始化\n```\n// null与undefined值相等，但类型不等\nnull === undefined   // false\nnull == undefined   // true\n```\n\n##### 4. 条件语句\n    if \n    if...else\n    if...else...if\n    switch  \n```\nswitch (n) {\n    case 1:\n        执行代码块 1\n        break;\n    case 2:\n        执行代码块 2\n        break;\n    default: \n        与 case 1 和 case 2 不同时执行的代码\n}\n``` \n    \n\n5. 循环语句\nfor\nfor/in\nwhile\ndo/while\n\n```\nfor (语句 1; 语句 2; 语句 3) {\n    被执行的代码块\n}\n\nvar person={fname:\"Bill\",lname:\"Gates\",age:56}; \n \nfor (x in person)  // x 为属性名\n{\n    txt=txt + person[x];\n}\n\nwhile (条件)\n{\n    需要执行的代码\n}\n\ndo\n{\n    需要执行的代码\n}\nwhile (条件)\n```\n\n##### 6. typeof\n作用：判断变量数据类型，可判断string、number、boolean、undefined、function、object\n```\ntypeof 'abc'    // string\ntypeof 12   // number\ntypeof true // boolean\ntypeof null // object\ntypeof function fn(a, b) => {return a + b}  // function\ntypeof [1,2,3]  // object\n```\n\n##### 7. 正则表达式\n   正则表达式是由一个字符序列形成的搜索模式\n\n##### 8. 变量提升\nJavaScript 中，函数及变量的声明都将被提升到函数的最顶部，变量可以在使用后声明\n```\nx = 5; // 变量 x 设置为 5\n\nelem = document.getElementById(\"demo\"); // 查找元素\nelem.innerHTML = x;                     // 在元素中显示 x\n\nvar x; // 声明 x\n```\n\n##### 9. this关键字\n    面向对象语言中 this 表示当前对象的一个引用\n（1）在方法中，this 表示该方法所属的对象。\n（2）如果单独使用，this 表示全局对象。\n（3）在函数中，this 表示全局对象。\n（4）在函数中，在严格模式下，this 是未定义的(undefined)。\n（5）在事件中，this 表示接收事件的元素。\n（6）类似 call() 和 apply() 方法可以将 this 引用到任何对象。\n```\n// 单独使用this，指向全局对象\nvar x = this\nconsole.log(this)   // Window\n\n// 对象方法中使用this，指向它所在方法的对象\nvar person = {\n    name: 'carr',\n    showName: function () {\n        console.log(this.name)  // carr\n    }\n}\n\n// 函数中使用this，严格模式下指向undefined，非严格模式下指向全局对象\nfunction fn () {\n    console.log(this)   // Window\n}\nfunction fn () {\n    'use strict';\n    console.log(this)\n}\n\n// 事件中的this，指向接受事件的HTML元素\n<button onClick=\"this.style.display='none'\"></button>\n\n// 使用call改变this指向\nvar person1 = {\n  fullName: function() {\n    return this.firstName + \" \" + this.lastName;\n  }\n}\nvar person2 = {\n  firstName:\"John\",\n  lastName: \"Doe\",\n}\nperson1.fullName.call(person2);  // 返回 \"John Doe\"\n``` \n\n##### 10. 函数\n（1）函数声明\n```\nfunction fn (a, b) { return a + b }\n```\n\n(2) 函数表达式\n```\nvar fn = function (a, b) { return a + b }\n```\n\n(3) 函数提升\n函数可以在声明之前调用\n```\nfn()\nfunction fn (a, b) {\n    return a + b\n}\n```\n\n(4) 自执行函数\n```\n(function())(\n    console.log('hello')\n)\n```\n\n(5) 函数是对象\n函数有arguments属性，它是包含所有参数的数组\n```\nfunction fn (a, b) {\n    return arguments.length\n}\n```\n\n(6) 箭头函数\n箭头函数没有自己的this，箭头函数中的this和外层this的值一样\n箭头函数没有arguments属性\n箭头函数不能作为构造函数\n\n(7) 默认参数\n```\n// ES5设置默认参数\nfunction fn (x, y) {\n    y = y || 0\n}\n\n// ES6设置默认参数\nfunction fn (a, b = 0) {\n    return a + b\n}\n```\n\n(8) 闭包\n```\nvar add = (function () {\n    var counter = 0\n    return function () {\n        return counter += 1\n    }\n})()\n```\n\n##### 13. 面向对象\n(1)原型\n\n(2)原型链\n\n(3)继承\n\n##### 14. String\n(1) indexOf // 返回字符串中某一个指定的字符首次出现的位置\n```\nvar str = 'Hello world, wclcome to the universe'\nvar n = str.indexOf('welcome')\n```\n\n(2) match\n\n(3) replace()\n\n(4) toUpperCase() / toLowerCase()\n\n(5) split()\n\n(6) slice()\n\n(7) search()\n\n(8) substr()\n\n(9) valueOf()\n\n(10) charAt()\n\n(11) charCodeAt()\n\n##### 15. Number\n\n##### 16. Array\n\n##### 17. Boolean\n\n##### 18. Math\n\n##### 19. Date\n\n##### 20. RegExp\n\n##### 21. DOM\n(1) DOM(Document object Model) 文档对象模型\n(2) DOM事件\nonload/onunload 进入或离开页面时触发\nonchange\nonmouseover\nonmouseout\nonmousedown\nonmouseup\nonclik\n\n(3) 事件绑定\naddEventListener    // 事件绑定\nremoveEventListener // 解除事件绑定\n\n```\nelement.addEventListener('click', function () {\n    console.log('hello world')\n})\n```\n\n(4)事件冒泡和事件捕获\n事件传递的方式有两种：事件冒泡或事件捕获\n在冒泡中，内部元素的事件会先触发。然后再触发外部元素\n在捕获中，外部元素的事件会被先触发，然后才会触发内部元素\n\n(5)向Window对象添加事件\n```\nwindow.addEvenetListener('resize', function () {\n    ...\n})\n```\n\n##### 22. BOM\n(1) BOM(Browser object Model) 浏览器对象模型 \n\n(2) window尺寸\nwindow.innerHeight  浏览器窗口的内部高度(包括滚动条)\nwindow.innerWidth - 浏览器窗口的内部宽度(包括滚动条)\n\n(3)window方法\nwindow.open()   打开新窗口\nwindow.close()  关闭当前窗口\nwindow.moveTo() 移动当前窗口\nwindow.resizeTo()  调整当前窗口的尺寸\n\n(4)","source":"_posts/javascript入门教程.md","raw":"---\ntitle: javascript入门教程\ndate: 2020-1-30 23:13:02\ntags:\n---\n\n##### 1. 关于javascript\n    JavaScript 是互联网上最流行的脚本语言\n\n##### 2. 历史版本\n    1997    ECMAScript1\n    1998    ECMAScript2\n    1999    ECMAScript3\n    2009    ECMAScript5\n    2011    ECMAScript5.1\n    2015    ECMAScript6\n    2016    ECMAScript7\n\n##### 3. 数据类型\n   值类型（基本类型）：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol\n\n   引用数据类型：对象(Object)、数组(Array)、函数(Function) \n\n   null表示一个空对象引用\n   undefined表示未定义、未初始化\n```\n// null与undefined值相等，但类型不等\nnull === undefined   // false\nnull == undefined   // true\n```\n\n##### 4. 条件语句\n    if \n    if...else\n    if...else...if\n    switch  \n```\nswitch (n) {\n    case 1:\n        执行代码块 1\n        break;\n    case 2:\n        执行代码块 2\n        break;\n    default: \n        与 case 1 和 case 2 不同时执行的代码\n}\n``` \n    \n\n5. 循环语句\nfor\nfor/in\nwhile\ndo/while\n\n```\nfor (语句 1; 语句 2; 语句 3) {\n    被执行的代码块\n}\n\nvar person={fname:\"Bill\",lname:\"Gates\",age:56}; \n \nfor (x in person)  // x 为属性名\n{\n    txt=txt + person[x];\n}\n\nwhile (条件)\n{\n    需要执行的代码\n}\n\ndo\n{\n    需要执行的代码\n}\nwhile (条件)\n```\n\n##### 6. typeof\n作用：判断变量数据类型，可判断string、number、boolean、undefined、function、object\n```\ntypeof 'abc'    // string\ntypeof 12   // number\ntypeof true // boolean\ntypeof null // object\ntypeof function fn(a, b) => {return a + b}  // function\ntypeof [1,2,3]  // object\n```\n\n##### 7. 正则表达式\n   正则表达式是由一个字符序列形成的搜索模式\n\n##### 8. 变量提升\nJavaScript 中，函数及变量的声明都将被提升到函数的最顶部，变量可以在使用后声明\n```\nx = 5; // 变量 x 设置为 5\n\nelem = document.getElementById(\"demo\"); // 查找元素\nelem.innerHTML = x;                     // 在元素中显示 x\n\nvar x; // 声明 x\n```\n\n##### 9. this关键字\n    面向对象语言中 this 表示当前对象的一个引用\n（1）在方法中，this 表示该方法所属的对象。\n（2）如果单独使用，this 表示全局对象。\n（3）在函数中，this 表示全局对象。\n（4）在函数中，在严格模式下，this 是未定义的(undefined)。\n（5）在事件中，this 表示接收事件的元素。\n（6）类似 call() 和 apply() 方法可以将 this 引用到任何对象。\n```\n// 单独使用this，指向全局对象\nvar x = this\nconsole.log(this)   // Window\n\n// 对象方法中使用this，指向它所在方法的对象\nvar person = {\n    name: 'carr',\n    showName: function () {\n        console.log(this.name)  // carr\n    }\n}\n\n// 函数中使用this，严格模式下指向undefined，非严格模式下指向全局对象\nfunction fn () {\n    console.log(this)   // Window\n}\nfunction fn () {\n    'use strict';\n    console.log(this)\n}\n\n// 事件中的this，指向接受事件的HTML元素\n<button onClick=\"this.style.display='none'\"></button>\n\n// 使用call改变this指向\nvar person1 = {\n  fullName: function() {\n    return this.firstName + \" \" + this.lastName;\n  }\n}\nvar person2 = {\n  firstName:\"John\",\n  lastName: \"Doe\",\n}\nperson1.fullName.call(person2);  // 返回 \"John Doe\"\n``` \n\n##### 10. 函数\n（1）函数声明\n```\nfunction fn (a, b) { return a + b }\n```\n\n(2) 函数表达式\n```\nvar fn = function (a, b) { return a + b }\n```\n\n(3) 函数提升\n函数可以在声明之前调用\n```\nfn()\nfunction fn (a, b) {\n    return a + b\n}\n```\n\n(4) 自执行函数\n```\n(function())(\n    console.log('hello')\n)\n```\n\n(5) 函数是对象\n函数有arguments属性，它是包含所有参数的数组\n```\nfunction fn (a, b) {\n    return arguments.length\n}\n```\n\n(6) 箭头函数\n箭头函数没有自己的this，箭头函数中的this和外层this的值一样\n箭头函数没有arguments属性\n箭头函数不能作为构造函数\n\n(7) 默认参数\n```\n// ES5设置默认参数\nfunction fn (x, y) {\n    y = y || 0\n}\n\n// ES6设置默认参数\nfunction fn (a, b = 0) {\n    return a + b\n}\n```\n\n(8) 闭包\n```\nvar add = (function () {\n    var counter = 0\n    return function () {\n        return counter += 1\n    }\n})()\n```\n\n##### 13. 面向对象\n(1)原型\n\n(2)原型链\n\n(3)继承\n\n##### 14. String\n(1) indexOf // 返回字符串中某一个指定的字符首次出现的位置\n```\nvar str = 'Hello world, wclcome to the universe'\nvar n = str.indexOf('welcome')\n```\n\n(2) match\n\n(3) replace()\n\n(4) toUpperCase() / toLowerCase()\n\n(5) split()\n\n(6) slice()\n\n(7) search()\n\n(8) substr()\n\n(9) valueOf()\n\n(10) charAt()\n\n(11) charCodeAt()\n\n##### 15. Number\n\n##### 16. Array\n\n##### 17. Boolean\n\n##### 18. Math\n\n##### 19. Date\n\n##### 20. RegExp\n\n##### 21. DOM\n(1) DOM(Document object Model) 文档对象模型\n(2) DOM事件\nonload/onunload 进入或离开页面时触发\nonchange\nonmouseover\nonmouseout\nonmousedown\nonmouseup\nonclik\n\n(3) 事件绑定\naddEventListener    // 事件绑定\nremoveEventListener // 解除事件绑定\n\n```\nelement.addEventListener('click', function () {\n    console.log('hello world')\n})\n```\n\n(4)事件冒泡和事件捕获\n事件传递的方式有两种：事件冒泡或事件捕获\n在冒泡中，内部元素的事件会先触发。然后再触发外部元素\n在捕获中，外部元素的事件会被先触发，然后才会触发内部元素\n\n(5)向Window对象添加事件\n```\nwindow.addEvenetListener('resize', function () {\n    ...\n})\n```\n\n##### 22. BOM\n(1) BOM(Browser object Model) 浏览器对象模型 \n\n(2) window尺寸\nwindow.innerHeight  浏览器窗口的内部高度(包括滚动条)\nwindow.innerWidth - 浏览器窗口的内部宽度(包括滚动条)\n\n(3)window方法\nwindow.open()   打开新窗口\nwindow.close()  关闭当前窗口\nwindow.moveTo() 移动当前窗口\nwindow.resizeTo()  调整当前窗口的尺寸\n\n(4)","slug":"javascript入门教程","published":1,"updated":"2021-12-20T10:07:10.877Z","_id":"ckwou9u5p000c9hwn0kuud8t6","comments":1,"layout":"post","photos":[],"link":"","content":"<h5 id=\"1-关于javascript\"><a href=\"#1-关于javascript\" class=\"headerlink\" title=\"1. 关于javascript\"></a>1. 关于javascript</h5><pre><code>JavaScript 是互联网上最流行的脚本语言\n</code></pre>\n<h5 id=\"2-历史版本\"><a href=\"#2-历史版本\" class=\"headerlink\" title=\"2. 历史版本\"></a>2. 历史版本</h5><pre><code>1997    ECMAScript1\n1998    ECMAScript2\n1999    ECMAScript3\n2009    ECMAScript5\n2011    ECMAScript5.1\n2015    ECMAScript6\n2016    ECMAScript7\n</code></pre>\n<h5 id=\"3-数据类型\"><a href=\"#3-数据类型\" class=\"headerlink\" title=\"3. 数据类型\"></a>3. 数据类型</h5><p>   值类型（基本类型）：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol</p>\n<p>   引用数据类型：对象(Object)、数组(Array)、函数(Function) </p>\n<p>   null表示一个空对象引用<br>   undefined表示未定义、未初始化</p>\n<pre><code>// null与undefined值相等，但类型不等\nnull === undefined   // false\nnull == undefined   // true\n</code></pre>\n<h5 id=\"4-条件语句\"><a href=\"#4-条件语句\" class=\"headerlink\" title=\"4. 条件语句\"></a>4. 条件语句</h5><pre><code>if \nif...else\nif...else...if\nswitch  \n</code></pre>\n<pre><code>switch (n) &#123;\n    case 1:\n        执行代码块 1\n        break;\n    case 2:\n        执行代码块 2\n        break;\n    default: \n        与 case 1 和 case 2 不同时执行的代码\n&#125;\n</code></pre>\n<ol start=\"5\">\n<li>循环语句<br>for<br>for/in<br>while<br>do/while</li>\n</ol>\n<pre><code>for (语句 1; 语句 2; 语句 3) &#123;\n    被执行的代码块\n&#125;\n\nvar person=&#123;fname:&quot;Bill&quot;,lname:&quot;Gates&quot;,age:56&#125;; \n \nfor (x in person)  // x 为属性名\n&#123;\n    txt=txt + person[x];\n&#125;\n\nwhile (条件)\n&#123;\n    需要执行的代码\n&#125;\n\ndo\n&#123;\n    需要执行的代码\n&#125;\nwhile (条件)\n</code></pre>\n<h5 id=\"6-typeof\"><a href=\"#6-typeof\" class=\"headerlink\" title=\"6. typeof\"></a>6. typeof</h5><p>作用：判断变量数据类型，可判断string、number、boolean、undefined、function、object</p>\n<pre><code>typeof &#39;abc&#39;    // string\ntypeof 12   // number\ntypeof true // boolean\ntypeof null // object\ntypeof function fn(a, b) =&gt; &#123;return a + b&#125;  // function\ntypeof [1,2,3]  // object\n</code></pre>\n<h5 id=\"7-正则表达式\"><a href=\"#7-正则表达式\" class=\"headerlink\" title=\"7. 正则表达式\"></a>7. 正则表达式</h5><p>   正则表达式是由一个字符序列形成的搜索模式</p>\n<h5 id=\"8-变量提升\"><a href=\"#8-变量提升\" class=\"headerlink\" title=\"8. 变量提升\"></a>8. 变量提升</h5><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部，变量可以在使用后声明</p>\n<pre><code>x = 5; // 变量 x 设置为 5\n\nelem = document.getElementById(&quot;demo&quot;); // 查找元素\nelem.innerHTML = x;                     // 在元素中显示 x\n\nvar x; // 声明 x\n</code></pre>\n<h5 id=\"9-this关键字\"><a href=\"#9-this关键字\" class=\"headerlink\" title=\"9. this关键字\"></a>9. this关键字</h5><pre><code>面向对象语言中 this 表示当前对象的一个引用\n</code></pre>\n<p>（1）在方法中，this 表示该方法所属的对象。<br>（2）如果单独使用，this 表示全局对象。<br>（3）在函数中，this 表示全局对象。<br>（4）在函数中，在严格模式下，this 是未定义的(undefined)。<br>（5）在事件中，this 表示接收事件的元素。<br>（6）类似 call() 和 apply() 方法可以将 this 引用到任何对象。</p>\n<pre><code>// 单独使用this，指向全局对象\nvar x = this\nconsole.log(this)   // Window\n\n// 对象方法中使用this，指向它所在方法的对象\nvar person = &#123;\n    name: &#39;carr&#39;,\n    showName: function () &#123;\n        console.log(this.name)  // carr\n    &#125;\n&#125;\n\n// 函数中使用this，严格模式下指向undefined，非严格模式下指向全局对象\nfunction fn () &#123;\n    console.log(this)   // Window\n&#125;\nfunction fn () &#123;\n    &#39;use strict&#39;;\n    console.log(this)\n&#125;\n\n// 事件中的this，指向接受事件的HTML元素\n&lt;button onClick=&quot;this.style.display=&#39;none&#39;&quot;&gt;&lt;/button&gt;\n\n// 使用call改变this指向\nvar person1 = &#123;\n  fullName: function() &#123;\n    return this.firstName + &quot; &quot; + this.lastName;\n  &#125;\n&#125;\nvar person2 = &#123;\n  firstName:&quot;John&quot;,\n  lastName: &quot;Doe&quot;,\n&#125;\nperson1.fullName.call(person2);  // 返回 &quot;John Doe&quot;\n</code></pre>\n<h5 id=\"10-函数\"><a href=\"#10-函数\" class=\"headerlink\" title=\"10. 函数\"></a>10. 函数</h5><p>（1）函数声明</p>\n<pre><code>function fn (a, b) &#123; return a + b &#125;\n</code></pre>\n<p>(2) 函数表达式</p>\n<pre><code>var fn = function (a, b) &#123; return a + b &#125;\n</code></pre>\n<p>(3) 函数提升<br>函数可以在声明之前调用</p>\n<pre><code>fn()\nfunction fn (a, b) &#123;\n    return a + b\n&#125;\n</code></pre>\n<p>(4) 自执行函数</p>\n<pre><code>(function())(\n    console.log(&#39;hello&#39;)\n)\n</code></pre>\n<p>(5) 函数是对象<br>函数有arguments属性，它是包含所有参数的数组</p>\n<pre><code>function fn (a, b) &#123;\n    return arguments.length\n&#125;\n</code></pre>\n<p>(6) 箭头函数<br>箭头函数没有自己的this，箭头函数中的this和外层this的值一样<br>箭头函数没有arguments属性<br>箭头函数不能作为构造函数</p>\n<p>(7) 默认参数</p>\n<pre><code>// ES5设置默认参数\nfunction fn (x, y) &#123;\n    y = y || 0\n&#125;\n\n// ES6设置默认参数\nfunction fn (a, b = 0) &#123;\n    return a + b\n&#125;\n</code></pre>\n<p>(8) 闭包</p>\n<pre><code>var add = (function () &#123;\n    var counter = 0\n    return function () &#123;\n        return counter += 1\n    &#125;\n&#125;)()\n</code></pre>\n<h5 id=\"13-面向对象\"><a href=\"#13-面向对象\" class=\"headerlink\" title=\"13. 面向对象\"></a>13. 面向对象</h5><p>(1)原型</p>\n<p>(2)原型链</p>\n<p>(3)继承</p>\n<h5 id=\"14-String\"><a href=\"#14-String\" class=\"headerlink\" title=\"14. String\"></a>14. String</h5><p>(1) indexOf // 返回字符串中某一个指定的字符首次出现的位置</p>\n<pre><code>var str = &#39;Hello world, wclcome to the universe&#39;\nvar n = str.indexOf(&#39;welcome&#39;)\n</code></pre>\n<p>(2) match</p>\n<p>(3) replace()</p>\n<p>(4) toUpperCase() / toLowerCase()</p>\n<p>(5) split()</p>\n<p>(6) slice()</p>\n<p>(7) search()</p>\n<p>(8) substr()</p>\n<p>(9) valueOf()</p>\n<p>(10) charAt()</p>\n<p>(11) charCodeAt()</p>\n<h5 id=\"15-Number\"><a href=\"#15-Number\" class=\"headerlink\" title=\"15. Number\"></a>15. Number</h5><h5 id=\"16-Array\"><a href=\"#16-Array\" class=\"headerlink\" title=\"16. Array\"></a>16. Array</h5><h5 id=\"17-Boolean\"><a href=\"#17-Boolean\" class=\"headerlink\" title=\"17. Boolean\"></a>17. Boolean</h5><h5 id=\"18-Math\"><a href=\"#18-Math\" class=\"headerlink\" title=\"18. Math\"></a>18. Math</h5><h5 id=\"19-Date\"><a href=\"#19-Date\" class=\"headerlink\" title=\"19. Date\"></a>19. Date</h5><h5 id=\"20-RegExp\"><a href=\"#20-RegExp\" class=\"headerlink\" title=\"20. RegExp\"></a>20. RegExp</h5><h5 id=\"21-DOM\"><a href=\"#21-DOM\" class=\"headerlink\" title=\"21. DOM\"></a>21. DOM</h5><p>(1) DOM(Document object Model) 文档对象模型<br>(2) DOM事件<br>onload/onunload 进入或离开页面时触发<br>onchange<br>onmouseover<br>onmouseout<br>onmousedown<br>onmouseup<br>onclik</p>\n<p>(3) 事件绑定<br>addEventListener    // 事件绑定<br>removeEventListener // 解除事件绑定</p>\n<pre><code>element.addEventListener(&#39;click&#39;, function () &#123;\n    console.log(&#39;hello world&#39;)\n&#125;)\n</code></pre>\n<p>(4)事件冒泡和事件捕获<br>事件传递的方式有两种：事件冒泡或事件捕获<br>在冒泡中，内部元素的事件会先触发。然后再触发外部元素<br>在捕获中，外部元素的事件会被先触发，然后才会触发内部元素</p>\n<p>(5)向Window对象添加事件</p>\n<pre><code>window.addEvenetListener(&#39;resize&#39;, function () &#123;\n    ...\n&#125;)\n</code></pre>\n<h5 id=\"22-BOM\"><a href=\"#22-BOM\" class=\"headerlink\" title=\"22. BOM\"></a>22. BOM</h5><p>(1) BOM(Browser object Model) 浏览器对象模型 </p>\n<p>(2) window尺寸<br>window.innerHeight  浏览器窗口的内部高度(包括滚动条)<br>window.innerWidth - 浏览器窗口的内部宽度(包括滚动条)</p>\n<p>(3)window方法<br>window.open()   打开新窗口<br>window.close()  关闭当前窗口<br>window.moveTo() 移动当前窗口<br>window.resizeTo()  调整当前窗口的尺寸</p>\n<p>(4)</p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"1-关于javascript\"><a href=\"#1-关于javascript\" class=\"headerlink\" title=\"1. 关于javascript\"></a>1. 关于javascript</h5><pre><code>JavaScript 是互联网上最流行的脚本语言\n</code></pre>\n<h5 id=\"2-历史版本\"><a href=\"#2-历史版本\" class=\"headerlink\" title=\"2. 历史版本\"></a>2. 历史版本</h5><pre><code>1997    ECMAScript1\n1998    ECMAScript2\n1999    ECMAScript3\n2009    ECMAScript5\n2011    ECMAScript5.1\n2015    ECMAScript6\n2016    ECMAScript7\n</code></pre>\n<h5 id=\"3-数据类型\"><a href=\"#3-数据类型\" class=\"headerlink\" title=\"3. 数据类型\"></a>3. 数据类型</h5><p>   值类型（基本类型）：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol</p>\n<p>   引用数据类型：对象(Object)、数组(Array)、函数(Function) </p>\n<p>   null表示一个空对象引用<br>   undefined表示未定义、未初始化</p>\n<pre><code>// null与undefined值相等，但类型不等\nnull === undefined   // false\nnull == undefined   // true\n</code></pre>\n<h5 id=\"4-条件语句\"><a href=\"#4-条件语句\" class=\"headerlink\" title=\"4. 条件语句\"></a>4. 条件语句</h5><pre><code>if \nif...else\nif...else...if\nswitch  \n</code></pre>\n<pre><code>switch (n) &#123;\n    case 1:\n        执行代码块 1\n        break;\n    case 2:\n        执行代码块 2\n        break;\n    default: \n        与 case 1 和 case 2 不同时执行的代码\n&#125;\n</code></pre>\n<ol start=\"5\">\n<li>循环语句<br>for<br>for/in<br>while<br>do/while</li>\n</ol>\n<pre><code>for (语句 1; 语句 2; 语句 3) &#123;\n    被执行的代码块\n&#125;\n\nvar person=&#123;fname:&quot;Bill&quot;,lname:&quot;Gates&quot;,age:56&#125;; \n \nfor (x in person)  // x 为属性名\n&#123;\n    txt=txt + person[x];\n&#125;\n\nwhile (条件)\n&#123;\n    需要执行的代码\n&#125;\n\ndo\n&#123;\n    需要执行的代码\n&#125;\nwhile (条件)\n</code></pre>\n<h5 id=\"6-typeof\"><a href=\"#6-typeof\" class=\"headerlink\" title=\"6. typeof\"></a>6. typeof</h5><p>作用：判断变量数据类型，可判断string、number、boolean、undefined、function、object</p>\n<pre><code>typeof &#39;abc&#39;    // string\ntypeof 12   // number\ntypeof true // boolean\ntypeof null // object\ntypeof function fn(a, b) =&gt; &#123;return a + b&#125;  // function\ntypeof [1,2,3]  // object\n</code></pre>\n<h5 id=\"7-正则表达式\"><a href=\"#7-正则表达式\" class=\"headerlink\" title=\"7. 正则表达式\"></a>7. 正则表达式</h5><p>   正则表达式是由一个字符序列形成的搜索模式</p>\n<h5 id=\"8-变量提升\"><a href=\"#8-变量提升\" class=\"headerlink\" title=\"8. 变量提升\"></a>8. 变量提升</h5><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部，变量可以在使用后声明</p>\n<pre><code>x = 5; // 变量 x 设置为 5\n\nelem = document.getElementById(&quot;demo&quot;); // 查找元素\nelem.innerHTML = x;                     // 在元素中显示 x\n\nvar x; // 声明 x\n</code></pre>\n<h5 id=\"9-this关键字\"><a href=\"#9-this关键字\" class=\"headerlink\" title=\"9. this关键字\"></a>9. this关键字</h5><pre><code>面向对象语言中 this 表示当前对象的一个引用\n</code></pre>\n<p>（1）在方法中，this 表示该方法所属的对象。<br>（2）如果单独使用，this 表示全局对象。<br>（3）在函数中，this 表示全局对象。<br>（4）在函数中，在严格模式下，this 是未定义的(undefined)。<br>（5）在事件中，this 表示接收事件的元素。<br>（6）类似 call() 和 apply() 方法可以将 this 引用到任何对象。</p>\n<pre><code>// 单独使用this，指向全局对象\nvar x = this\nconsole.log(this)   // Window\n\n// 对象方法中使用this，指向它所在方法的对象\nvar person = &#123;\n    name: &#39;carr&#39;,\n    showName: function () &#123;\n        console.log(this.name)  // carr\n    &#125;\n&#125;\n\n// 函数中使用this，严格模式下指向undefined，非严格模式下指向全局对象\nfunction fn () &#123;\n    console.log(this)   // Window\n&#125;\nfunction fn () &#123;\n    &#39;use strict&#39;;\n    console.log(this)\n&#125;\n\n// 事件中的this，指向接受事件的HTML元素\n&lt;button onClick=&quot;this.style.display=&#39;none&#39;&quot;&gt;&lt;/button&gt;\n\n// 使用call改变this指向\nvar person1 = &#123;\n  fullName: function() &#123;\n    return this.firstName + &quot; &quot; + this.lastName;\n  &#125;\n&#125;\nvar person2 = &#123;\n  firstName:&quot;John&quot;,\n  lastName: &quot;Doe&quot;,\n&#125;\nperson1.fullName.call(person2);  // 返回 &quot;John Doe&quot;\n</code></pre>\n<h5 id=\"10-函数\"><a href=\"#10-函数\" class=\"headerlink\" title=\"10. 函数\"></a>10. 函数</h5><p>（1）函数声明</p>\n<pre><code>function fn (a, b) &#123; return a + b &#125;\n</code></pre>\n<p>(2) 函数表达式</p>\n<pre><code>var fn = function (a, b) &#123; return a + b &#125;\n</code></pre>\n<p>(3) 函数提升<br>函数可以在声明之前调用</p>\n<pre><code>fn()\nfunction fn (a, b) &#123;\n    return a + b\n&#125;\n</code></pre>\n<p>(4) 自执行函数</p>\n<pre><code>(function())(\n    console.log(&#39;hello&#39;)\n)\n</code></pre>\n<p>(5) 函数是对象<br>函数有arguments属性，它是包含所有参数的数组</p>\n<pre><code>function fn (a, b) &#123;\n    return arguments.length\n&#125;\n</code></pre>\n<p>(6) 箭头函数<br>箭头函数没有自己的this，箭头函数中的this和外层this的值一样<br>箭头函数没有arguments属性<br>箭头函数不能作为构造函数</p>\n<p>(7) 默认参数</p>\n<pre><code>// ES5设置默认参数\nfunction fn (x, y) &#123;\n    y = y || 0\n&#125;\n\n// ES6设置默认参数\nfunction fn (a, b = 0) &#123;\n    return a + b\n&#125;\n</code></pre>\n<p>(8) 闭包</p>\n<pre><code>var add = (function () &#123;\n    var counter = 0\n    return function () &#123;\n        return counter += 1\n    &#125;\n&#125;)()\n</code></pre>\n<h5 id=\"13-面向对象\"><a href=\"#13-面向对象\" class=\"headerlink\" title=\"13. 面向对象\"></a>13. 面向对象</h5><p>(1)原型</p>\n<p>(2)原型链</p>\n<p>(3)继承</p>\n<h5 id=\"14-String\"><a href=\"#14-String\" class=\"headerlink\" title=\"14. String\"></a>14. String</h5><p>(1) indexOf // 返回字符串中某一个指定的字符首次出现的位置</p>\n<pre><code>var str = &#39;Hello world, wclcome to the universe&#39;\nvar n = str.indexOf(&#39;welcome&#39;)\n</code></pre>\n<p>(2) match</p>\n<p>(3) replace()</p>\n<p>(4) toUpperCase() / toLowerCase()</p>\n<p>(5) split()</p>\n<p>(6) slice()</p>\n<p>(7) search()</p>\n<p>(8) substr()</p>\n<p>(9) valueOf()</p>\n<p>(10) charAt()</p>\n<p>(11) charCodeAt()</p>\n<h5 id=\"15-Number\"><a href=\"#15-Number\" class=\"headerlink\" title=\"15. Number\"></a>15. Number</h5><h5 id=\"16-Array\"><a href=\"#16-Array\" class=\"headerlink\" title=\"16. Array\"></a>16. Array</h5><h5 id=\"17-Boolean\"><a href=\"#17-Boolean\" class=\"headerlink\" title=\"17. Boolean\"></a>17. Boolean</h5><h5 id=\"18-Math\"><a href=\"#18-Math\" class=\"headerlink\" title=\"18. Math\"></a>18. Math</h5><h5 id=\"19-Date\"><a href=\"#19-Date\" class=\"headerlink\" title=\"19. Date\"></a>19. Date</h5><h5 id=\"20-RegExp\"><a href=\"#20-RegExp\" class=\"headerlink\" title=\"20. RegExp\"></a>20. RegExp</h5><h5 id=\"21-DOM\"><a href=\"#21-DOM\" class=\"headerlink\" title=\"21. DOM\"></a>21. DOM</h5><p>(1) DOM(Document object Model) 文档对象模型<br>(2) DOM事件<br>onload/onunload 进入或离开页面时触发<br>onchange<br>onmouseover<br>onmouseout<br>onmousedown<br>onmouseup<br>onclik</p>\n<p>(3) 事件绑定<br>addEventListener    // 事件绑定<br>removeEventListener // 解除事件绑定</p>\n<pre><code>element.addEventListener(&#39;click&#39;, function () &#123;\n    console.log(&#39;hello world&#39;)\n&#125;)\n</code></pre>\n<p>(4)事件冒泡和事件捕获<br>事件传递的方式有两种：事件冒泡或事件捕获<br>在冒泡中，内部元素的事件会先触发。然后再触发外部元素<br>在捕获中，外部元素的事件会被先触发，然后才会触发内部元素</p>\n<p>(5)向Window对象添加事件</p>\n<pre><code>window.addEvenetListener(&#39;resize&#39;, function () &#123;\n    ...\n&#125;)\n</code></pre>\n<h5 id=\"22-BOM\"><a href=\"#22-BOM\" class=\"headerlink\" title=\"22. BOM\"></a>22. BOM</h5><p>(1) BOM(Browser object Model) 浏览器对象模型 </p>\n<p>(2) window尺寸<br>window.innerHeight  浏览器窗口的内部高度(包括滚动条)<br>window.innerWidth - 浏览器窗口的内部宽度(包括滚动条)</p>\n<p>(3)window方法<br>window.open()   打开新窗口<br>window.close()  关闭当前窗口<br>window.moveTo() 移动当前窗口<br>window.resizeTo()  调整当前窗口的尺寸</p>\n<p>(4)</p>\n"},{"title":"koa使用介绍","date":"2021-10-29T06:27:04.000Z","_content":"1. koa简介\n   Koa 是一个新的 web 框架，通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理\n\n2. 安装\n\n```\nnpm install koa\n```\n\n3. Hello World\n\n```\nconst Koa = require('koa')\nconst app = new Koa()\n\napp.use(async ctx => {\n    ctx.body = 'Hello World'\n})\n\napp.listen(3000)\n```\n\n4. Context（上下文）\n\nKoa Context将node的request和response对象封装到单个对象中，为编写Web应用程序和API提供了许多有用的方法\n```\napp.use(async ctx => {\n    ctx // context\n    ctx.request // koa request\n    ctx.response    // koa response\n})\n```\n\n5. Request\n\nrequest.header  请求头对象\n\nresponse.method 请求方法\n\nrequest.search  使用 ? 获取原始查询字符串\n\nrequest.host    存在时获取主机（hostname:port）\n\nrequest.hostname    存在时获取主机名\n\nrequest.URL 获取 WHATWG 解析的 URL 对象\n\nrequest.type    获取请求 Content-Type, 不含 \"charset\" 等参数\n\nrequest.charset     存在时获取请求字符集，或者 undefined：\n\n\n\n6. Response","source":"_posts/koa使用介绍.md","raw":"---\ntitle: koa使用介绍\ndate: 2021-10-29 14:27:04\ntags:\n---\n1. koa简介\n   Koa 是一个新的 web 框架，通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理\n\n2. 安装\n\n```\nnpm install koa\n```\n\n3. Hello World\n\n```\nconst Koa = require('koa')\nconst app = new Koa()\n\napp.use(async ctx => {\n    ctx.body = 'Hello World'\n})\n\napp.listen(3000)\n```\n\n4. Context（上下文）\n\nKoa Context将node的request和response对象封装到单个对象中，为编写Web应用程序和API提供了许多有用的方法\n```\napp.use(async ctx => {\n    ctx // context\n    ctx.request // koa request\n    ctx.response    // koa response\n})\n```\n\n5. Request\n\nrequest.header  请求头对象\n\nresponse.method 请求方法\n\nrequest.search  使用 ? 获取原始查询字符串\n\nrequest.host    存在时获取主机（hostname:port）\n\nrequest.hostname    存在时获取主机名\n\nrequest.URL 获取 WHATWG 解析的 URL 对象\n\nrequest.type    获取请求 Content-Type, 不含 \"charset\" 等参数\n\nrequest.charset     存在时获取请求字符集，或者 undefined：\n\n\n\n6. Response","slug":"koa使用介绍","published":1,"updated":"2021-11-02T10:44:54.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwou9u5s000f9hwndbt6frdh","content":"<ol>\n<li><p>koa简介<br>Koa 是一个新的 web 框架，通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理</p>\n</li>\n<li><p>安装</p>\n</li>\n</ol>\n<pre><code>npm install koa\n</code></pre>\n<ol start=\"3\">\n<li>Hello World</li>\n</ol>\n<pre><code>const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\napp.use(async ctx =&gt; &#123;\n    ctx.body = &#39;Hello World&#39;\n&#125;)\n\napp.listen(3000)\n</code></pre>\n<ol start=\"4\">\n<li>Context（上下文）</li>\n</ol>\n<p>Koa Context将node的request和response对象封装到单个对象中，为编写Web应用程序和API提供了许多有用的方法</p>\n<pre><code>app.use(async ctx =&gt; &#123;\n    ctx // context\n    ctx.request // koa request\n    ctx.response    // koa response\n&#125;)\n</code></pre>\n<ol start=\"5\">\n<li>Request</li>\n</ol>\n<p>request.header  请求头对象</p>\n<p>response.method 请求方法</p>\n<p>request.search  使用 ? 获取原始查询字符串</p>\n<p>request.host    存在时获取主机（hostname:port）</p>\n<p>request.hostname    存在时获取主机名</p>\n<p>request.URL 获取 WHATWG 解析的 URL 对象</p>\n<p>request.type    获取请求 Content-Type, 不含 “charset” 等参数</p>\n<p>request.charset     存在时获取请求字符集，或者 undefined：</p>\n<ol start=\"6\">\n<li>Response</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>koa简介<br>Koa 是一个新的 web 框架，通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理</p>\n</li>\n<li><p>安装</p>\n</li>\n</ol>\n<pre><code>npm install koa\n</code></pre>\n<ol start=\"3\">\n<li>Hello World</li>\n</ol>\n<pre><code>const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\napp.use(async ctx =&gt; &#123;\n    ctx.body = &#39;Hello World&#39;\n&#125;)\n\napp.listen(3000)\n</code></pre>\n<ol start=\"4\">\n<li>Context（上下文）</li>\n</ol>\n<p>Koa Context将node的request和response对象封装到单个对象中，为编写Web应用程序和API提供了许多有用的方法</p>\n<pre><code>app.use(async ctx =&gt; &#123;\n    ctx // context\n    ctx.request // koa request\n    ctx.response    // koa response\n&#125;)\n</code></pre>\n<ol start=\"5\">\n<li>Request</li>\n</ol>\n<p>request.header  请求头对象</p>\n<p>response.method 请求方法</p>\n<p>request.search  使用 ? 获取原始查询字符串</p>\n<p>request.host    存在时获取主机（hostname:port）</p>\n<p>request.hostname    存在时获取主机名</p>\n<p>request.URL 获取 WHATWG 解析的 URL 对象</p>\n<p>request.type    获取请求 Content-Type, 不含 “charset” 等参数</p>\n<p>request.charset     存在时获取请求字符集，或者 undefined：</p>\n<ol start=\"6\">\n<li>Response</li>\n</ol>\n"},{"title":"react-hooks","date":"2021-10-30T03:19:40.000Z","_content":"\n1. useState\n\n2. useEffect\n\n3. useContext\n\n4. useRef\n\n5. useReducer\n\n6. useCallback\n","source":"_posts/react-hooks.md","raw":"---\ntitle: react-hooks\ndate: 2021-10-30 11:19:40\ntags:\n---\n\n1. useState\n\n2. useEffect\n\n3. useContext\n\n4. useRef\n\n5. useReducer\n\n6. useCallback\n","slug":"react-hooks","published":1,"updated":"2021-11-01T10:32:36.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwou9u5y000i9hwn36ikdm0g","content":"<ol>\n<li><p>useState</p>\n</li>\n<li><p>useEffect</p>\n</li>\n<li><p>useContext</p>\n</li>\n<li><p>useRef</p>\n</li>\n<li><p>useReducer</p>\n</li>\n<li><p>useCallback</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>useState</p>\n</li>\n<li><p>useEffect</p>\n</li>\n<li><p>useContext</p>\n</li>\n<li><p>useRef</p>\n</li>\n<li><p>useReducer</p>\n</li>\n<li><p>useCallback</p>\n</li>\n</ol>\n"},{"title":"react面试题","date":"2021-05-20T06:12:06.000Z","_content":"\n##### 1. React生命周期？\n1）componentWillMount   在渲染之前执行，在客户端和服务器端都会执行\n2) componentDidMount    仅在第一次渲染后在客户端执行\n3) componentWillReceiveProps()  当从父类接收到 props 并且在调用另一个渲染器之前调用\n4) shouldComponentUpdate()  根据特定条件返回 true 或 false。如果你希望更新组件，请返回true 否则返回 false。默认情况下，它返回 false\n5) componentWillUpdate()    在 DOM 中进行渲染之前调用\n6) componentDidUpdate() 在渲染发生后立即调用\n7) componentWillUnmount()   从 DOM 卸载组件后调用。用于清理内存空间","source":"_posts/react面试题.md","raw":"---\ntitle: react面试题\ndate: 2021-5-20 14:12:06\ntags:\n---\n\n##### 1. React生命周期？\n1）componentWillMount   在渲染之前执行，在客户端和服务器端都会执行\n2) componentDidMount    仅在第一次渲染后在客户端执行\n3) componentWillReceiveProps()  当从父类接收到 props 并且在调用另一个渲染器之前调用\n4) shouldComponentUpdate()  根据特定条件返回 true 或 false。如果你希望更新组件，请返回true 否则返回 false。默认情况下，它返回 false\n5) componentWillUpdate()    在 DOM 中进行渲染之前调用\n6) componentDidUpdate() 在渲染发生后立即调用\n7) componentWillUnmount()   从 DOM 卸载组件后调用。用于清理内存空间","slug":"react面试题","published":1,"updated":"2021-12-20T08:10:44.103Z","_id":"ckwou9u61000l9hwn5iw9bcsc","comments":1,"layout":"post","photos":[],"link":"","content":"<h5 id=\"1-React生命周期？\"><a href=\"#1-React生命周期？\" class=\"headerlink\" title=\"1. React生命周期？\"></a>1. React生命周期？</h5><p>1）componentWillMount   在渲染之前执行，在客户端和服务器端都会执行<br>2) componentDidMount    仅在第一次渲染后在客户端执行<br>3) componentWillReceiveProps()  当从父类接收到 props 并且在调用另一个渲染器之前调用<br>4) shouldComponentUpdate()  根据特定条件返回 true 或 false。如果你希望更新组件，请返回true 否则返回 false。默认情况下，它返回 false<br>5) componentWillUpdate()    在 DOM 中进行渲染之前调用<br>6) componentDidUpdate() 在渲染发生后立即调用<br>7) componentWillUnmount()   从 DOM 卸载组件后调用。用于清理内存空间</p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"1-React生命周期？\"><a href=\"#1-React生命周期？\" class=\"headerlink\" title=\"1. React生命周期？\"></a>1. React生命周期？</h5><p>1）componentWillMount   在渲染之前执行，在客户端和服务器端都会执行<br>2) componentDidMount    仅在第一次渲染后在客户端执行<br>3) componentWillReceiveProps()  当从父类接收到 props 并且在调用另一个渲染器之前调用<br>4) shouldComponentUpdate()  根据特定条件返回 true 或 false。如果你希望更新组件，请返回true 否则返回 false。默认情况下，它返回 false<br>5) componentWillUpdate()    在 DOM 中进行渲染之前调用<br>6) componentDidUpdate() 在渲染发生后立即调用<br>7) componentWillUnmount()   从 DOM 卸载组件后调用。用于清理内存空间</p>\n"},{"title":"vue面试题","date":"2021-01-10T05:56:59.000Z","_content":"\n##### 1.vue2.0生命周期有哪些？\n```\nbeforeCreate    组件创建，元素dom和数据还没有初始化\ncreated         数据data已经初始化完成，方法可以调用，但dom未渲染\nbeforeMount     dom未挂载，数据初始化已完成，但双向绑定还是显示{{}}\nmounted         dom完成挂载，一般数据请求放在这里，因为请求改变数据之后刚好渲染\nbeforeUpdate    页面数据改变了都会触发\nupdated         只要页面数据改变了都会触发，页面更新完毕\nbeforeDestory   组件销毁之前执行\ndestoryed       组件销毁\n```\n\n##### 2.v-model的实现原理？\nv-model在表单input、textarea、select等元素上创建双向数据绑定，v-model本质上是语法糖\n\n##### 3.vue响应式原理？\n数据劫持+观察者模式\n使用Object.defineProperty将属性进行劫持，数组则是通过重写数据来实现，当页面使用对应属性时，\n每个属性都拥有自己的dep属性，存在它所依赖的watcher(依赖收集)get，当属性变化后通知自己对应的watcher去更新(派发更新)set\n\n##### 4.$nextTick有什么作用？\n修改data的值后，需要立即获取dom元素的值，是获取不到的，因为vue是异步渲染的，\n需要通过$nextTick获取\n\n##### 5.v-if与v-show的区别？\n共同点：都能控制元素的显示和隐藏\n不同点：v-show的本质是利用display:none/block来控制元素的显示和隐藏\n       v-if是动态的向dom树添加或删除元素，v-if创建和删除相比v-show更消耗性能\n使用建议：如果需要频繁的切换元素建议使用v-show    \n\n##### 6.computed计算属性与methods的区别？\ncomputed计算属性有缓存的的功能，只有当指定数据变时，计算属性才会执行，否则否好原来的数据\nmethods没有缓存功能，每次渲染都会执行\n\n##### 7.keep-alive的作用？\nkeep-alive用来对组件进行缓存\n\n##### 8.组件通信的方法？\n1. props和$emit 父子组件通信\n2. $parent和$children  获取\n3. $attrs和$liteners A->B->C\n4. provide inject注入变量\n5. $refs获取组件实例\n6. EventBus兄弟组件传递数据\n7. vuex状态管理\n```\n// 父组件\n<template>\n    <child :name=\"childName\" :changeCount=\"getCount\" />\n</template>\n<script>\nimport Child from './Child'\nexport default {\n    components: {\n        Child\n    },\n    data () {\n        return {\n            childName: 'carr'\n        }\n    },\n    getCount (count) {\n        console.log(count)\n    }\n}\n</script>\n\n// 子组件\n<template>\n    <div>\n        <p>{{myName}}</p>\n        <button @click=\"changeName\">{{count}}</button>\n    </div>\n</template>\n<script>\nexport default {\n    // 父向子用props\n    props: {\n        myName: {\n            type: String,\n            default: ''\n        }\n    },\n    data () {\n        return {\n            count: 0\n        }\n    },\n    methods: {\n        changeName () {\n            this.count += 1\n            this.$emit('changeCount', this.count)\n        }\n    }\n}\n</script>\n```\n\n\n##### 9.什么是MVVM?\nM: 模型层\nVM: 视图模型\nV: 视图层\nVM通过数据绑定将后端传递的数据转化成页面，通过DOM事件监听的方式将页面转换为数据传给后端\n\n##### 10.遍历为什么要使用key？\nkey是为Vue中Vnode的唯一标识，通过这个key，我们的diff操作可以更准确、更快速\n\n##### 11.vue中的data为什么要是一个函数？\n组件的data写成一个函数，数据以函数返回值的形式定过，这样每复用一次组件，就会返回一份新的data，\n类似于给每个组件实例创建一个私有的数据空间，让每个组件实例维护各自的数据，单纯写成对象的形式，\n就使得所有组件实例共享一份data\n\n##### 12.v-if和v-for的优先级？\nv-for的优先级高于v-for\n\n##### 13.怎样理解vue单向数据流？\n数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行\n修改，这样会防止子组件意外改变父组件的状态，从而导致你的应用数据流向难以理解\n\n##### 14.computed和watch的区别及应用场景？\ncomputed是计算属性，依赖其它属性计算值，且computed的值有缓存\nwatch监听到值的变化会执行回调，在回调中可以进行一系列操作\n计算属性一般用载模板渲染中，某个值时依赖其它属性计算而来，watch适用于观测某个值的变化去完成\n一些复杂的业务逻辑\n\n##### 15.vue如何监测数组变化？\n基于性能原因，没有用defineProperty对数组每一项进行拦截，二十选择对7种数组方法进行重写\npush shift  pop splice  unshift sort  reverse\n\n##### 16.vue3有哪些变化？\n1. 响应式原理改变，vue3使用Proxy取代vue2版本的Object.defineProperty\n2. 新增了Composition API\n\n##### 17.虚拟DOM时什么？\n在浏览器中操作DOM是很昂贵的，频繁操作DOM，会产生一定的性能问题，虚拟DOM本质时用一个原生的JS对象\n去描述一个DOM节点，时对真实DOM的一层抽象\n\n##### 18.vue事件绑定原理？\n\n##### 19.vue父子组件生命周期钩子函数执行顺序\nVue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：\n\n加载渲染过程\n\n父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted\n\n子组件更新过程\n\n父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated\n\n父组件更新过程\n\n父 beforeUpdate -> 父 updated\n\n销毁过程\n\n父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed\n\n##### 20.\b动态绑定class和style\n```\n// 对象语法\n<div :class=\"{'active': isActive, 'text-danger': hasError}\"></div>\n\n// 数组语法\n<div :class=\"[isActive ? 'activeClass' : '', 'errorClass']\"></div>\n\n// 对象语法\n<div :style=\"{color: activeColor, fontSize: fontSize + 'px'}\"></div>\n\n// 数组语法\n<div :style=\"[styleColor, styleSize]\"></div>\n```\n","source":"_posts/vue面试题.md","raw":"---\ntitle: vue面试题\ndate: 2021-1-10 13:56:59\ntags:\n---\n\n##### 1.vue2.0生命周期有哪些？\n```\nbeforeCreate    组件创建，元素dom和数据还没有初始化\ncreated         数据data已经初始化完成，方法可以调用，但dom未渲染\nbeforeMount     dom未挂载，数据初始化已完成，但双向绑定还是显示{{}}\nmounted         dom完成挂载，一般数据请求放在这里，因为请求改变数据之后刚好渲染\nbeforeUpdate    页面数据改变了都会触发\nupdated         只要页面数据改变了都会触发，页面更新完毕\nbeforeDestory   组件销毁之前执行\ndestoryed       组件销毁\n```\n\n##### 2.v-model的实现原理？\nv-model在表单input、textarea、select等元素上创建双向数据绑定，v-model本质上是语法糖\n\n##### 3.vue响应式原理？\n数据劫持+观察者模式\n使用Object.defineProperty将属性进行劫持，数组则是通过重写数据来实现，当页面使用对应属性时，\n每个属性都拥有自己的dep属性，存在它所依赖的watcher(依赖收集)get，当属性变化后通知自己对应的watcher去更新(派发更新)set\n\n##### 4.$nextTick有什么作用？\n修改data的值后，需要立即获取dom元素的值，是获取不到的，因为vue是异步渲染的，\n需要通过$nextTick获取\n\n##### 5.v-if与v-show的区别？\n共同点：都能控制元素的显示和隐藏\n不同点：v-show的本质是利用display:none/block来控制元素的显示和隐藏\n       v-if是动态的向dom树添加或删除元素，v-if创建和删除相比v-show更消耗性能\n使用建议：如果需要频繁的切换元素建议使用v-show    \n\n##### 6.computed计算属性与methods的区别？\ncomputed计算属性有缓存的的功能，只有当指定数据变时，计算属性才会执行，否则否好原来的数据\nmethods没有缓存功能，每次渲染都会执行\n\n##### 7.keep-alive的作用？\nkeep-alive用来对组件进行缓存\n\n##### 8.组件通信的方法？\n1. props和$emit 父子组件通信\n2. $parent和$children  获取\n3. $attrs和$liteners A->B->C\n4. provide inject注入变量\n5. $refs获取组件实例\n6. EventBus兄弟组件传递数据\n7. vuex状态管理\n```\n// 父组件\n<template>\n    <child :name=\"childName\" :changeCount=\"getCount\" />\n</template>\n<script>\nimport Child from './Child'\nexport default {\n    components: {\n        Child\n    },\n    data () {\n        return {\n            childName: 'carr'\n        }\n    },\n    getCount (count) {\n        console.log(count)\n    }\n}\n</script>\n\n// 子组件\n<template>\n    <div>\n        <p>{{myName}}</p>\n        <button @click=\"changeName\">{{count}}</button>\n    </div>\n</template>\n<script>\nexport default {\n    // 父向子用props\n    props: {\n        myName: {\n            type: String,\n            default: ''\n        }\n    },\n    data () {\n        return {\n            count: 0\n        }\n    },\n    methods: {\n        changeName () {\n            this.count += 1\n            this.$emit('changeCount', this.count)\n        }\n    }\n}\n</script>\n```\n\n\n##### 9.什么是MVVM?\nM: 模型层\nVM: 视图模型\nV: 视图层\nVM通过数据绑定将后端传递的数据转化成页面，通过DOM事件监听的方式将页面转换为数据传给后端\n\n##### 10.遍历为什么要使用key？\nkey是为Vue中Vnode的唯一标识，通过这个key，我们的diff操作可以更准确、更快速\n\n##### 11.vue中的data为什么要是一个函数？\n组件的data写成一个函数，数据以函数返回值的形式定过，这样每复用一次组件，就会返回一份新的data，\n类似于给每个组件实例创建一个私有的数据空间，让每个组件实例维护各自的数据，单纯写成对象的形式，\n就使得所有组件实例共享一份data\n\n##### 12.v-if和v-for的优先级？\nv-for的优先级高于v-for\n\n##### 13.怎样理解vue单向数据流？\n数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行\n修改，这样会防止子组件意外改变父组件的状态，从而导致你的应用数据流向难以理解\n\n##### 14.computed和watch的区别及应用场景？\ncomputed是计算属性，依赖其它属性计算值，且computed的值有缓存\nwatch监听到值的变化会执行回调，在回调中可以进行一系列操作\n计算属性一般用载模板渲染中，某个值时依赖其它属性计算而来，watch适用于观测某个值的变化去完成\n一些复杂的业务逻辑\n\n##### 15.vue如何监测数组变化？\n基于性能原因，没有用defineProperty对数组每一项进行拦截，二十选择对7种数组方法进行重写\npush shift  pop splice  unshift sort  reverse\n\n##### 16.vue3有哪些变化？\n1. 响应式原理改变，vue3使用Proxy取代vue2版本的Object.defineProperty\n2. 新增了Composition API\n\n##### 17.虚拟DOM时什么？\n在浏览器中操作DOM是很昂贵的，频繁操作DOM，会产生一定的性能问题，虚拟DOM本质时用一个原生的JS对象\n去描述一个DOM节点，时对真实DOM的一层抽象\n\n##### 18.vue事件绑定原理？\n\n##### 19.vue父子组件生命周期钩子函数执行顺序\nVue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：\n\n加载渲染过程\n\n父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted\n\n子组件更新过程\n\n父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated\n\n父组件更新过程\n\n父 beforeUpdate -> 父 updated\n\n销毁过程\n\n父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed\n\n##### 20.\b动态绑定class和style\n```\n// 对象语法\n<div :class=\"{'active': isActive, 'text-danger': hasError}\"></div>\n\n// 数组语法\n<div :class=\"[isActive ? 'activeClass' : '', 'errorClass']\"></div>\n\n// 对象语法\n<div :style=\"{color: activeColor, fontSize: fontSize + 'px'}\"></div>\n\n// 数组语法\n<div :style=\"[styleColor, styleSize]\"></div>\n```\n","slug":"vue面试题","published":1,"updated":"2021-12-20T08:33:07.074Z","_id":"ckwou9u66000r9hwnbaau6vc2","comments":1,"layout":"post","photos":[],"link":"","content":"<h5 id=\"1-vue2-0生命周期有哪些？\"><a href=\"#1-vue2-0生命周期有哪些？\" class=\"headerlink\" title=\"1.vue2.0生命周期有哪些？\"></a>1.vue2.0生命周期有哪些？</h5><pre><code>beforeCreate    组件创建，元素dom和数据还没有初始化\ncreated         数据data已经初始化完成，方法可以调用，但dom未渲染\nbeforeMount     dom未挂载，数据初始化已完成，但双向绑定还是显示&#123;&#123;&#125;&#125;\nmounted         dom完成挂载，一般数据请求放在这里，因为请求改变数据之后刚好渲染\nbeforeUpdate    页面数据改变了都会触发\nupdated         只要页面数据改变了都会触发，页面更新完毕\nbeforeDestory   组件销毁之前执行\ndestoryed       组件销毁\n```\n\n##### 2.v-model的实现原理？\nv-model在表单input、textarea、select等元素上创建双向数据绑定，v-model本质上是语法糖\n\n##### 3.vue响应式原理？\n数据劫持+观察者模式\n使用Object.defineProperty将属性进行劫持，数组则是通过重写数据来实现，当页面使用对应属性时，\n每个属性都拥有自己的dep属性，存在它所依赖的watcher(依赖收集)get，当属性变化后通知自己对应的watcher去更新(派发更新)set\n\n##### 4.$nextTick有什么作用？\n修改data的值后，需要立即获取dom元素的值，是获取不到的，因为vue是异步渲染的，\n需要通过$nextTick获取\n\n##### 5.v-if与v-show的区别？\n共同点：都能控制元素的显示和隐藏\n不同点：v-show的本质是利用display:none/block来控制元素的显示和隐藏\n       v-if是动态的向dom树添加或删除元素，v-if创建和删除相比v-show更消耗性能\n使用建议：如果需要频繁的切换元素建议使用v-show    \n\n##### 6.computed计算属性与methods的区别？\ncomputed计算属性有缓存的的功能，只有当指定数据变时，计算属性才会执行，否则否好原来的数据\nmethods没有缓存功能，每次渲染都会执行\n\n##### 7.keep-alive的作用？\nkeep-alive用来对组件进行缓存\n\n##### 8.组件通信的方法？\n1. props和$emit 父子组件通信\n2. $parent和$children  获取\n3. $attrs和$liteners A->B->C\n4. provide inject注入变量\n5. $refs获取组件实例\n6. EventBus兄弟组件传递数据\n7. vuex状态管理\n```\n// 父组件\n<template>\n    <child :name=\"childName\" :changecount=\"getCount\">\n</child></template>\n<script>\nimport Child from './Child'\nexport default &#123;\n    components: &#123;\n        Child\n    &#125;,\n    data () &#123;\n        return &#123;\n            childName: 'carr'\n        &#125;\n    &#125;,\n    getCount (count) &#123;\n        console.log(count)\n    &#125;\n&#125;\n</script>\n\n// 子组件\n<template>\n    <div>\n        <p>&#123;&#123;myName&#125;&#125;&lt;/p&gt;\n        &lt;button @click=&quot;changeName&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default &#123;\n    // 父向子用props\n    props: &#123;\n        myName: &#123;\n            type: String,\n            default: &#39;&#39;\n        &#125;\n    &#125;,\n    data () &#123;\n        return &#123;\n            count: 0\n        &#125;\n    &#125;,\n    methods: &#123;\n        changeName () &#123;\n            this.count += 1\n            this.$emit(&#39;changeCount&#39;, this.count)\n        &#125;\n    &#125;\n&#125;\n&lt;/script&gt;\n</p></div></template></code></pre>\n<h5 id=\"9-什么是MVVM\"><a href=\"#9-什么是MVVM\" class=\"headerlink\" title=\"9.什么是MVVM?\"></a>9.什么是MVVM?</h5><p>M: 模型层<br>VM: 视图模型<br>V: 视图层<br>VM通过数据绑定将后端传递的数据转化成页面，通过DOM事件监听的方式将页面转换为数据传给后端</p>\n<h5 id=\"10-遍历为什么要使用key？\"><a href=\"#10-遍历为什么要使用key？\" class=\"headerlink\" title=\"10.遍历为什么要使用key？\"></a>10.遍历为什么要使用key？</h5><p>key是为Vue中Vnode的唯一标识，通过这个key，我们的diff操作可以更准确、更快速</p>\n<h5 id=\"11-vue中的data为什么要是一个函数？\"><a href=\"#11-vue中的data为什么要是一个函数？\" class=\"headerlink\" title=\"11.vue中的data为什么要是一个函数？\"></a>11.vue中的data为什么要是一个函数？</h5><p>组件的data写成一个函数，数据以函数返回值的形式定过，这样每复用一次组件，就会返回一份新的data，<br>类似于给每个组件实例创建一个私有的数据空间，让每个组件实例维护各自的数据，单纯写成对象的形式，<br>就使得所有组件实例共享一份data</p>\n<h5 id=\"12-v-if和v-for的优先级？\"><a href=\"#12-v-if和v-for的优先级？\" class=\"headerlink\" title=\"12.v-if和v-for的优先级？\"></a>12.v-if和v-for的优先级？</h5><p>v-for的优先级高于v-for</p>\n<h5 id=\"13-怎样理解vue单向数据流？\"><a href=\"#13-怎样理解vue单向数据流？\" class=\"headerlink\" title=\"13.怎样理解vue单向数据流？\"></a>13.怎样理解vue单向数据流？</h5><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行<br>修改，这样会防止子组件意外改变父组件的状态，从而导致你的应用数据流向难以理解</p>\n<h5 id=\"14-computed和watch的区别及应用场景？\"><a href=\"#14-computed和watch的区别及应用场景？\" class=\"headerlink\" title=\"14.computed和watch的区别及应用场景？\"></a>14.computed和watch的区别及应用场景？</h5><p>computed是计算属性，依赖其它属性计算值，且computed的值有缓存<br>watch监听到值的变化会执行回调，在回调中可以进行一系列操作<br>计算属性一般用载模板渲染中，某个值时依赖其它属性计算而来，watch适用于观测某个值的变化去完成<br>一些复杂的业务逻辑</p>\n<h5 id=\"15-vue如何监测数组变化？\"><a href=\"#15-vue如何监测数组变化？\" class=\"headerlink\" title=\"15.vue如何监测数组变化？\"></a>15.vue如何监测数组变化？</h5><p>基于性能原因，没有用defineProperty对数组每一项进行拦截，二十选择对7种数组方法进行重写<br>push shift  pop splice  unshift sort  reverse</p>\n<h5 id=\"16-vue3有哪些变化？\"><a href=\"#16-vue3有哪些变化？\" class=\"headerlink\" title=\"16.vue3有哪些变化？\"></a>16.vue3有哪些变化？</h5><ol>\n<li>响应式原理改变，vue3使用Proxy取代vue2版本的Object.defineProperty</li>\n<li>新增了Composition API</li>\n</ol>\n<h5 id=\"17-虚拟DOM时什么？\"><a href=\"#17-虚拟DOM时什么？\" class=\"headerlink\" title=\"17.虚拟DOM时什么？\"></a>17.虚拟DOM时什么？</h5><p>在浏览器中操作DOM是很昂贵的，频繁操作DOM，会产生一定的性能问题，虚拟DOM本质时用一个原生的JS对象<br>去描述一个DOM节点，时对真实DOM的一层抽象</p>\n<h5 id=\"18-vue事件绑定原理？\"><a href=\"#18-vue事件绑定原理？\" class=\"headerlink\" title=\"18.vue事件绑定原理？\"></a>18.vue事件绑定原理？</h5><h5 id=\"19-vue父子组件生命周期钩子函数执行顺序\"><a href=\"#19-vue父子组件生命周期钩子函数执行顺序\" class=\"headerlink\" title=\"19.vue父子组件生命周期钩子函数执行顺序\"></a>19.vue父子组件生命周期钩子函数执行顺序</h5><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>\n<p>加载渲染过程</p>\n<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>\n<p>子组件更新过程</p>\n<p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>\n<p>父组件更新过程</p>\n<p>父 beforeUpdate -&gt; 父 updated</p>\n<p>销毁过程</p>\n<p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>\n<h5 id=\"20-动态绑定class和style\"><a href=\"#20-动态绑定class和style\" class=\"headerlink\" title=\"20.\b动态绑定class和style\"></a>20.\b动态绑定class和style</h5><pre><code>// 对象语法\n&lt;div :class=&quot;&#123;&#39;active&#39;: isActive, &#39;text-danger&#39;: hasError&#125;&quot;&gt;&lt;/div&gt;\n\n// 数组语法\n&lt;div :class=&quot;[isActive ? &#39;activeClass&#39; : &#39;&#39;, &#39;errorClass&#39;]&quot;&gt;&lt;/div&gt;\n\n// 对象语法\n&lt;div :style=&quot;&#123;color: activeColor, fontSize: fontSize + &#39;px&#39;&#125;&quot;&gt;&lt;/div&gt;\n\n// 数组语法\n&lt;div :style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"1-vue2-0生命周期有哪些？\"><a href=\"#1-vue2-0生命周期有哪些？\" class=\"headerlink\" title=\"1.vue2.0生命周期有哪些？\"></a>1.vue2.0生命周期有哪些？</h5><pre><code>beforeCreate    组件创建，元素dom和数据还没有初始化\ncreated         数据data已经初始化完成，方法可以调用，但dom未渲染\nbeforeMount     dom未挂载，数据初始化已完成，但双向绑定还是显示&#123;&#123;&#125;&#125;\nmounted         dom完成挂载，一般数据请求放在这里，因为请求改变数据之后刚好渲染\nbeforeUpdate    页面数据改变了都会触发\nupdated         只要页面数据改变了都会触发，页面更新完毕\nbeforeDestory   组件销毁之前执行\ndestoryed       组件销毁\n```\n\n##### 2.v-model的实现原理？\nv-model在表单input、textarea、select等元素上创建双向数据绑定，v-model本质上是语法糖\n\n##### 3.vue响应式原理？\n数据劫持+观察者模式\n使用Object.defineProperty将属性进行劫持，数组则是通过重写数据来实现，当页面使用对应属性时，\n每个属性都拥有自己的dep属性，存在它所依赖的watcher(依赖收集)get，当属性变化后通知自己对应的watcher去更新(派发更新)set\n\n##### 4.$nextTick有什么作用？\n修改data的值后，需要立即获取dom元素的值，是获取不到的，因为vue是异步渲染的，\n需要通过$nextTick获取\n\n##### 5.v-if与v-show的区别？\n共同点：都能控制元素的显示和隐藏\n不同点：v-show的本质是利用display:none/block来控制元素的显示和隐藏\n       v-if是动态的向dom树添加或删除元素，v-if创建和删除相比v-show更消耗性能\n使用建议：如果需要频繁的切换元素建议使用v-show    \n\n##### 6.computed计算属性与methods的区别？\ncomputed计算属性有缓存的的功能，只有当指定数据变时，计算属性才会执行，否则否好原来的数据\nmethods没有缓存功能，每次渲染都会执行\n\n##### 7.keep-alive的作用？\nkeep-alive用来对组件进行缓存\n\n##### 8.组件通信的方法？\n1. props和$emit 父子组件通信\n2. $parent和$children  获取\n3. $attrs和$liteners A->B->C\n4. provide inject注入变量\n5. $refs获取组件实例\n6. EventBus兄弟组件传递数据\n7. vuex状态管理\n```\n// 父组件\n<template>\n    <child :name=\"childName\" :changecount=\"getCount\">\n</child></template>\n<script>\nimport Child from './Child'\nexport default &#123;\n    components: &#123;\n        Child\n    &#125;,\n    data () &#123;\n        return &#123;\n            childName: 'carr'\n        &#125;\n    &#125;,\n    getCount (count) &#123;\n        console.log(count)\n    &#125;\n&#125;\n</script>\n\n// 子组件\n<template>\n    <div>\n        <p>&#123;&#123;myName&#125;&#125;&lt;/p&gt;\n        &lt;button @click=&quot;changeName&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default &#123;\n    // 父向子用props\n    props: &#123;\n        myName: &#123;\n            type: String,\n            default: &#39;&#39;\n        &#125;\n    &#125;,\n    data () &#123;\n        return &#123;\n            count: 0\n        &#125;\n    &#125;,\n    methods: &#123;\n        changeName () &#123;\n            this.count += 1\n            this.$emit(&#39;changeCount&#39;, this.count)\n        &#125;\n    &#125;\n&#125;\n&lt;/script&gt;\n</p></div></template></code></pre>\n<h5 id=\"9-什么是MVVM\"><a href=\"#9-什么是MVVM\" class=\"headerlink\" title=\"9.什么是MVVM?\"></a>9.什么是MVVM?</h5><p>M: 模型层<br>VM: 视图模型<br>V: 视图层<br>VM通过数据绑定将后端传递的数据转化成页面，通过DOM事件监听的方式将页面转换为数据传给后端</p>\n<h5 id=\"10-遍历为什么要使用key？\"><a href=\"#10-遍历为什么要使用key？\" class=\"headerlink\" title=\"10.遍历为什么要使用key？\"></a>10.遍历为什么要使用key？</h5><p>key是为Vue中Vnode的唯一标识，通过这个key，我们的diff操作可以更准确、更快速</p>\n<h5 id=\"11-vue中的data为什么要是一个函数？\"><a href=\"#11-vue中的data为什么要是一个函数？\" class=\"headerlink\" title=\"11.vue中的data为什么要是一个函数？\"></a>11.vue中的data为什么要是一个函数？</h5><p>组件的data写成一个函数，数据以函数返回值的形式定过，这样每复用一次组件，就会返回一份新的data，<br>类似于给每个组件实例创建一个私有的数据空间，让每个组件实例维护各自的数据，单纯写成对象的形式，<br>就使得所有组件实例共享一份data</p>\n<h5 id=\"12-v-if和v-for的优先级？\"><a href=\"#12-v-if和v-for的优先级？\" class=\"headerlink\" title=\"12.v-if和v-for的优先级？\"></a>12.v-if和v-for的优先级？</h5><p>v-for的优先级高于v-for</p>\n<h5 id=\"13-怎样理解vue单向数据流？\"><a href=\"#13-怎样理解vue单向数据流？\" class=\"headerlink\" title=\"13.怎样理解vue单向数据流？\"></a>13.怎样理解vue单向数据流？</h5><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行<br>修改，这样会防止子组件意外改变父组件的状态，从而导致你的应用数据流向难以理解</p>\n<h5 id=\"14-computed和watch的区别及应用场景？\"><a href=\"#14-computed和watch的区别及应用场景？\" class=\"headerlink\" title=\"14.computed和watch的区别及应用场景？\"></a>14.computed和watch的区别及应用场景？</h5><p>computed是计算属性，依赖其它属性计算值，且computed的值有缓存<br>watch监听到值的变化会执行回调，在回调中可以进行一系列操作<br>计算属性一般用载模板渲染中，某个值时依赖其它属性计算而来，watch适用于观测某个值的变化去完成<br>一些复杂的业务逻辑</p>\n<h5 id=\"15-vue如何监测数组变化？\"><a href=\"#15-vue如何监测数组变化？\" class=\"headerlink\" title=\"15.vue如何监测数组变化？\"></a>15.vue如何监测数组变化？</h5><p>基于性能原因，没有用defineProperty对数组每一项进行拦截，二十选择对7种数组方法进行重写<br>push shift  pop splice  unshift sort  reverse</p>\n<h5 id=\"16-vue3有哪些变化？\"><a href=\"#16-vue3有哪些变化？\" class=\"headerlink\" title=\"16.vue3有哪些变化？\"></a>16.vue3有哪些变化？</h5><ol>\n<li>响应式原理改变，vue3使用Proxy取代vue2版本的Object.defineProperty</li>\n<li>新增了Composition API</li>\n</ol>\n<h5 id=\"17-虚拟DOM时什么？\"><a href=\"#17-虚拟DOM时什么？\" class=\"headerlink\" title=\"17.虚拟DOM时什么？\"></a>17.虚拟DOM时什么？</h5><p>在浏览器中操作DOM是很昂贵的，频繁操作DOM，会产生一定的性能问题，虚拟DOM本质时用一个原生的JS对象<br>去描述一个DOM节点，时对真实DOM的一层抽象</p>\n<h5 id=\"18-vue事件绑定原理？\"><a href=\"#18-vue事件绑定原理？\" class=\"headerlink\" title=\"18.vue事件绑定原理？\"></a>18.vue事件绑定原理？</h5><h5 id=\"19-vue父子组件生命周期钩子函数执行顺序\"><a href=\"#19-vue父子组件生命周期钩子函数执行顺序\" class=\"headerlink\" title=\"19.vue父子组件生命周期钩子函数执行顺序\"></a>19.vue父子组件生命周期钩子函数执行顺序</h5><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>\n<p>加载渲染过程</p>\n<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>\n<p>子组件更新过程</p>\n<p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>\n<p>父组件更新过程</p>\n<p>父 beforeUpdate -&gt; 父 updated</p>\n<p>销毁过程</p>\n<p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>\n<h5 id=\"20-动态绑定class和style\"><a href=\"#20-动态绑定class和style\" class=\"headerlink\" title=\"20.\b动态绑定class和style\"></a>20.\b动态绑定class和style</h5><pre><code>// 对象语法\n&lt;div :class=&quot;&#123;&#39;active&#39;: isActive, &#39;text-danger&#39;: hasError&#125;&quot;&gt;&lt;/div&gt;\n\n// 数组语法\n&lt;div :class=&quot;[isActive ? &#39;activeClass&#39; : &#39;&#39;, &#39;errorClass&#39;]&quot;&gt;&lt;/div&gt;\n\n// 对象语法\n&lt;div :style=&quot;&#123;color: activeColor, fontSize: fontSize + &#39;px&#39;&#125;&quot;&gt;&lt;/div&gt;\n\n// 数组语法\n&lt;div :style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;\n</code></pre>\n"},{"title":"前端综合面试题","date":"2021-10-29T08:14:14.000Z","_content":"\n##### 1. 从输入URL地址到页面渲染的过程？\n（1）DNS域名解析\n（2）根据IP向服务器发请求\n（3）服务器处理http请求，返回结果\n（4）根据HTML生成DOM Tree\n（5）根据CSS生成CSS DOM\n（6）DOM Tree和CSS DOM整合成Render Tree\n（7）根据Render Tree渲染页面\n\n##### 2. 什么是重绘与回流？\n\n\n##### 3. 浏览器缓存？\n（1）协商缓存\n\n（2）强制缓存\n\n\n##### 4. 同源策略是什么？\n协议、域名、端口三者相同\n\n##### 5. 举例几种跨越的方法？\n（1）jsonp\n（2）cors\n\n##### 6. 优化网页的几个方向？\n（1）减少网络请求\n    - 合并文件\n    - 使用本地缓存\n（2）减小资源体积\n    - html、css、js、图片压缩\n    - 开启gzip\n（3）使用CDN\n（4）预加载\n（5）懒加载\n\n\n##### 7. 谈一谈XSS攻击\n（1）什么时XSS\nXSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击\n\n（2）原理\n恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的\n\n（3）XSS分类\n- 反射型XSS\n反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行\n\n- 存储型XSS\n主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码\n\n- DOM-based型XSS\n\n\n##### 8. 谈一谈CSRF攻击\n（1）什么是CSRF?\nCSRF（Cross-site request forgery），中文名称：跨站请求伪造\n\n（2）CSRF危害？\n你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全\n\n（3）原理\n![csrf原理](csrf.jpeg)\n要完成一次CSRF攻击，受害者必须完成两个步骤：\n- 登录受信任网站A，并在本地生成Cookie\n- 在不登出A的情况下，访问危险网站B\n\n（4）防御\n- Cookie Hashing(所有表单都包含同一个伪随机值)\n- 验证码\n- One-Time Tokens(不同的表单包含一个不同的伪随机值)\n- ","source":"_posts/前端综合面试题.md","raw":"---\ntitle: 前端综合面试题\ndate: 2021-10-29 16:14:14\ntags:\n---\n\n##### 1. 从输入URL地址到页面渲染的过程？\n（1）DNS域名解析\n（2）根据IP向服务器发请求\n（3）服务器处理http请求，返回结果\n（4）根据HTML生成DOM Tree\n（5）根据CSS生成CSS DOM\n（6）DOM Tree和CSS DOM整合成Render Tree\n（7）根据Render Tree渲染页面\n\n##### 2. 什么是重绘与回流？\n\n\n##### 3. 浏览器缓存？\n（1）协商缓存\n\n（2）强制缓存\n\n\n##### 4. 同源策略是什么？\n协议、域名、端口三者相同\n\n##### 5. 举例几种跨越的方法？\n（1）jsonp\n（2）cors\n\n##### 6. 优化网页的几个方向？\n（1）减少网络请求\n    - 合并文件\n    - 使用本地缓存\n（2）减小资源体积\n    - html、css、js、图片压缩\n    - 开启gzip\n（3）使用CDN\n（4）预加载\n（5）懒加载\n\n\n##### 7. 谈一谈XSS攻击\n（1）什么时XSS\nXSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击\n\n（2）原理\n恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的\n\n（3）XSS分类\n- 反射型XSS\n反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行\n\n- 存储型XSS\n主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码\n\n- DOM-based型XSS\n\n\n##### 8. 谈一谈CSRF攻击\n（1）什么是CSRF?\nCSRF（Cross-site request forgery），中文名称：跨站请求伪造\n\n（2）CSRF危害？\n你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全\n\n（3）原理\n![csrf原理](csrf.jpeg)\n要完成一次CSRF攻击，受害者必须完成两个步骤：\n- 登录受信任网站A，并在本地生成Cookie\n- 在不登出A的情况下，访问危险网站B\n\n（4）防御\n- Cookie Hashing(所有表单都包含同一个伪随机值)\n- 验证码\n- One-Time Tokens(不同的表单包含一个不同的伪随机值)\n- ","slug":"前端综合面试题","published":1,"updated":"2021-11-20T01:50:59.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwou9u67000t9hwn0lwbbhk9","content":"\n        <h5 id=\"1-从输入URL地址到页面渲染的过程？\">\n          <a href=\"#1-从输入URL地址到页面渲染的过程？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-从输入URL地址到页面渲染的过程？\" class=\"headerlink\" title=\"1. 从输入URL地址到页面渲染的过程？\"></a>1. 从输入URL地址到页面渲染的过程？</h5>\n      <p>（1）DNS域名解析<br>（2）根据IP向服务器发请求<br>（3）服务器处理http请求，返回结果<br>（4）根据HTML生成DOM Tree<br>（5）根据CSS生成CSS DOM<br>（6）DOM Tree和CSS DOM整合成Render Tree<br>（7）根据Render Tree渲染页面</p>\n\n        <h5 id=\"2-什么是重绘与回流？\">\n          <a href=\"#2-什么是重绘与回流？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-什么是重绘与回流？\" class=\"headerlink\" title=\"2. 什么是重绘与回流？\"></a>2. 什么是重绘与回流？</h5>\n      \n        <h5 id=\"3-浏览器缓存？\">\n          <a href=\"#3-浏览器缓存？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-浏览器缓存？\" class=\"headerlink\" title=\"3. 浏览器缓存？\"></a>3. 浏览器缓存？</h5>\n      <p>（1）协商缓存</p>\n<p>（2）强制缓存</p>\n\n        <h5 id=\"4-同源策略是什么？\">\n          <a href=\"#4-同源策略是什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-同源策略是什么？\" class=\"headerlink\" title=\"4. 同源策略是什么？\"></a>4. 同源策略是什么？</h5>\n      <p>协议、域名、端口三者相同</p>\n\n        <h5 id=\"5-举例几种跨越的方法？\">\n          <a href=\"#5-举例几种跨越的方法？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-举例几种跨越的方法？\" class=\"headerlink\" title=\"5. 举例几种跨越的方法？\"></a>5. 举例几种跨越的方法？</h5>\n      <p>（1）jsonp<br>（2）cors</p>\n\n        <h5 id=\"6-优化网页的几个方向？\">\n          <a href=\"#6-优化网页的几个方向？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-优化网页的几个方向？\" class=\"headerlink\" title=\"6. 优化网页的几个方向？\"></a>6. 优化网页的几个方向？</h5>\n      <p>（1）减少网络请求<br>    - 合并文件<br>    - 使用本地缓存<br>（2）减小资源体积<br>    - html、css、js、图片压缩<br>    - 开启gzip<br>（3）使用CDN<br>（4）预加载<br>（5）懒加载</p>\n\n        <h5 id=\"7-谈一谈XSS攻击\">\n          <a href=\"#7-谈一谈XSS攻击\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-谈一谈XSS攻击\" class=\"headerlink\" title=\"7. 谈一谈XSS攻击\"></a>7. 谈一谈XSS攻击</h5>\n      <p>（1）什么时XSS<br>XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击</p>\n<p>（2）原理<br>恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的</p>\n<p>（3）XSS分类</p>\n<ul>\n<li><p>反射型XSS<br>反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行</p>\n</li>\n<li><p>存储型XSS<br>主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码</p>\n</li>\n<li><p>DOM-based型XSS</p>\n</li>\n</ul>\n\n        <h5 id=\"8-谈一谈CSRF攻击\">\n          <a href=\"#8-谈一谈CSRF攻击\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-谈一谈CSRF攻击\" class=\"headerlink\" title=\"8. 谈一谈CSRF攻击\"></a>8. 谈一谈CSRF攻击</h5>\n      <p>（1）什么是CSRF?<br>CSRF（Cross-site request forgery），中文名称：跨站请求伪造</p>\n<p>（2）CSRF危害？<br>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全</p>\n<p>（3）原理<br><img src=\"/2021/10/29/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/csrf.jpeg\" alt=\"csrf原理\"><br>要完成一次CSRF攻击，受害者必须完成两个步骤：</p>\n<ul>\n<li>登录受信任网站A，并在本地生成Cookie</li>\n<li>在不登出A的情况下，访问危险网站B</li>\n</ul>\n<p>（4）防御</p>\n<ul>\n<li>Cookie Hashing(所有表单都包含同一个伪随机值)</li>\n<li>验证码</li>\n<li>One-Time Tokens(不同的表单包含一个不同的伪随机值)</li>\n<li></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"\n        <h5 id=\"1-从输入URL地址到页面渲染的过程？\">\n          <a href=\"#1-从输入URL地址到页面渲染的过程？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-从输入URL地址到页面渲染的过程？\" class=\"headerlink\" title=\"1. 从输入URL地址到页面渲染的过程？\"></a>1. 从输入URL地址到页面渲染的过程？</h5>\n      <p>（1）DNS域名解析<br>（2）根据IP向服务器发请求<br>（3）服务器处理http请求，返回结果<br>（4）根据HTML生成DOM Tree<br>（5）根据CSS生成CSS DOM<br>（6）DOM Tree和CSS DOM整合成Render Tree<br>（7）根据Render Tree渲染页面</p>\n\n        <h5 id=\"2-什么是重绘与回流？\">\n          <a href=\"#2-什么是重绘与回流？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-什么是重绘与回流？\" class=\"headerlink\" title=\"2. 什么是重绘与回流？\"></a>2. 什么是重绘与回流？</h5>\n      \n        <h5 id=\"3-浏览器缓存？\">\n          <a href=\"#3-浏览器缓存？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-浏览器缓存？\" class=\"headerlink\" title=\"3. 浏览器缓存？\"></a>3. 浏览器缓存？</h5>\n      <p>（1）协商缓存</p>\n<p>（2）强制缓存</p>\n\n        <h5 id=\"4-同源策略是什么？\">\n          <a href=\"#4-同源策略是什么？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-同源策略是什么？\" class=\"headerlink\" title=\"4. 同源策略是什么？\"></a>4. 同源策略是什么？</h5>\n      <p>协议、域名、端口三者相同</p>\n\n        <h5 id=\"5-举例几种跨越的方法？\">\n          <a href=\"#5-举例几种跨越的方法？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-举例几种跨越的方法？\" class=\"headerlink\" title=\"5. 举例几种跨越的方法？\"></a>5. 举例几种跨越的方法？</h5>\n      <p>（1）jsonp<br>（2）cors</p>\n\n        <h5 id=\"6-优化网页的几个方向？\">\n          <a href=\"#6-优化网页的几个方向？\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-优化网页的几个方向？\" class=\"headerlink\" title=\"6. 优化网页的几个方向？\"></a>6. 优化网页的几个方向？</h5>\n      <p>（1）减少网络请求<br>    - 合并文件<br>    - 使用本地缓存<br>（2）减小资源体积<br>    - html、css、js、图片压缩<br>    - 开启gzip<br>（3）使用CDN<br>（4）预加载<br>（5）懒加载</p>\n\n        <h5 id=\"7-谈一谈XSS攻击\">\n          <a href=\"#7-谈一谈XSS攻击\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-谈一谈XSS攻击\" class=\"headerlink\" title=\"7. 谈一谈XSS攻击\"></a>7. 谈一谈XSS攻击</h5>\n      <p>（1）什么时XSS<br>XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击</p>\n<p>（2）原理<br>恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的</p>\n<p>（3）XSS分类</p>\n<ul>\n<li><p>反射型XSS<br>反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行</p>\n</li>\n<li><p>存储型XSS<br>主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码</p>\n</li>\n<li><p>DOM-based型XSS</p>\n</li>\n</ul>\n\n        <h5 id=\"8-谈一谈CSRF攻击\">\n          <a href=\"#8-谈一谈CSRF攻击\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-谈一谈CSRF攻击\" class=\"headerlink\" title=\"8. 谈一谈CSRF攻击\"></a>8. 谈一谈CSRF攻击</h5>\n      <p>（1）什么是CSRF?<br>CSRF（Cross-site request forgery），中文名称：跨站请求伪造</p>\n<p>（2）CSRF危害？<br>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全</p>\n<p>（3）原理<br><img src=\"/2021/10/29/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/csrf.jpeg\" alt=\"csrf原理\"><br>要完成一次CSRF攻击，受害者必须完成两个步骤：</p>\n<ul>\n<li>登录受信任网站A，并在本地生成Cookie</li>\n<li>在不登出A的情况下，访问危险网站B</li>\n</ul>\n<p>（4）防御</p>\n<ul>\n<li>Cookie Hashing(所有表单都包含同一个伪随机值)</li>\n<li>验证码</li>\n<li>One-Time Tokens(不同的表单包含一个不同的伪随机值)</li>\n<li></li>\n</ul>\n"},{"title":"vue后台管理系统","date":"2021-10-29T06:16:48.000Z","_content":"\n##### 1. 功能模块\n（1）客户管理\n    - 仪表盘\n    - 待办事项\n    - 线索\n    - 客户\n    - 联系人\n    - 商机\n    - 合同\n    - 回款\n    - 发票\n    - 产品\n    - 市场活动\n（2）人力资源\n（3）日志\n（4）项目管理\n（5）任务审批\n\n##### 2. 技术栈\nvue@2.x\nvue-cli@3.x\nvue-router\nvuex\naxios\nelement-ui\n\n##### 3. 搭建开发环境\n(1) 安装node\n(2) 安装vue-cli\n\n```\nnpm install vue-cli -g\n```\n\n##### 4. 项目初始化\n```\nvue create crm\n```\n\n##### 5. github管理代码\n（1）github上创建远程代码仓库\n\n\n##### 6. 项目规划\n|- api\n|- assets\n|- components\n    |- CreateView.vue   // 新建页面通用组件\n|- directives\n|- filters\n|- router\n|- store\n|- styles\n|- utils\n|- views\n    |- CustomerManagement\n        |- components\n            |- CrmListHead.vue // 客户管理通用页头\n        |- customer\n            |- CustomerIndex.vue\n|- App.vue\n|- main.js\n|- permission.js\n\n##### 6. axios封装\n\n```\nimport axios from 'axios'\n\nconst service = axios.create({\n    baseURL: process.env.BASE_API,\n    timeout: 15000\n})\n\nservice.interceptors.request.use(config => {\n\n})\n\nservice.interceptors.response.use(response => {\n\n})\n\nexport default service\n```\n\n##### 7. 请求API\n\napi/user.js\n\n```\nimport request from '@/utils/request'\n\nexport default login (username, password) {\n    return request({\n        url: '/login',\n        data: {\n            username,\n            password\n        }\n    })\n}\n```\n\n##### 8. 公共模块封装\n（1）新建页面组件\n\n```\n<template>\n    <transition name=\"opacity-fade\">\n        <div \n            class=\"c-view\"\n            :style=\"{'background-color': backgroundColor, 'padding': padding}\"\n        >\n            <el-card\n                v-loading=\"loading\"\n                :style=\"{'width': width}\"\n            >\n                <slot name=\"header\" />\n                <slot />\n            </el-card>\n        </div>\n    </transition>\n</template>\n<script>\nexport default {\n    name: 'CreateView',\n    props: {\n        borderStyle: {\n            type: Object,\n            default: () => {\n                return {}\n            }\n        },\n        loading: {\n            type: Boolean,\n            default: false\n        },\n        width: {\n            type: String,\n            default: '700px'\n        },\n        backgroundColor: {\n            type: String,\n            default: '#F5F6F9' // rgba(0, 0, 0, 0.6) 黑色半透明\n        },\n        /** 展示内容的上下padding **/\n        padding: {\n            type: String,\n            default: '40px'\n        }\n    },\n    data () {\n        return {\n            \n        }\n    }\n}\n</script>\n<style lang=\"scss\" scoped>\n.opacity-fade-enter,\n.opacity-fade-leave-active{\n    transition: all 0.2s;\n}\n.opacity-fade-enter,\n.opacity-fade-leave-to{\n    opacity: 0;\n}\n</style>\n```\n\n##### 7. 状态管理\n- store/index.js\n\n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport getters from './getters'\nimport customer from './modules/customer'\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store({\n    modules: {\n        app,\n        customer\n    },\n    getters\n})\n\nexport default store\n```\n\n- store/getters.js\n\n```\nconst getters = {\n    crm: state => state.user.crm\n}\n\nexport default getters\n```\n\n- store/modules/user.js\n\n```\nimport { login, logout } from '@/api/login'\nconst app = {\n    state: {\n        crm: {},    // 客户管理\n    },\n    mutations: {\n        SET_CRM: (state, crm) => {\n            state.crm = crm\n        }\n    },\n    actions: {\n        Login({commit}, userInfo){\n            return new Promise((resolve, reject) => {\n                login(username, userInfo.password).then(data => {\n                    commit('SET_CRM', data.auth.crm)\n                }).catch(error => {\n                    reject(error)\n                })\n            })\n        }\n    }\n}\nexport default app\n```\n\n##### 6. 客户模块\n（1）\n\n（2）分析页面，筛选通用部分，封装成公共组件\n- 页头部分公用组件封装\nCrmListHead\n```\n<template>\n    <div class=\"container\">\n        <div>{{title}}</div>\n        <el-input \n            placeholder=\"placeholder\"\n            @input=\"inputChange\"\n            v-model=\"inputContent\">\n            <el-button \n                icon=\"el-icon-search\"\n                @click.native=\"searchInput\" />\n        </el-input>  \n        <div class=\"right-container\">\n            <el-button \n                v-if=\"cansave\"\n                type=\"primary\"\n                @click=\"createClick\"\n            >{{mainTitle}}</el-button>\n            <el-dropdowm\n                v-if=\"moreTypes.length > 0\"\n                trigger=\"click\"\n                @command=\"handleTypeDrop\"\n            >\n                <el-dropdown-menu slot=\"dropdown\">\n                    <el-dropwdown-item\n                        v-for=\"(item, index) in moreTypes\"\n                        :key=\"index\"\n                    >\n                        {{iitem.name}}\n                    </el-dropdowm>\n                </el-dropdown-menu>\n            <el-dropdown>\n        </div>\n        <crm-create-view \n            v-if=\"isCreate\"\n            :crmType=\"\"\n        />\n    </div>\n</template>\n\n<script>\nimport { mapGetters } from 'vuex'\nimport CrmCreateView from '@/components/CrmCreateView'\nexport default {\n    name: 'CrmListHead',\n    components: {\n        CrmCreateView\n    },\n    data () {\n        return {\n            inputContent: '',\n            moreTypes: []\n        }\n    },\n    props: {\n        // 页头主标题\n        title: {\n            type: String,\n            default: '\n        },\n        placeholder: {\n            type: String,\n            default: '请输入内容'\n        },\n        // 页头按钮文字\n        mainTitle: {\n            type: String,\n            default: ''\n        },\n        crmType: {\n            type: String,\n            default: ''\n        },\n        isSeas: {\n            type: Boolean,\n            default: false\n        }\n    },\n    computed: {\n        ...mapGetters(['crm']),\n        canSave () {\n\n        }\n    },\n    mounted () {\n        // 线索和客户判断更多操作\n        if (!this.isSeas) {\n            if (this.crm[this.crmType].excelimport) {\n                this.moreTypes.push({type: 'enter', name: '导入'})\n            }\n            if (this.crm[this.crmType].excelexport) {\n                this.moreTypes.push({type: 'out', name: '导出'})\n            }\n        } else {\n             // 客户池的导出关键字不同\n            if (this.crm.pool.excelexport) {\n                this.moreTypes.push({ type: 'out', name: '导出' })\n            }\n        }\n    },\n    methods: {\n        // 下拉菜单点击\n        handleTypeDrop(command, param = {}) {\n            if (command === 'out') {\n\n            } else if (command === 'enter') {\n\n            }\n        }\n        inputChange() {\n            this.$emit('update:search', this.inputContent)\n        },\n        searchInput () {\n            this.$emit('on-search', this.inputContent)\n        },\n        // 新建按钮\n        createClick () {\n\n        }\n    }\n}\n</script>\n```\n\n（2）mixins\n\nmixin/table.js\n\n```\nimport {\n    crmCustomerIndex\n} from '@/api/customerManagment/customer'\nexport default {\n    components: {\n        CrmListHead,\n    },\n    data () {\n        return {\n            loading: false, // 是否加载中\n            list: [],   // 表格数据\n            search: ''  // 搜索内容\n            fieldList: [],  // 表格字段\n            currentPage: 1, // 当前页面\n            total: 0,   // 总页数\n            pageSize: [15, 30, 60, 100],    \n            selectList: [], // 选中的数据\n        }\n    },\n    computed: {\n        ...mapGetters(['crm'])\n    },\n    mounted () {\n        // 控制table的高度\n        window.resize = () => {\n            this.updateTableHeight()\n        }\n    },\n    methods: {\n        // 获取数据\n        getList () {\n            this.loading = true\n            var crmIndexRequest = this.getIndexRequest()\n            // API请求参数\n            var params = {\n                page: this.currentPage,\n                limit: this.pageSize,\n                search: this.search,\n                type: this.isSeas ? crmTypeModel.pool : crmTypeModel[this.crmType]\n            }\n            // 执行请求\n            crmIndexRequest(params).then(res => {\n                if () {\n\n                } else {\n                    this.list = res.data.list\n                }\n                this.total = res.data.totalRow\n                this.loading = false\n            }).catch(() =>  {\n                this.loading = false\n            })\n        },\n        // 判断当前页面要执行的API请求\n        getIndexRequest () {\n            if (this.crmType === 'leads') {\n                return crmLeadsIndex\n            } else if (this.crmType === 'customer') {\n                if (this.isSeas) {\n                    return crmCustomerPool\n                } else {\n                    return crmCustomerIndex\n                }\n            } else if (this.crmType === 'contacts') {\n                return crmContactsIndex\n            } else if (this.crmType === 'business') {\n                return crmBusinessIndex\n            } else if (this.crmType === 'product') {\n                return crmProductIndex\n            }\n        },\n        // 搜索\n        crmSearch (value) {\n\n        }\n        // 获取表格字段\n        getFieldList () {\n            \n        }\n    }\n}\n```\n\n（3）客户管理页面\n\nCustomerIndex.vue\n\n```\n<template>\n    <crm-list-head \n        ref=\"listHead\"\n        title=\"客户管理\"\n        :crm-type=\"crmType\"\n        placeholder=\"请输入客户名称/手机号\"\n        main-title=\"新建客户\"\n    />\n    <div>\n        <crm-table-head \n\n        />\n        <el-table\n            v-loading=\"loading\"\n            :data=\"list\"\n            style=\"width: 100%\"\n            border\n            stripe\n        >\n            <el-table-column\n                show-overflow-tooltip\n                type=\"selection\"\n                align=\"center\"\n                width=\"55\"\n            />\n            <!-- 遍历字段 -->\n            <el-table-column\n                v-for=\"(item, index) in fieldList\"\n                :key=\"item.id\"\n                :prop=\"item.prop\"\n                :label=\"item.label\"\n                sortable=\"custom\"\n                show-overflow-tooltip\n            >\n                <template\n                    slot=\"header\"\n                    slot-scope=\"scope\"\n                >\n                    <div class=\"table-head-name\">{{scope.column.label}}</div>\n                </template>\n            <el-table-column/>\n            <el-table-column\n                fixed=\"right\"\n                width=\"36\"\n             >\n                \n             </el-table-column>\n        </el-table>\n        <!-- 分页 -->\n        <div class=\"p-container\">\n            <el-pagition \n                class=\"p-bar\"\n                :current-page=\"currentPage\"\n                :page-sizes=\"pageSizes\"\n                :titla=\"total\"\n                layout=\"totla, sizes, next, prev, jumper\"\n                @current-change=\"handleCurrentChange\"\n            />\n        </div>\n    </div>\n</template>\n<script>\nimport { mapGetters } from 'vuex'\nexport default {\n    name: 'CustomerIndex',\n    components: {\n\n    },\n    computed: {\n        ...mapGetters(['CRMconfig'])\n    },\n    minins: [],\n    data () {\n        return {\n            crmType: 'customer'\n        }\n    },\n    methods: {\n\n    }\n}\n</script>\n<style lang=\"scss\" scoped>\n\n</style>\n```\n","source":"_posts/基于vue开发的CRM系统.md","raw":"---\ntitle: vue后台管理系统\ndate: 2021-10-29 14:16:48\ntags:\n---\n\n##### 1. 功能模块\n（1）客户管理\n    - 仪表盘\n    - 待办事项\n    - 线索\n    - 客户\n    - 联系人\n    - 商机\n    - 合同\n    - 回款\n    - 发票\n    - 产品\n    - 市场活动\n（2）人力资源\n（3）日志\n（4）项目管理\n（5）任务审批\n\n##### 2. 技术栈\nvue@2.x\nvue-cli@3.x\nvue-router\nvuex\naxios\nelement-ui\n\n##### 3. 搭建开发环境\n(1) 安装node\n(2) 安装vue-cli\n\n```\nnpm install vue-cli -g\n```\n\n##### 4. 项目初始化\n```\nvue create crm\n```\n\n##### 5. github管理代码\n（1）github上创建远程代码仓库\n\n\n##### 6. 项目规划\n|- api\n|- assets\n|- components\n    |- CreateView.vue   // 新建页面通用组件\n|- directives\n|- filters\n|- router\n|- store\n|- styles\n|- utils\n|- views\n    |- CustomerManagement\n        |- components\n            |- CrmListHead.vue // 客户管理通用页头\n        |- customer\n            |- CustomerIndex.vue\n|- App.vue\n|- main.js\n|- permission.js\n\n##### 6. axios封装\n\n```\nimport axios from 'axios'\n\nconst service = axios.create({\n    baseURL: process.env.BASE_API,\n    timeout: 15000\n})\n\nservice.interceptors.request.use(config => {\n\n})\n\nservice.interceptors.response.use(response => {\n\n})\n\nexport default service\n```\n\n##### 7. 请求API\n\napi/user.js\n\n```\nimport request from '@/utils/request'\n\nexport default login (username, password) {\n    return request({\n        url: '/login',\n        data: {\n            username,\n            password\n        }\n    })\n}\n```\n\n##### 8. 公共模块封装\n（1）新建页面组件\n\n```\n<template>\n    <transition name=\"opacity-fade\">\n        <div \n            class=\"c-view\"\n            :style=\"{'background-color': backgroundColor, 'padding': padding}\"\n        >\n            <el-card\n                v-loading=\"loading\"\n                :style=\"{'width': width}\"\n            >\n                <slot name=\"header\" />\n                <slot />\n            </el-card>\n        </div>\n    </transition>\n</template>\n<script>\nexport default {\n    name: 'CreateView',\n    props: {\n        borderStyle: {\n            type: Object,\n            default: () => {\n                return {}\n            }\n        },\n        loading: {\n            type: Boolean,\n            default: false\n        },\n        width: {\n            type: String,\n            default: '700px'\n        },\n        backgroundColor: {\n            type: String,\n            default: '#F5F6F9' // rgba(0, 0, 0, 0.6) 黑色半透明\n        },\n        /** 展示内容的上下padding **/\n        padding: {\n            type: String,\n            default: '40px'\n        }\n    },\n    data () {\n        return {\n            \n        }\n    }\n}\n</script>\n<style lang=\"scss\" scoped>\n.opacity-fade-enter,\n.opacity-fade-leave-active{\n    transition: all 0.2s;\n}\n.opacity-fade-enter,\n.opacity-fade-leave-to{\n    opacity: 0;\n}\n</style>\n```\n\n##### 7. 状态管理\n- store/index.js\n\n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport getters from './getters'\nimport customer from './modules/customer'\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store({\n    modules: {\n        app,\n        customer\n    },\n    getters\n})\n\nexport default store\n```\n\n- store/getters.js\n\n```\nconst getters = {\n    crm: state => state.user.crm\n}\n\nexport default getters\n```\n\n- store/modules/user.js\n\n```\nimport { login, logout } from '@/api/login'\nconst app = {\n    state: {\n        crm: {},    // 客户管理\n    },\n    mutations: {\n        SET_CRM: (state, crm) => {\n            state.crm = crm\n        }\n    },\n    actions: {\n        Login({commit}, userInfo){\n            return new Promise((resolve, reject) => {\n                login(username, userInfo.password).then(data => {\n                    commit('SET_CRM', data.auth.crm)\n                }).catch(error => {\n                    reject(error)\n                })\n            })\n        }\n    }\n}\nexport default app\n```\n\n##### 6. 客户模块\n（1）\n\n（2）分析页面，筛选通用部分，封装成公共组件\n- 页头部分公用组件封装\nCrmListHead\n```\n<template>\n    <div class=\"container\">\n        <div>{{title}}</div>\n        <el-input \n            placeholder=\"placeholder\"\n            @input=\"inputChange\"\n            v-model=\"inputContent\">\n            <el-button \n                icon=\"el-icon-search\"\n                @click.native=\"searchInput\" />\n        </el-input>  \n        <div class=\"right-container\">\n            <el-button \n                v-if=\"cansave\"\n                type=\"primary\"\n                @click=\"createClick\"\n            >{{mainTitle}}</el-button>\n            <el-dropdowm\n                v-if=\"moreTypes.length > 0\"\n                trigger=\"click\"\n                @command=\"handleTypeDrop\"\n            >\n                <el-dropdown-menu slot=\"dropdown\">\n                    <el-dropwdown-item\n                        v-for=\"(item, index) in moreTypes\"\n                        :key=\"index\"\n                    >\n                        {{iitem.name}}\n                    </el-dropdowm>\n                </el-dropdown-menu>\n            <el-dropdown>\n        </div>\n        <crm-create-view \n            v-if=\"isCreate\"\n            :crmType=\"\"\n        />\n    </div>\n</template>\n\n<script>\nimport { mapGetters } from 'vuex'\nimport CrmCreateView from '@/components/CrmCreateView'\nexport default {\n    name: 'CrmListHead',\n    components: {\n        CrmCreateView\n    },\n    data () {\n        return {\n            inputContent: '',\n            moreTypes: []\n        }\n    },\n    props: {\n        // 页头主标题\n        title: {\n            type: String,\n            default: '\n        },\n        placeholder: {\n            type: String,\n            default: '请输入内容'\n        },\n        // 页头按钮文字\n        mainTitle: {\n            type: String,\n            default: ''\n        },\n        crmType: {\n            type: String,\n            default: ''\n        },\n        isSeas: {\n            type: Boolean,\n            default: false\n        }\n    },\n    computed: {\n        ...mapGetters(['crm']),\n        canSave () {\n\n        }\n    },\n    mounted () {\n        // 线索和客户判断更多操作\n        if (!this.isSeas) {\n            if (this.crm[this.crmType].excelimport) {\n                this.moreTypes.push({type: 'enter', name: '导入'})\n            }\n            if (this.crm[this.crmType].excelexport) {\n                this.moreTypes.push({type: 'out', name: '导出'})\n            }\n        } else {\n             // 客户池的导出关键字不同\n            if (this.crm.pool.excelexport) {\n                this.moreTypes.push({ type: 'out', name: '导出' })\n            }\n        }\n    },\n    methods: {\n        // 下拉菜单点击\n        handleTypeDrop(command, param = {}) {\n            if (command === 'out') {\n\n            } else if (command === 'enter') {\n\n            }\n        }\n        inputChange() {\n            this.$emit('update:search', this.inputContent)\n        },\n        searchInput () {\n            this.$emit('on-search', this.inputContent)\n        },\n        // 新建按钮\n        createClick () {\n\n        }\n    }\n}\n</script>\n```\n\n（2）mixins\n\nmixin/table.js\n\n```\nimport {\n    crmCustomerIndex\n} from '@/api/customerManagment/customer'\nexport default {\n    components: {\n        CrmListHead,\n    },\n    data () {\n        return {\n            loading: false, // 是否加载中\n            list: [],   // 表格数据\n            search: ''  // 搜索内容\n            fieldList: [],  // 表格字段\n            currentPage: 1, // 当前页面\n            total: 0,   // 总页数\n            pageSize: [15, 30, 60, 100],    \n            selectList: [], // 选中的数据\n        }\n    },\n    computed: {\n        ...mapGetters(['crm'])\n    },\n    mounted () {\n        // 控制table的高度\n        window.resize = () => {\n            this.updateTableHeight()\n        }\n    },\n    methods: {\n        // 获取数据\n        getList () {\n            this.loading = true\n            var crmIndexRequest = this.getIndexRequest()\n            // API请求参数\n            var params = {\n                page: this.currentPage,\n                limit: this.pageSize,\n                search: this.search,\n                type: this.isSeas ? crmTypeModel.pool : crmTypeModel[this.crmType]\n            }\n            // 执行请求\n            crmIndexRequest(params).then(res => {\n                if () {\n\n                } else {\n                    this.list = res.data.list\n                }\n                this.total = res.data.totalRow\n                this.loading = false\n            }).catch(() =>  {\n                this.loading = false\n            })\n        },\n        // 判断当前页面要执行的API请求\n        getIndexRequest () {\n            if (this.crmType === 'leads') {\n                return crmLeadsIndex\n            } else if (this.crmType === 'customer') {\n                if (this.isSeas) {\n                    return crmCustomerPool\n                } else {\n                    return crmCustomerIndex\n                }\n            } else if (this.crmType === 'contacts') {\n                return crmContactsIndex\n            } else if (this.crmType === 'business') {\n                return crmBusinessIndex\n            } else if (this.crmType === 'product') {\n                return crmProductIndex\n            }\n        },\n        // 搜索\n        crmSearch (value) {\n\n        }\n        // 获取表格字段\n        getFieldList () {\n            \n        }\n    }\n}\n```\n\n（3）客户管理页面\n\nCustomerIndex.vue\n\n```\n<template>\n    <crm-list-head \n        ref=\"listHead\"\n        title=\"客户管理\"\n        :crm-type=\"crmType\"\n        placeholder=\"请输入客户名称/手机号\"\n        main-title=\"新建客户\"\n    />\n    <div>\n        <crm-table-head \n\n        />\n        <el-table\n            v-loading=\"loading\"\n            :data=\"list\"\n            style=\"width: 100%\"\n            border\n            stripe\n        >\n            <el-table-column\n                show-overflow-tooltip\n                type=\"selection\"\n                align=\"center\"\n                width=\"55\"\n            />\n            <!-- 遍历字段 -->\n            <el-table-column\n                v-for=\"(item, index) in fieldList\"\n                :key=\"item.id\"\n                :prop=\"item.prop\"\n                :label=\"item.label\"\n                sortable=\"custom\"\n                show-overflow-tooltip\n            >\n                <template\n                    slot=\"header\"\n                    slot-scope=\"scope\"\n                >\n                    <div class=\"table-head-name\">{{scope.column.label}}</div>\n                </template>\n            <el-table-column/>\n            <el-table-column\n                fixed=\"right\"\n                width=\"36\"\n             >\n                \n             </el-table-column>\n        </el-table>\n        <!-- 分页 -->\n        <div class=\"p-container\">\n            <el-pagition \n                class=\"p-bar\"\n                :current-page=\"currentPage\"\n                :page-sizes=\"pageSizes\"\n                :titla=\"total\"\n                layout=\"totla, sizes, next, prev, jumper\"\n                @current-change=\"handleCurrentChange\"\n            />\n        </div>\n    </div>\n</template>\n<script>\nimport { mapGetters } from 'vuex'\nexport default {\n    name: 'CustomerIndex',\n    components: {\n\n    },\n    computed: {\n        ...mapGetters(['CRMconfig'])\n    },\n    minins: [],\n    data () {\n        return {\n            crmType: 'customer'\n        }\n    },\n    methods: {\n\n    }\n}\n</script>\n<style lang=\"scss\" scoped>\n\n</style>\n```\n","slug":"基于vue开发的CRM系统","published":1,"updated":"2021-11-20T01:50:59.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwou9u68000u9hwn2fo59j4y","content":"\n        <h5 id=\"1-功能模块\">\n          <a href=\"#1-功能模块\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-功能模块\" class=\"headerlink\" title=\"1. 功能模块\"></a>1. 功能模块</h5>\n      <p>（1）客户管理<br>    - 仪表盘<br>    - 待办事项<br>    - 线索<br>    - 客户<br>    - 联系人<br>    - 商机<br>    - 合同<br>    - 回款<br>    - 发票<br>    - 产品<br>    - 市场活动<br>（2）人力资源<br>（3）日志<br>（4）项目管理<br>（5）任务审批</p>\n\n        <h5 id=\"2-技术栈\">\n          <a href=\"#2-技术栈\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-技术栈\" class=\"headerlink\" title=\"2. 技术栈\"></a>2. 技术栈</h5>\n      <p><span class=\"exturl\"><a class=\"exturl__link\" href=\"mailto:&#x76;&#x75;&#x65;&#64;&#50;&#46;&#120;\">&#x76;&#x75;&#x65;&#64;&#50;&#46;&#120;</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br><span class=\"exturl\"><a class=\"exturl__link\" href=\"mailto:&#118;&#x75;&#101;&#x2d;&#99;&#108;&#105;&#64;&#x33;&#x2e;&#120;\">&#118;&#x75;&#101;&#x2d;&#99;&#108;&#105;&#64;&#x33;&#x2e;&#120;</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br>vue-router<br>vuex<br>axios<br>element-ui</p>\n\n        <h5 id=\"3-搭建开发环境\">\n          <a href=\"#3-搭建开发环境\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-搭建开发环境\" class=\"headerlink\" title=\"3. 搭建开发环境\"></a>3. 搭建开发环境</h5>\n      <p>(1) 安装node<br>(2) 安装vue-cli</p>\n<pre><code>npm install vue-cli -g\n</code></pre>\n\n        <h5 id=\"4-项目初始化\">\n          <a href=\"#4-项目初始化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-项目初始化\" class=\"headerlink\" title=\"4. 项目初始化\"></a>4. 项目初始化</h5>\n      <pre><code>vue create crm\n</code></pre>\n\n        <h5 id=\"5-github管理代码\">\n          <a href=\"#5-github管理代码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-github管理代码\" class=\"headerlink\" title=\"5. github管理代码\"></a>5. github管理代码</h5>\n      <p>（1）github上创建远程代码仓库</p>\n\n        <h5 id=\"6-项目规划\">\n          <a href=\"#6-项目规划\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-项目规划\" class=\"headerlink\" title=\"6. 项目规划\"></a>6. 项目规划</h5>\n      <p>|- api<br>|- assets<br>|- components<br>    |- CreateView.vue   // 新建页面通用组件<br>|- directives<br>|- filters<br>|- router<br>|- store<br>|- styles<br>|- utils<br>|- views<br>    |- CustomerManagement<br>        |- components<br>            |- CrmListHead.vue // 客户管理通用页头<br>        |- customer<br>            |- CustomerIndex.vue<br>|- App.vue<br>|- main.js<br>|- permission.js</p>\n\n        <h5 id=\"6-axios封装\">\n          <a href=\"#6-axios封装\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-axios封装\" class=\"headerlink\" title=\"6. axios封装\"></a>6. axios封装</h5>\n      <pre><code>import axios from &#39;axios&#39;\n\nconst service = axios.create(&#123;\n    baseURL: process.env.BASE_API,\n    timeout: 15000\n&#125;)\n\nservice.interceptors.request.use(config =&gt; &#123;\n\n&#125;)\n\nservice.interceptors.response.use(response =&gt; &#123;\n\n&#125;)\n\nexport default service\n</code></pre>\n\n        <h5 id=\"7-请求API\">\n          <a href=\"#7-请求API\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-请求API\" class=\"headerlink\" title=\"7. 请求API\"></a>7. 请求API</h5>\n      <p>api/user.js</p>\n<pre><code>import request from &#39;@/utils/request&#39;\n\nexport default login (username, password) &#123;\n    return request(&#123;\n        url: &#39;/login&#39;,\n        data: &#123;\n            username,\n            password\n        &#125;\n    &#125;)\n&#125;\n</code></pre>\n\n        <h5 id=\"8-公共模块封装\">\n          <a href=\"#8-公共模块封装\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-公共模块封装\" class=\"headerlink\" title=\"8. 公共模块封装\"></a>8. 公共模块封装</h5>\n      <p>（1）新建页面组件</p>\n<pre><code>&lt;template&gt;\n    &lt;transition name=&quot;opacity-fade&quot;&gt;\n        &lt;div \n            class=&quot;c-view&quot;\n            :style=&quot;&#123;&#39;background-color&#39;: backgroundColor, &#39;padding&#39;: padding&#125;&quot;\n        &gt;\n            &lt;el-card\n                v-loading=&quot;loading&quot;\n                :style=&quot;&#123;&#39;width&#39;: width&#125;&quot;\n            &gt;\n                &lt;slot name=&quot;header&quot; /&gt;\n                &lt;slot /&gt;\n            &lt;/el-card&gt;\n        &lt;/div&gt;\n    &lt;/transition&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default &#123;\n    name: &#39;CreateView&#39;,\n    props: &#123;\n        borderStyle: &#123;\n            type: Object,\n            default: () =&gt; &#123;\n                return &#123;&#125;\n            &#125;\n        &#125;,\n        loading: &#123;\n            type: Boolean,\n            default: false\n        &#125;,\n        width: &#123;\n            type: String,\n            default: &#39;700px&#39;\n        &#125;,\n        backgroundColor: &#123;\n            type: String,\n            default: &#39;#F5F6F9&#39; // rgba(0, 0, 0, 0.6) 黑色半透明\n        &#125;,\n        /** 展示内容的上下padding **/\n        padding: &#123;\n            type: String,\n            default: &#39;40px&#39;\n        &#125;\n    &#125;,\n    data () &#123;\n        return &#123;\n            \n        &#125;\n    &#125;\n&#125;\n&lt;/script&gt;\n&lt;style lang=&quot;scss&quot; scoped&gt;\n.opacity-fade-enter,\n.opacity-fade-leave-active&#123;\n    transition: all 0.2s;\n&#125;\n.opacity-fade-enter,\n.opacity-fade-leave-to&#123;\n    opacity: 0;\n&#125;\n&lt;/style&gt;\n</code></pre>\n\n        <h5 id=\"7-状态管理\">\n          <a href=\"#7-状态管理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-状态管理\" class=\"headerlink\" title=\"7. 状态管理\"></a>7. 状态管理</h5>\n      <ul>\n<li>store/index.js</li>\n</ul>\n<pre><code>import Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\nimport getters from &#39;./getters&#39;\nimport customer from &#39;./modules/customer&#39;\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store(&#123;\n    modules: &#123;\n        app,\n        customer\n    &#125;,\n    getters\n&#125;)\n\nexport default store\n</code></pre>\n<ul>\n<li>store/getters.js</li>\n</ul>\n<pre><code>const getters = &#123;\n    crm: state =&gt; state.user.crm\n&#125;\n\nexport default getters\n</code></pre>\n<ul>\n<li>store/modules/user.js</li>\n</ul>\n<pre><code>import &#123; login, logout &#125; from &#39;@/api/login&#39;\nconst app = &#123;\n    state: &#123;\n        crm: &#123;&#125;,    // 客户管理\n    &#125;,\n    mutations: &#123;\n        SET_CRM: (state, crm) =&gt; &#123;\n            state.crm = crm\n        &#125;\n    &#125;,\n    actions: &#123;\n        Login(&#123;commit&#125;, userInfo)&#123;\n            return new Promise((resolve, reject) =&gt; &#123;\n                login(username, userInfo.password).then(data =&gt; &#123;\n                    commit(&#39;SET_CRM&#39;, data.auth.crm)\n                &#125;).catch(error =&gt; &#123;\n                    reject(error)\n                &#125;)\n            &#125;)\n        &#125;\n    &#125;\n&#125;\nexport default app\n</code></pre>\n\n        <h5 id=\"6-客户模块\">\n          <a href=\"#6-客户模块\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-客户模块\" class=\"headerlink\" title=\"6. 客户模块\"></a>6. 客户模块</h5>\n      <p>（1）</p>\n<p>（2）分析页面，筛选通用部分，封装成公共组件</p>\n<ul>\n<li>页头部分公用组件封装<br>CrmListHead<br>```<template>\n  <div class=\"container\">\n      <div>vue后台管理系统</div>\n      <el-input placeholder=\"placeholder\" @input=\"inputChange\" v-model=\"inputContent\">\n          <el-button icon=\"el-icon-search\" @click.native=\"searchInput\">\n      </el-button></el-input>  \n      <div class=\"right-container\">\n          <el-button v-if=\"cansave\" type=\"primary\" @click=\"createClick\"></el-button>\n          <el-dropdowm v-if=\"moreTypes.length > 0\" trigger=\"click\" @command=\"handleTypeDrop\">\n              <el-dropdown-menu slot=\"dropdown\">\n                  <el-dropwdown-item v-for=\"(item, index) in moreTypes\" :key=\"index\">\n                      \n                  </el-dropwdown-item></el-dropdown-menu></el-dropdowm>\n              \n          <el-dropdown>\n      </el-dropdown></div>\n      <crm-create-view v-if=\"isCreate\" :crmtype>\n  </crm-create-view></div>\n</template></li>\n</ul>\n<script>\nimport { mapGetters } from 'vuex'\nimport CrmCreateView from '@/components/CrmCreateView'\nexport default {\n    name: 'CrmListHead',\n    components: {\n        CrmCreateView\n    },\n    data () {\n        return {\n            inputContent: '',\n            moreTypes: []\n        }\n    },\n    props: {\n        // 页头主标题\n        title: {\n            type: String,\n            default: '\n        },\n        placeholder: {\n            type: String,\n            default: '请输入内容'\n        },\n        // 页头按钮文字\n        mainTitle: {\n            type: String,\n            default: ''\n        },\n        crmType: {\n            type: String,\n            default: ''\n        },\n        isSeas: {\n            type: Boolean,\n            default: false\n        }\n    },\n    computed: {\n        ...mapGetters(['crm']),\n        canSave () {\n\n        }\n    },\n    mounted () {\n        // 线索和客户判断更多操作\n        if (!this.isSeas) {\n            if (this.crm[this.crmType].excelimport) {\n                this.moreTypes.push({type: 'enter', name: '导入'})\n            }\n            if (this.crm[this.crmType].excelexport) {\n                this.moreTypes.push({type: 'out', name: '导出'})\n            }\n        } else {\n             // 客户池的导出关键字不同\n            if (this.crm.pool.excelexport) {\n                this.moreTypes.push({ type: 'out', name: '导出' })\n            }\n        }\n    },\n    methods: {\n        // 下拉菜单点击\n        handleTypeDrop(command, param = {}) {\n            if (command === 'out') {\n\n            } else if (command === 'enter') {\n\n            }\n        }\n        inputChange() {\n            this.$emit('update:search', this.inputContent)\n        },\n        searchInput () {\n            this.$emit('on-search', this.inputContent)\n        },\n        // 新建按钮\n        createClick () {\n\n        }\n    }\n}\n</script>\n<pre><code>\n（2）mixins\n\nmixin/table.js\n</code></pre>\n<p>import {<br>    crmCustomerIndex<br>} from ‘@/api/customerManagment/customer’<br>export default {<br>    components: {<br>        CrmListHead,<br>    },<br>    data () {<br>        return {<br>            loading: false, // 是否加载中<br>            list: [],   // 表格数据<br>            search: ‘’  // 搜索内容<br>            fieldList: [],  // 表格字段<br>            currentPage: 1, // 当前页面<br>            total: 0,   // 总页数<br>            pageSize: [15, 30, 60, 100],<br>            selectList: [], // 选中的数据<br>        }<br>    },<br>    computed: {<br>        …mapGetters([‘crm’])<br>    },<br>    mounted () {<br>        // 控制table的高度<br>        window.resize = () =&gt; {<br>            this.updateTableHeight()<br>        }<br>    },<br>    methods: {<br>        // 获取数据<br>        getList () {<br>            this.loading = true<br>            var crmIndexRequest = this.getIndexRequest()<br>            // API请求参数<br>            var params = {<br>                page: this.currentPage,<br>                limit: this.pageSize,<br>                search: this.search,<br>                type: this.isSeas ? crmTypeModel.pool : crmTypeModel[this.crmType]<br>            }<br>            // 执行请求<br>            crmIndexRequest(params).then(res =&gt; {<br>                if () {</p>\n<pre><code>            &#125; else &#123;\n                this.list = res.data.list\n            &#125;\n            this.total = res.data.totalRow\n            this.loading = false\n        &#125;).catch(() =&gt;  &#123;\n            this.loading = false\n        &#125;)\n    &#125;,\n    // 判断当前页面要执行的API请求\n    getIndexRequest () &#123;\n        if (this.crmType === &#39;leads&#39;) &#123;\n            return crmLeadsIndex\n        &#125; else if (this.crmType === &#39;customer&#39;) &#123;\n            if (this.isSeas) &#123;\n                return crmCustomerPool\n            &#125; else &#123;\n                return crmCustomerIndex\n            &#125;\n        &#125; else if (this.crmType === &#39;contacts&#39;) &#123;\n            return crmContactsIndex\n        &#125; else if (this.crmType === &#39;business&#39;) &#123;\n            return crmBusinessIndex\n        &#125; else if (this.crmType === &#39;product&#39;) &#123;\n            return crmProductIndex\n        &#125;\n    &#125;,\n    // 搜索\n    crmSearch (value) &#123;\n\n    &#125;\n    // 获取表格字段\n    getFieldList () &#123;\n        \n    &#125;\n&#125;\n</code></pre>\n<p>}</p>\n<pre><code>\n（3）客户管理页面\n\nCustomerIndex.vue\n</code></pre>\n<template>\n    <crm-list-head ref=\"listHead\" title=\"客户管理\" :crm-type=\"crmType\" placeholder=\"请输入客户名称/手机号\" main-title=\"新建客户\">\n    <div>\n        <crm-table-head <pre><code>    /&gt;\n    &lt;el-table\n        v-loading=&quot;loading&quot;\n        :data=&quot;list&quot;\n        style=&quot;width: 100%&quot;\n        border\n        stripe\n    &gt;\n        &lt;el-table-column\n            show-overflow-tooltip\n            type=&quot;selection&quot;\n            align=&quot;center&quot;\n            width=&quot;55&quot;\n        /&gt;\n        &lt;!-- 遍历字段 --&gt;\n        &lt;el-table-column\n            v-for=&quot;(item, index) in fieldList&quot;\n            :key=&quot;item.id&quot;\n            :prop=&quot;item.prop&quot;\n            :label=&quot;item.label&quot;\n            sortable=&quot;custom&quot;\n            show-overflow-tooltip\n        &gt;\n            &lt;template\n                slot=&quot;header&quot;\n                slot-scope=&quot;scope&quot;\n            &gt;\n                &lt;div class=&quot;table-head-name&quot;&gt;&#123;&#123;scope.column.label&#125;&#125;&lt;/div&gt;\n            &lt;/template&gt;\n        &lt;el-table-column/&gt;\n        &lt;el-table-column\n            fixed=&quot;right&quot;\n            width=&quot;36&quot;\n         &gt;\n            \n         &lt;/el-table-column&gt;\n    &lt;/el-table&gt;\n    &lt;!-- 分页 --&gt;\n    &lt;div class=&quot;p-container&quot;&gt;\n        &lt;el-pagition \n            class=&quot;p-bar&quot;\n            :current-page=&quot;currentPage&quot;\n            :page-sizes=&quot;pageSizes&quot;\n            :titla=&quot;total&quot;\n            layout=&quot;totla, sizes, next, prev, jumper&quot;\n            @current-change=&quot;handleCurrentChange&quot;\n        /&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code>\n</crm-table-head></div></crm-list-head></template>\n<script>\nimport { mapGetters } from 'vuex'\nexport default {\n    name: 'CustomerIndex',\n    components: {\n\n<pre><code>&#125;,\ncomputed: &#123;\n    ...mapGetters([&#39;CRMconfig&#39;])\n&#125;,\nminins: [],\ndata () &#123;\n    return &#123;\n        crmType: &#39;customer&#39;\n    &#125;\n&#125;,\nmethods: &#123;\n\n&#125;\n</code></pre>\n<p>}<br></script><p></p>\n<style lang=\"scss\" scoped>\n\n</style>\n<pre><code>\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"\n        <h5 id=\"1-功能模块\">\n          <a href=\"#1-功能模块\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-功能模块\" class=\"headerlink\" title=\"1. 功能模块\"></a>1. 功能模块</h5>\n      <p>（1）客户管理<br>    - 仪表盘<br>    - 待办事项<br>    - 线索<br>    - 客户<br>    - 联系人<br>    - 商机<br>    - 合同<br>    - 回款<br>    - 发票<br>    - 产品<br>    - 市场活动<br>（2）人力资源<br>（3）日志<br>（4）项目管理<br>（5）任务审批</p>\n\n        <h5 id=\"2-技术栈\">\n          <a href=\"#2-技术栈\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-技术栈\" class=\"headerlink\" title=\"2. 技术栈\"></a>2. 技术栈</h5>\n      <p><span class=\"exturl\"><a class=\"exturl__link\" href=\"mailto:&#x76;&#x75;&#x65;&#64;&#50;&#46;&#120;\">&#x76;&#x75;&#x65;&#64;&#50;&#46;&#120;</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br><span class=\"exturl\"><a class=\"exturl__link\" href=\"mailto:&#118;&#x75;&#101;&#x2d;&#99;&#108;&#105;&#64;&#x33;&#x2e;&#120;\">&#118;&#x75;&#101;&#x2d;&#99;&#108;&#105;&#64;&#x33;&#x2e;&#120;</a><span class=\"exturl__icon\"><i class=\"fas fa-external-link-alt\"></i></span></span><br>vue-router<br>vuex<br>axios<br>element-ui</p>\n\n        <h5 id=\"3-搭建开发环境\">\n          <a href=\"#3-搭建开发环境\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-搭建开发环境\" class=\"headerlink\" title=\"3. 搭建开发环境\"></a>3. 搭建开发环境</h5>\n      <p>(1) 安装node<br>(2) 安装vue-cli</p>\n<pre><code>npm install vue-cli -g\n</code></pre>\n\n        <h5 id=\"4-项目初始化\">\n          <a href=\"#4-项目初始化\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-项目初始化\" class=\"headerlink\" title=\"4. 项目初始化\"></a>4. 项目初始化</h5>\n      <pre><code>vue create crm\n</code></pre>\n\n        <h5 id=\"5-github管理代码\">\n          <a href=\"#5-github管理代码\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#5-github管理代码\" class=\"headerlink\" title=\"5. github管理代码\"></a>5. github管理代码</h5>\n      <p>（1）github上创建远程代码仓库</p>\n\n        <h5 id=\"6-项目规划\">\n          <a href=\"#6-项目规划\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-项目规划\" class=\"headerlink\" title=\"6. 项目规划\"></a>6. 项目规划</h5>\n      <p>|- api<br>|- assets<br>|- components<br>    |- CreateView.vue   // 新建页面通用组件<br>|- directives<br>|- filters<br>|- router<br>|- store<br>|- styles<br>|- utils<br>|- views<br>    |- CustomerManagement<br>        |- components<br>            |- CrmListHead.vue // 客户管理通用页头<br>        |- customer<br>            |- CustomerIndex.vue<br>|- App.vue<br>|- main.js<br>|- permission.js</p>\n\n        <h5 id=\"6-axios封装\">\n          <a href=\"#6-axios封装\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-axios封装\" class=\"headerlink\" title=\"6. axios封装\"></a>6. axios封装</h5>\n      <pre><code>import axios from &#39;axios&#39;\n\nconst service = axios.create(&#123;\n    baseURL: process.env.BASE_API,\n    timeout: 15000\n&#125;)\n\nservice.interceptors.request.use(config =&gt; &#123;\n\n&#125;)\n\nservice.interceptors.response.use(response =&gt; &#123;\n\n&#125;)\n\nexport default service\n</code></pre>\n\n        <h5 id=\"7-请求API\">\n          <a href=\"#7-请求API\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-请求API\" class=\"headerlink\" title=\"7. 请求API\"></a>7. 请求API</h5>\n      <p>api/user.js</p>\n<pre><code>import request from &#39;@/utils/request&#39;\n\nexport default login (username, password) &#123;\n    return request(&#123;\n        url: &#39;/login&#39;,\n        data: &#123;\n            username,\n            password\n        &#125;\n    &#125;)\n&#125;\n</code></pre>\n\n        <h5 id=\"8-公共模块封装\">\n          <a href=\"#8-公共模块封装\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#8-公共模块封装\" class=\"headerlink\" title=\"8. 公共模块封装\"></a>8. 公共模块封装</h5>\n      <p>（1）新建页面组件</p>\n<pre><code>&lt;template&gt;\n    &lt;transition name=&quot;opacity-fade&quot;&gt;\n        &lt;div \n            class=&quot;c-view&quot;\n            :style=&quot;&#123;&#39;background-color&#39;: backgroundColor, &#39;padding&#39;: padding&#125;&quot;\n        &gt;\n            &lt;el-card\n                v-loading=&quot;loading&quot;\n                :style=&quot;&#123;&#39;width&#39;: width&#125;&quot;\n            &gt;\n                &lt;slot name=&quot;header&quot; /&gt;\n                &lt;slot /&gt;\n            &lt;/el-card&gt;\n        &lt;/div&gt;\n    &lt;/transition&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default &#123;\n    name: &#39;CreateView&#39;,\n    props: &#123;\n        borderStyle: &#123;\n            type: Object,\n            default: () =&gt; &#123;\n                return &#123;&#125;\n            &#125;\n        &#125;,\n        loading: &#123;\n            type: Boolean,\n            default: false\n        &#125;,\n        width: &#123;\n            type: String,\n            default: &#39;700px&#39;\n        &#125;,\n        backgroundColor: &#123;\n            type: String,\n            default: &#39;#F5F6F9&#39; // rgba(0, 0, 0, 0.6) 黑色半透明\n        &#125;,\n        /** 展示内容的上下padding **/\n        padding: &#123;\n            type: String,\n            default: &#39;40px&#39;\n        &#125;\n    &#125;,\n    data () &#123;\n        return &#123;\n            \n        &#125;\n    &#125;\n&#125;\n&lt;/script&gt;\n&lt;style lang=&quot;scss&quot; scoped&gt;\n.opacity-fade-enter,\n.opacity-fade-leave-active&#123;\n    transition: all 0.2s;\n&#125;\n.opacity-fade-enter,\n.opacity-fade-leave-to&#123;\n    opacity: 0;\n&#125;\n&lt;/style&gt;\n</code></pre>\n\n        <h5 id=\"7-状态管理\">\n          <a href=\"#7-状态管理\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#7-状态管理\" class=\"headerlink\" title=\"7. 状态管理\"></a>7. 状态管理</h5>\n      <ul>\n<li>store/index.js</li>\n</ul>\n<pre><code>import Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\nimport getters from &#39;./getters&#39;\nimport customer from &#39;./modules/customer&#39;\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store(&#123;\n    modules: &#123;\n        app,\n        customer\n    &#125;,\n    getters\n&#125;)\n\nexport default store\n</code></pre>\n<ul>\n<li>store/getters.js</li>\n</ul>\n<pre><code>const getters = &#123;\n    crm: state =&gt; state.user.crm\n&#125;\n\nexport default getters\n</code></pre>\n<ul>\n<li>store/modules/user.js</li>\n</ul>\n<pre><code>import &#123; login, logout &#125; from &#39;@/api/login&#39;\nconst app = &#123;\n    state: &#123;\n        crm: &#123;&#125;,    // 客户管理\n    &#125;,\n    mutations: &#123;\n        SET_CRM: (state, crm) =&gt; &#123;\n            state.crm = crm\n        &#125;\n    &#125;,\n    actions: &#123;\n        Login(&#123;commit&#125;, userInfo)&#123;\n            return new Promise((resolve, reject) =&gt; &#123;\n                login(username, userInfo.password).then(data =&gt; &#123;\n                    commit(&#39;SET_CRM&#39;, data.auth.crm)\n                &#125;).catch(error =&gt; &#123;\n                    reject(error)\n                &#125;)\n            &#125;)\n        &#125;\n    &#125;\n&#125;\nexport default app\n</code></pre>\n\n        <h5 id=\"6-客户模块\">\n          <a href=\"#6-客户模块\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#6-客户模块\" class=\"headerlink\" title=\"6. 客户模块\"></a>6. 客户模块</h5>\n      <p>（1）</p>\n<p>（2）分析页面，筛选通用部分，封装成公共组件</p>\n<ul>\n<li>页头部分公用组件封装<br>CrmListHead<br>```<template>\n  <div class=\"container\">\n      <div>vue后台管理系统</div>\n      <el-input placeholder=\"placeholder\" @input=\"inputChange\" v-model=\"inputContent\">\n          <el-button icon=\"el-icon-search\" @click.native=\"searchInput\">\n      </el-button></el-input>  \n      <div class=\"right-container\">\n          <el-button v-if=\"cansave\" type=\"primary\" @click=\"createClick\"></el-button>\n          <el-dropdowm v-if=\"moreTypes.length > 0\" trigger=\"click\" @command=\"handleTypeDrop\">\n              <el-dropdown-menu slot=\"dropdown\">\n                  <el-dropwdown-item v-for=\"(item, index) in moreTypes\" :key=\"index\">\n                      \n                  </el-dropwdown-item></el-dropdown-menu></el-dropdowm>\n              \n          <el-dropdown>\n      </el-dropdown></div>\n      <crm-create-view v-if=\"isCreate\" :crmtype>\n  </crm-create-view></div>\n</template></li>\n</ul>\n<script>\nimport { mapGetters } from 'vuex'\nimport CrmCreateView from '@/components/CrmCreateView'\nexport default {\n    name: 'CrmListHead',\n    components: {\n        CrmCreateView\n    },\n    data () {\n        return {\n            inputContent: '',\n            moreTypes: []\n        }\n    },\n    props: {\n        // 页头主标题\n        title: {\n            type: String,\n            default: '\n        },\n        placeholder: {\n            type: String,\n            default: '请输入内容'\n        },\n        // 页头按钮文字\n        mainTitle: {\n            type: String,\n            default: ''\n        },\n        crmType: {\n            type: String,\n            default: ''\n        },\n        isSeas: {\n            type: Boolean,\n            default: false\n        }\n    },\n    computed: {\n        ...mapGetters(['crm']),\n        canSave () {\n\n        }\n    },\n    mounted () {\n        // 线索和客户判断更多操作\n        if (!this.isSeas) {\n            if (this.crm[this.crmType].excelimport) {\n                this.moreTypes.push({type: 'enter', name: '导入'})\n            }\n            if (this.crm[this.crmType].excelexport) {\n                this.moreTypes.push({type: 'out', name: '导出'})\n            }\n        } else {\n             // 客户池的导出关键字不同\n            if (this.crm.pool.excelexport) {\n                this.moreTypes.push({ type: 'out', name: '导出' })\n            }\n        }\n    },\n    methods: {\n        // 下拉菜单点击\n        handleTypeDrop(command, param = {}) {\n            if (command === 'out') {\n\n            } else if (command === 'enter') {\n\n            }\n        }\n        inputChange() {\n            this.$emit('update:search', this.inputContent)\n        },\n        searchInput () {\n            this.$emit('on-search', this.inputContent)\n        },\n        // 新建按钮\n        createClick () {\n\n        }\n    }\n}\n</script>\n<pre><code>\n（2）mixins\n\nmixin/table.js\n</code></pre>\n<p>import {<br>    crmCustomerIndex<br>} from ‘@/api/customerManagment/customer’<br>export default {<br>    components: {<br>        CrmListHead,<br>    },<br>    data () {<br>        return {<br>            loading: false, // 是否加载中<br>            list: [],   // 表格数据<br>            search: ‘’  // 搜索内容<br>            fieldList: [],  // 表格字段<br>            currentPage: 1, // 当前页面<br>            total: 0,   // 总页数<br>            pageSize: [15, 30, 60, 100],<br>            selectList: [], // 选中的数据<br>        }<br>    },<br>    computed: {<br>        …mapGetters([‘crm’])<br>    },<br>    mounted () {<br>        // 控制table的高度<br>        window.resize = () =&gt; {<br>            this.updateTableHeight()<br>        }<br>    },<br>    methods: {<br>        // 获取数据<br>        getList () {<br>            this.loading = true<br>            var crmIndexRequest = this.getIndexRequest()<br>            // API请求参数<br>            var params = {<br>                page: this.currentPage,<br>                limit: this.pageSize,<br>                search: this.search,<br>                type: this.isSeas ? crmTypeModel.pool : crmTypeModel[this.crmType]<br>            }<br>            // 执行请求<br>            crmIndexRequest(params).then(res =&gt; {<br>                if () {</p>\n<pre><code>            &#125; else &#123;\n                this.list = res.data.list\n            &#125;\n            this.total = res.data.totalRow\n            this.loading = false\n        &#125;).catch(() =&gt;  &#123;\n            this.loading = false\n        &#125;)\n    &#125;,\n    // 判断当前页面要执行的API请求\n    getIndexRequest () &#123;\n        if (this.crmType === &#39;leads&#39;) &#123;\n            return crmLeadsIndex\n        &#125; else if (this.crmType === &#39;customer&#39;) &#123;\n            if (this.isSeas) &#123;\n                return crmCustomerPool\n            &#125; else &#123;\n                return crmCustomerIndex\n            &#125;\n        &#125; else if (this.crmType === &#39;contacts&#39;) &#123;\n            return crmContactsIndex\n        &#125; else if (this.crmType === &#39;business&#39;) &#123;\n            return crmBusinessIndex\n        &#125; else if (this.crmType === &#39;product&#39;) &#123;\n            return crmProductIndex\n        &#125;\n    &#125;,\n    // 搜索\n    crmSearch (value) &#123;\n\n    &#125;\n    // 获取表格字段\n    getFieldList () &#123;\n        \n    &#125;\n&#125;\n</code></pre>\n<p>}</p>\n<pre><code>\n（3）客户管理页面\n\nCustomerIndex.vue\n</code></pre>\n<template>\n    <crm-list-head ref=\"listHead\" title=\"客户管理\" :crm-type=\"crmType\" placeholder=\"请输入客户名称/手机号\" main-title=\"新建客户\">\n    <div>\n        <crm-table-head <pre><code>    /&gt;\n    &lt;el-table\n        v-loading=&quot;loading&quot;\n        :data=&quot;list&quot;\n        style=&quot;width: 100%&quot;\n        border\n        stripe\n    &gt;\n        &lt;el-table-column\n            show-overflow-tooltip\n            type=&quot;selection&quot;\n            align=&quot;center&quot;\n            width=&quot;55&quot;\n        /&gt;\n        &lt;!-- 遍历字段 --&gt;\n        &lt;el-table-column\n            v-for=&quot;(item, index) in fieldList&quot;\n            :key=&quot;item.id&quot;\n            :prop=&quot;item.prop&quot;\n            :label=&quot;item.label&quot;\n            sortable=&quot;custom&quot;\n            show-overflow-tooltip\n        &gt;\n            &lt;template\n                slot=&quot;header&quot;\n                slot-scope=&quot;scope&quot;\n            &gt;\n                &lt;div class=&quot;table-head-name&quot;&gt;&#123;&#123;scope.column.label&#125;&#125;&lt;/div&gt;\n            &lt;/template&gt;\n        &lt;el-table-column/&gt;\n        &lt;el-table-column\n            fixed=&quot;right&quot;\n            width=&quot;36&quot;\n         &gt;\n            \n         &lt;/el-table-column&gt;\n    &lt;/el-table&gt;\n    &lt;!-- 分页 --&gt;\n    &lt;div class=&quot;p-container&quot;&gt;\n        &lt;el-pagition \n            class=&quot;p-bar&quot;\n            :current-page=&quot;currentPage&quot;\n            :page-sizes=&quot;pageSizes&quot;\n            :titla=&quot;total&quot;\n            layout=&quot;totla, sizes, next, prev, jumper&quot;\n            @current-change=&quot;handleCurrentChange&quot;\n        /&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code>\n</crm-table-head></div></crm-list-head></template>\n<script>\nimport { mapGetters } from 'vuex'\nexport default {\n    name: 'CustomerIndex',\n    components: {\n\n<pre><code>&#125;,\ncomputed: &#123;\n    ...mapGetters([&#39;CRMconfig&#39;])\n&#125;,\nminins: [],\ndata () &#123;\n    return &#123;\n        crmType: &#39;customer&#39;\n    &#125;\n&#125;,\nmethods: &#123;\n\n&#125;\n</code></pre>\n<p>}<br></script><p></p>\n<style lang=\"scss\" scoped>\n\n</style>\n<pre><code>\n</code></pre>\n"},{"title":"大屏数据可视化项目开发","date":"2021-10-29T06:50:13.000Z","_content":"\n##### 1. 创建项目\n\n```\nvue create datav\n```\n\n#### 2. 安装依赖\n\n```\nnpm install echarts\n```\n\n##### 3. 页面拆分\n（1）热销商品（基于饼图封装）\n（2）客户分布（基于地图封装）\n（3）销售数据（基于柱图封装）\n（4）库存分析（基于饼图封装）\n（5）销售走势（基于折线图封装）\n（6）商家统计（基于柱图封装）\n\n##### 4. 热销商品组件开发\n\n```\n<template>\n    <div class=\"c-container\">\n        <div ref=\"hot_ref\"></div>\n    </div>\n</template>\n\n<script>\nexport default {\n    data () {\n        return {\n            initOption: {\n                title: {\n                    text: '热销商品销售统计',\n                    top: 20,\n                    left: 20\n                },\n                legend: {\n                    top: '20%',\n                    icon: 'circle'\n                },\n                tooltip: {\n                    show: true\n                },\n                series: [\n                    {\n                        type: 'pie',\n                        label: {\n                            show: false\n                        }\n                    }\n                ]\n            },\n            timer,\n            chartInstance: null,\n            currentIndex: 0\n        }\n    },\n    methods: {\n        // 初始化\n        initChart () {\n            this.chartInstance = this.$echarts.init(this.$refs.hot_ref, 'chalk')\n        },\n        // 动态展示数据\n        updateChart () {\n            this.chartInstance.setOption(updateOption)\n        },\n        // 自适应窗口改变\n        updateScreen () {\n            const titleFontSize = this.$refs.hot_ref.offsetWidth / 100 * 3.6\n            const screenOption = {\n                title: {\n                    textStyle: {\n                        textStyle: {\n                            fontSize: titleFontSize / 1.5\n                        }\n                    }\n                }\n            }\n        },\n        startInterval () {\n            if (this.timer) {\n                clearInterval(this.timer)\n            }\n            this.timer = setInterval(() => {\n                this.currentIndex++\n                if (this.currentIndex > this.allData.length - 1) {\n                    this.currentIndex = 0\n                }\n                this.updateChart()\n            }, 2000)\n        }\n    }\n}\n</script>\n```","source":"_posts/大屏数据可视化项目开发.md","raw":"---\ntitle: 大屏数据可视化项目开发\ndate: 2021-10-29 14:50:13\ntags:\n---\n\n##### 1. 创建项目\n\n```\nvue create datav\n```\n\n#### 2. 安装依赖\n\n```\nnpm install echarts\n```\n\n##### 3. 页面拆分\n（1）热销商品（基于饼图封装）\n（2）客户分布（基于地图封装）\n（3）销售数据（基于柱图封装）\n（4）库存分析（基于饼图封装）\n（5）销售走势（基于折线图封装）\n（6）商家统计（基于柱图封装）\n\n##### 4. 热销商品组件开发\n\n```\n<template>\n    <div class=\"c-container\">\n        <div ref=\"hot_ref\"></div>\n    </div>\n</template>\n\n<script>\nexport default {\n    data () {\n        return {\n            initOption: {\n                title: {\n                    text: '热销商品销售统计',\n                    top: 20,\n                    left: 20\n                },\n                legend: {\n                    top: '20%',\n                    icon: 'circle'\n                },\n                tooltip: {\n                    show: true\n                },\n                series: [\n                    {\n                        type: 'pie',\n                        label: {\n                            show: false\n                        }\n                    }\n                ]\n            },\n            timer,\n            chartInstance: null,\n            currentIndex: 0\n        }\n    },\n    methods: {\n        // 初始化\n        initChart () {\n            this.chartInstance = this.$echarts.init(this.$refs.hot_ref, 'chalk')\n        },\n        // 动态展示数据\n        updateChart () {\n            this.chartInstance.setOption(updateOption)\n        },\n        // 自适应窗口改变\n        updateScreen () {\n            const titleFontSize = this.$refs.hot_ref.offsetWidth / 100 * 3.6\n            const screenOption = {\n                title: {\n                    textStyle: {\n                        textStyle: {\n                            fontSize: titleFontSize / 1.5\n                        }\n                    }\n                }\n            }\n        },\n        startInterval () {\n            if (this.timer) {\n                clearInterval(this.timer)\n            }\n            this.timer = setInterval(() => {\n                this.currentIndex++\n                if (this.currentIndex > this.allData.length - 1) {\n                    this.currentIndex = 0\n                }\n                this.updateChart()\n            }, 2000)\n        }\n    }\n}\n</script>\n```","slug":"大屏数据可视化项目开发","published":1,"updated":"2021-11-20T01:51:59.824Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwou9u69000v9hwneq0j19ct","content":"\n        <h5 id=\"1-创建项目\">\n          <a href=\"#1-创建项目\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-创建项目\" class=\"headerlink\" title=\"1. 创建项目\"></a>1. 创建项目</h5>\n      <pre><code>vue create datav\n</code></pre>\n\n        <h4 id=\"2-安装依赖\">\n          <a href=\"#2-安装依赖\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-安装依赖\" class=\"headerlink\" title=\"2. 安装依赖\"></a>2. 安装依赖</h4>\n      <pre><code>npm install echarts\n</code></pre>\n\n        <h5 id=\"3-页面拆分\">\n          <a href=\"#3-页面拆分\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-页面拆分\" class=\"headerlink\" title=\"3. 页面拆分\"></a>3. 页面拆分</h5>\n      <p>（1）热销商品（基于饼图封装）<br>（2）客户分布（基于地图封装）<br>（3）销售数据（基于柱图封装）<br>（4）库存分析（基于饼图封装）<br>（5）销售走势（基于折线图封装）<br>（6）商家统计（基于柱图封装）</p>\n\n        <h5 id=\"4-热销商品组件开发\">\n          <a href=\"#4-热销商品组件开发\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-热销商品组件开发\" class=\"headerlink\" title=\"4. 热销商品组件开发\"></a>4. 热销商品组件开发</h5>\n      <pre><code>&lt;template&gt;\n    &lt;div class=&quot;c-container&quot;&gt;\n        &lt;div ref=&quot;hot_ref&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default &#123;\n    data () &#123;\n        return &#123;\n            initOption: &#123;\n                title: &#123;\n                    text: &#39;热销商品销售统计&#39;,\n                    top: 20,\n                    left: 20\n                &#125;,\n                legend: &#123;\n                    top: &#39;20%&#39;,\n                    icon: &#39;circle&#39;\n                &#125;,\n                tooltip: &#123;\n                    show: true\n                &#125;,\n                series: [\n                    &#123;\n                        type: &#39;pie&#39;,\n                        label: &#123;\n                            show: false\n                        &#125;\n                    &#125;\n                ]\n            &#125;,\n            timer,\n            chartInstance: null,\n            currentIndex: 0\n        &#125;\n    &#125;,\n    methods: &#123;\n        // 初始化\n        initChart () &#123;\n            this.chartInstance = this.$echarts.init(this.$refs.hot_ref, &#39;chalk&#39;)\n        &#125;,\n        // 动态展示数据\n        updateChart () &#123;\n            this.chartInstance.setOption(updateOption)\n        &#125;,\n        // 自适应窗口改变\n        updateScreen () &#123;\n            const titleFontSize = this.$refs.hot_ref.offsetWidth / 100 * 3.6\n            const screenOption = &#123;\n                title: &#123;\n                    textStyle: &#123;\n                        textStyle: &#123;\n                            fontSize: titleFontSize / 1.5\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;,\n        startInterval () &#123;\n            if (this.timer) &#123;\n                clearInterval(this.timer)\n            &#125;\n            this.timer = setInterval(() =&gt; &#123;\n                this.currentIndex++\n                if (this.currentIndex &gt; this.allData.length - 1) &#123;\n                    this.currentIndex = 0\n                &#125;\n                this.updateChart()\n            &#125;, 2000)\n        &#125;\n    &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"\n        <h5 id=\"1-创建项目\">\n          <a href=\"#1-创建项目\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#1-创建项目\" class=\"headerlink\" title=\"1. 创建项目\"></a>1. 创建项目</h5>\n      <pre><code>vue create datav\n</code></pre>\n\n        <h4 id=\"2-安装依赖\">\n          <a href=\"#2-安装依赖\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#2-安装依赖\" class=\"headerlink\" title=\"2. 安装依赖\"></a>2. 安装依赖</h4>\n      <pre><code>npm install echarts\n</code></pre>\n\n        <h5 id=\"3-页面拆分\">\n          <a href=\"#3-页面拆分\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#3-页面拆分\" class=\"headerlink\" title=\"3. 页面拆分\"></a>3. 页面拆分</h5>\n      <p>（1）热销商品（基于饼图封装）<br>（2）客户分布（基于地图封装）<br>（3）销售数据（基于柱图封装）<br>（4）库存分析（基于饼图封装）<br>（5）销售走势（基于折线图封装）<br>（6）商家统计（基于柱图封装）</p>\n\n        <h5 id=\"4-热销商品组件开发\">\n          <a href=\"#4-热销商品组件开发\" class=\"heading-link\"><i class=\"fas fa-link\"></i></a><a href=\"#4-热销商品组件开发\" class=\"headerlink\" title=\"4. 热销商品组件开发\"></a>4. 热销商品组件开发</h5>\n      <pre><code>&lt;template&gt;\n    &lt;div class=&quot;c-container&quot;&gt;\n        &lt;div ref=&quot;hot_ref&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default &#123;\n    data () &#123;\n        return &#123;\n            initOption: &#123;\n                title: &#123;\n                    text: &#39;热销商品销售统计&#39;,\n                    top: 20,\n                    left: 20\n                &#125;,\n                legend: &#123;\n                    top: &#39;20%&#39;,\n                    icon: &#39;circle&#39;\n                &#125;,\n                tooltip: &#123;\n                    show: true\n                &#125;,\n                series: [\n                    &#123;\n                        type: &#39;pie&#39;,\n                        label: &#123;\n                            show: false\n                        &#125;\n                    &#125;\n                ]\n            &#125;,\n            timer,\n            chartInstance: null,\n            currentIndex: 0\n        &#125;\n    &#125;,\n    methods: &#123;\n        // 初始化\n        initChart () &#123;\n            this.chartInstance = this.$echarts.init(this.$refs.hot_ref, &#39;chalk&#39;)\n        &#125;,\n        // 动态展示数据\n        updateChart () &#123;\n            this.chartInstance.setOption(updateOption)\n        &#125;,\n        // 自适应窗口改变\n        updateScreen () &#123;\n            const titleFontSize = this.$refs.hot_ref.offsetWidth / 100 * 3.6\n            const screenOption = &#123;\n                title: &#123;\n                    textStyle: &#123;\n                        textStyle: &#123;\n                            fontSize: titleFontSize / 1.5\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;,\n        startInterval () &#123;\n            if (this.timer) &#123;\n                clearInterval(this.timer)\n            &#125;\n            this.timer = setInterval(() =&gt; &#123;\n                this.currentIndex++\n                if (this.currentIndex &gt; this.allData.length - 1) &#123;\n                    this.currentIndex = 0\n                &#125;\n                this.updateChart()\n            &#125;, 2000)\n        &#125;\n    &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n"},{"title":"前端工程化最佳实践","date":"2021-11-20T08:15:01.000Z","_content":"\n##### 1. 历史变革\n（1）前端的历史变革\n- B/S 架构兴起，进而有了前端、后端之分\n- 随着前端复杂度的上升，模块复用、实践规范越来越重要\n- 为了管理和简化前端开发过程，前端框架、自动化、构建系统应运而生并发展迅猛\n- 基于行业最佳实践，开箱即用的框架（如dva）、工具体系等逐渐建立起来\n\n（2）工程化体系的历史衍变\n- 前端框架：插件化（jQuery） -> 模块化（RequireJS） -> 组件化（React\n- 构建工具：任务化（grunt/gulp） -> 系统化（webpack）\n- CI/CD：工具化（Jenkins） -> 自动化（Web Hook）\n\n##### 2. 前端开发工作流\n- 开发\n- 测试\n- 构建\n- 部署\n- 监控\n\n##### 3. 最佳实践\n（1）开发阶段\n- 脚手架：创建前端应用的目录结构，并生成样板代码\n- 公共库：维护着可复用的 UI 组件、工具模块等公共资源\n- 包管理器：引入第三方库/组件，并跟踪管理这些依赖项\n- 编辑器：提供语法高亮、智能提示、引用跳转等功能，提升开发体验\n- 构建工具：提供语法校验、编译、打包、DevServer 等功能，简化工作流\n- 调试套件：提供预览、DevTools、Mock、性能分析诊断等调试功能，加速修改-验证的主循环\n\n（2）测试阶段\n- 单元测试框架：提供针对组件、逻辑的测试支持\n- 静态扫描工具：从代码质量、构建产物质量、最佳实践/开发规约等多个维度做静态检查\n- 自动化测试工具：针对 UI 效果和业务流程，提供测试支持\n- 性能测试工具：监测并统计出相对准确的性能数据\n\n（3）构建阶段\n- 打包脚本：在语法校验、编译、打包的基础上，进行合并、压缩、代码拆分、图片处理、SSR等极限优化\n- 构建服务：支持多任务并行打包、通知\n\n（4）部署阶段\n- 发布平台：将前端资源上传至 CDN 或 SSR 渲染服务，或者以离线包的形式集成到移动客户端\n- 迭代管理平台：提供 CI/CD 支持\n\n（5）监控阶段\n- 埋点平台：统计、分析业务数据，跟踪性能指标\n- 监控平台：观察线上的异常信息，包括报错、白屏、流量异常等\n","source":"_posts/前端工程化最佳实践.md","raw":"---\ntitle: 前端工程化最佳实践\ndate: 2021-11-20 16:15:01\ntags:\n---\n\n##### 1. 历史变革\n（1）前端的历史变革\n- B/S 架构兴起，进而有了前端、后端之分\n- 随着前端复杂度的上升，模块复用、实践规范越来越重要\n- 为了管理和简化前端开发过程，前端框架、自动化、构建系统应运而生并发展迅猛\n- 基于行业最佳实践，开箱即用的框架（如dva）、工具体系等逐渐建立起来\n\n（2）工程化体系的历史衍变\n- 前端框架：插件化（jQuery） -> 模块化（RequireJS） -> 组件化（React\n- 构建工具：任务化（grunt/gulp） -> 系统化（webpack）\n- CI/CD：工具化（Jenkins） -> 自动化（Web Hook）\n\n##### 2. 前端开发工作流\n- 开发\n- 测试\n- 构建\n- 部署\n- 监控\n\n##### 3. 最佳实践\n（1）开发阶段\n- 脚手架：创建前端应用的目录结构，并生成样板代码\n- 公共库：维护着可复用的 UI 组件、工具模块等公共资源\n- 包管理器：引入第三方库/组件，并跟踪管理这些依赖项\n- 编辑器：提供语法高亮、智能提示、引用跳转等功能，提升开发体验\n- 构建工具：提供语法校验、编译、打包、DevServer 等功能，简化工作流\n- 调试套件：提供预览、DevTools、Mock、性能分析诊断等调试功能，加速修改-验证的主循环\n\n（2）测试阶段\n- 单元测试框架：提供针对组件、逻辑的测试支持\n- 静态扫描工具：从代码质量、构建产物质量、最佳实践/开发规约等多个维度做静态检查\n- 自动化测试工具：针对 UI 效果和业务流程，提供测试支持\n- 性能测试工具：监测并统计出相对准确的性能数据\n\n（3）构建阶段\n- 打包脚本：在语法校验、编译、打包的基础上，进行合并、压缩、代码拆分、图片处理、SSR等极限优化\n- 构建服务：支持多任务并行打包、通知\n\n（4）部署阶段\n- 发布平台：将前端资源上传至 CDN 或 SSR 渲染服务，或者以离线包的形式集成到移动客户端\n- 迭代管理平台：提供 CI/CD 支持\n\n（5）监控阶段\n- 埋点平台：统计、分析业务数据，跟踪性能指标\n- 监控平台：观察线上的异常信息，包括报错、白屏、流量异常等\n","slug":"前端工程化最佳实践","published":1,"updated":"2021-12-20T08:45:02.612Z","_id":"ckxe93wqx0000w518elj746rb","comments":1,"layout":"post","photos":[],"link":"","content":"<h5 id=\"1-历史变革\"><a href=\"#1-历史变革\" class=\"headerlink\" title=\"1. 历史变革\"></a>1. 历史变革</h5><p>（1）前端的历史变革</p>\n<ul>\n<li>B/S 架构兴起，进而有了前端、后端之分</li>\n<li>随着前端复杂度的上升，模块复用、实践规范越来越重要</li>\n<li>为了管理和简化前端开发过程，前端框架、自动化、构建系统应运而生并发展迅猛</li>\n<li>基于行业最佳实践，开箱即用的框架（如dva）、工具体系等逐渐建立起来</li>\n</ul>\n<p>（2）工程化体系的历史衍变</p>\n<ul>\n<li>前端框架：插件化（jQuery） -&gt; 模块化（RequireJS） -&gt; 组件化（React</li>\n<li>构建工具：任务化（grunt/gulp） -&gt; 系统化（webpack）</li>\n<li>CI/CD：工具化（Jenkins） -&gt; 自动化（Web Hook）</li>\n</ul>\n<h5 id=\"2-前端开发工作流\"><a href=\"#2-前端开发工作流\" class=\"headerlink\" title=\"2. 前端开发工作流\"></a>2. 前端开发工作流</h5><ul>\n<li>开发</li>\n<li>测试</li>\n<li>构建</li>\n<li>部署</li>\n<li>监控</li>\n</ul>\n<h5 id=\"3-最佳实践\"><a href=\"#3-最佳实践\" class=\"headerlink\" title=\"3. 最佳实践\"></a>3. 最佳实践</h5><p>（1）开发阶段</p>\n<ul>\n<li>脚手架：创建前端应用的目录结构，并生成样板代码</li>\n<li>公共库：维护着可复用的 UI 组件、工具模块等公共资源</li>\n<li>包管理器：引入第三方库/组件，并跟踪管理这些依赖项</li>\n<li>编辑器：提供语法高亮、智能提示、引用跳转等功能，提升开发体验</li>\n<li>构建工具：提供语法校验、编译、打包、DevServer 等功能，简化工作流</li>\n<li>调试套件：提供预览、DevTools、Mock、性能分析诊断等调试功能，加速修改-验证的主循环</li>\n</ul>\n<p>（2）测试阶段</p>\n<ul>\n<li>单元测试框架：提供针对组件、逻辑的测试支持</li>\n<li>静态扫描工具：从代码质量、构建产物质量、最佳实践/开发规约等多个维度做静态检查</li>\n<li>自动化测试工具：针对 UI 效果和业务流程，提供测试支持</li>\n<li>性能测试工具：监测并统计出相对准确的性能数据</li>\n</ul>\n<p>（3）构建阶段</p>\n<ul>\n<li>打包脚本：在语法校验、编译、打包的基础上，进行合并、压缩、代码拆分、图片处理、SSR等极限优化</li>\n<li>构建服务：支持多任务并行打包、通知</li>\n</ul>\n<p>（4）部署阶段</p>\n<ul>\n<li>发布平台：将前端资源上传至 CDN 或 SSR 渲染服务，或者以离线包的形式集成到移动客户端</li>\n<li>迭代管理平台：提供 CI/CD 支持</li>\n</ul>\n<p>（5）监控阶段</p>\n<ul>\n<li>埋点平台：统计、分析业务数据，跟踪性能指标</li>\n<li>监控平台：观察线上的异常信息，包括报错、白屏、流量异常等</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"1-历史变革\"><a href=\"#1-历史变革\" class=\"headerlink\" title=\"1. 历史变革\"></a>1. 历史变革</h5><p>（1）前端的历史变革</p>\n<ul>\n<li>B/S 架构兴起，进而有了前端、后端之分</li>\n<li>随着前端复杂度的上升，模块复用、实践规范越来越重要</li>\n<li>为了管理和简化前端开发过程，前端框架、自动化、构建系统应运而生并发展迅猛</li>\n<li>基于行业最佳实践，开箱即用的框架（如dva）、工具体系等逐渐建立起来</li>\n</ul>\n<p>（2）工程化体系的历史衍变</p>\n<ul>\n<li>前端框架：插件化（jQuery） -&gt; 模块化（RequireJS） -&gt; 组件化（React</li>\n<li>构建工具：任务化（grunt/gulp） -&gt; 系统化（webpack）</li>\n<li>CI/CD：工具化（Jenkins） -&gt; 自动化（Web Hook）</li>\n</ul>\n<h5 id=\"2-前端开发工作流\"><a href=\"#2-前端开发工作流\" class=\"headerlink\" title=\"2. 前端开发工作流\"></a>2. 前端开发工作流</h5><ul>\n<li>开发</li>\n<li>测试</li>\n<li>构建</li>\n<li>部署</li>\n<li>监控</li>\n</ul>\n<h5 id=\"3-最佳实践\"><a href=\"#3-最佳实践\" class=\"headerlink\" title=\"3. 最佳实践\"></a>3. 最佳实践</h5><p>（1）开发阶段</p>\n<ul>\n<li>脚手架：创建前端应用的目录结构，并生成样板代码</li>\n<li>公共库：维护着可复用的 UI 组件、工具模块等公共资源</li>\n<li>包管理器：引入第三方库/组件，并跟踪管理这些依赖项</li>\n<li>编辑器：提供语法高亮、智能提示、引用跳转等功能，提升开发体验</li>\n<li>构建工具：提供语法校验、编译、打包、DevServer 等功能，简化工作流</li>\n<li>调试套件：提供预览、DevTools、Mock、性能分析诊断等调试功能，加速修改-验证的主循环</li>\n</ul>\n<p>（2）测试阶段</p>\n<ul>\n<li>单元测试框架：提供针对组件、逻辑的测试支持</li>\n<li>静态扫描工具：从代码质量、构建产物质量、最佳实践/开发规约等多个维度做静态检查</li>\n<li>自动化测试工具：针对 UI 效果和业务流程，提供测试支持</li>\n<li>性能测试工具：监测并统计出相对准确的性能数据</li>\n</ul>\n<p>（3）构建阶段</p>\n<ul>\n<li>打包脚本：在语法校验、编译、打包的基础上，进行合并、压缩、代码拆分、图片处理、SSR等极限优化</li>\n<li>构建服务：支持多任务并行打包、通知</li>\n</ul>\n<p>（4）部署阶段</p>\n<ul>\n<li>发布平台：将前端资源上传至 CDN 或 SSR 渲染服务，或者以离线包的形式集成到移动客户端</li>\n<li>迭代管理平台：提供 CI/CD 支持</li>\n</ul>\n<p>（5）监控阶段</p>\n<ul>\n<li>埋点平台：统计、分析业务数据，跟踪性能指标</li>\n<li>监控平台：观察线上的异常信息，包括报错、白屏、流量异常等</li>\n</ul>\n"},{"title":"vue原理初探","date":"2021-06-29T06:57:18.000Z","_content":"##### 1.先看一张图\n![vue原理](vue原理1.png)","source":"_posts/vue原理初探.md","raw":"---\ntitle: vue原理初探\ndate: 2021-6-29 14:57:18\ntags:\n---\n##### 1.先看一张图\n![vue原理](vue原理1.png)","slug":"vue原理初探","published":1,"updated":"2021-12-20T08:10:25.698Z","_id":"ckxedq6200001w518a8404oav","comments":1,"layout":"post","photos":[],"link":"","content":"<h5 id=\"1-先看一张图\"><a href=\"#1-先看一张图\" class=\"headerlink\" title=\"1.先看一张图\"></a>1.先看一张图</h5><p><img src=\"/2021/06/29/vue%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/vue%E5%8E%9F%E7%90%861.png\" alt=\"vue原理\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"1-先看一张图\"><a href=\"#1-先看一张图\" class=\"headerlink\" title=\"1.先看一张图\"></a>1.先看一张图</h5><p><img src=\"/2021/06/29/vue%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/vue%E5%8E%9F%E7%90%861.png\" alt=\"vue原理\"></p>\n"},{"title":"vue组件库开发","date":"2021-10-29T06:21:06.000Z","_content":"","source":"_posts/如何用vue造轮子.md","raw":"---\ntitle: vue组件库开发\ndate: 2021-10-29 14:21:06\ntags:\n---\n","slug":"如何用vue造轮子","published":1,"updated":"2021-12-20T07:55:14.833Z","_id":"ckxedv6td0002w518215hau3l","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"快速入门vue","date":"2021-10-31T13:19:30.000Z","_content":"\n1. vue简介\n    Vue是一套用于构建用户界面的渐进式框架，Vue能够为复杂的单页面应用提供驱动\n\n2. 安装\n（1）CDN引入\n```\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2\"></script>\n```\n\n（2）脚手架工具vue-cli\n```\n// 全局安装vue-cli\nnpm install vue-cli -g\n\n// create vue project\nvue init wepack demo-name   // for vue-cli@2.x\n\nor\n\nvue create  // for vue-cli@3.x\n```\n\n3. Vue实例\n```\nvar data = {a: 1}\nvar vm = new Vue({\n    data: data\n})\n```\n\n4. 生命周期\n![vue生命周期](lifecycle.png)\n\n5. 插值（Mustache）\n数据绑定最常见的形式就是使用'Mustache'语法（双大括号）的文本插值\n```\n<span>{{Message: {{msg}}}}</span>\n```\n\n6. 指令\n指定（Directives）是带有v-前缀的特殊attribute，指令的指责是，当表达式的值改变时，\n将其产生的连带影响，响应式的用于DOM\nv-on    // 缩写 :\nv-bind  // 缩写 @\nv-if\nv-else\nv-else-if\nv-html\nv-for\nv-show\n\n7. 修饰符\n.prevent\n\n8. 计算属性(computed)\n计算属性\n```\nvar vm = new Vue({\n    el: '#app',\n    data: {\n        message: 'Hello'\n    },\n    computed: {\n        reversedMessage: function () {\n            // this指向vm实例\n            return this.message.split('').reverse().join('')\n        }\n    }\n})\n```\n\n9. 侦听器\n\n```\n<div id=\"app\">\n    <p>\n        Ask a yes/no question\n        <input v-model=\"question\" />\n    </p>\n</div>\n\nvar vm = new Vue({\n    el: '#app',\n    data () {\n        return {\n            question: '',\n            answer: 'I cannot give you an answer until you ask a question!'\n        }\n    },\n    created () {\n        this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n    },\n    watch: {\n        question: function (newQuestion, oldQuestion) {\n            this.answer = 'Waiting for you to stop typing...'\n            this.debouncedGetAnswer()\n        }\n    },\n    methods: {\n        getAnsswer: function () {\n            if (this.question.indexOf('?') === -1) {\n                this.answer = ''Questions usually contain a question mark. ;-)'\n                return \n            }\n            this.answer = 'Thinking...'\n            var vm = this\n            axios.get('').then(res => {\n                vm.answer = _.capitalize(response.data.answer)\n            }).catch(error => {\n                vm.answer = 'Error! Could not reach the API. ' + error\n            })\n        }\n    }\n})\n```\n\n10. class与style绑定\n内联\n\n```\n<div :class=\"{active: isActive}\"></div>\n\ndata: {\n    isActive: true\n}\n```\n\n对象\n\n```\n<div :class=\"classObject\"></div>\n\ndata: {\n    classObject: {\n        active\" true,\n        'text-danger': false\n    }\n}\n```\n\n计算属性\n\n```\n<div :class=\"classObject\"></div>\n\ndata: {\n    isActive: true,\n    error: null\n}\n\ncomputed: {\n    classObject: function () {\n        return {\n            active: this.isActive && !this.error,\n            'text-danger': this.error && this.error.type === 'fatal'\n        }\n    }\n}\n\n```\n\n数组\n\n```\n<div v-bind:class=\"[activeClass, errorClass]\"></div>\n\ndata: {\n    activeClass: 'active',\n    errorClass: 'text-danger'\n}\n```\n\n三元表达式\n\n```\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n数组中使用对象\n```\n<div v-bind:class=\"[{ active: isActive }, errorClass]\"></div>\n```\n\n\n11. 条件渲染\nv-if指令用于条件性地渲染一块内容\n\n```\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\n```\n\n总结：\n    不建议v-if与v-for一起使用，v-for具有比v-if更高的优先级，\n\n\n12. 列表渲染\n\n```\n<ul>\n    <li v-for=\"item in items\" :key=\"item.message\">\n        {{item.message}}\n    </li>\n</ul>\n```\n\n总结：\n（1）建议给每个遍历项添加一个唯一的key，且不是下标\n（2）不建议v-for, v-if在上同一个元素上同时使用\n（3）v-for的优先级高于v-if\n\n13. 事件处理（v-on）\n用v-on指令监听DOM事件\n\n```\n<div id=\"app\">\n    <button v-on:click=\"greet\">Greet</button>\n</div>\n\nvar app = new Vue({\n    el: '#app',\n    data: {\n        name: 'Vue.js'\n    },\n    methods: {\n        greet: function (event) {\n            if (event) {\n                alert(event.target.tagName)\n            }\n        }\n    }\n})\n```\n\n事件修饰符：\n.stop\n.prevent\n.capture\n.self\n.once\n.passive\n.enter\n.tab\n.delete\n.esc\n.space\n.up\n.down\n.left\n.right\n\n```\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n\n<!-- 修饰符可以串联 -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n\n<!-- 添加事件监听器时使用事件捕获模式 -->\n<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->\n<div v-on:click.capture=\"doThis\">...</div>\n\n<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->\n<!-- 即事件不是从内部元素触发的 -->\n<div v-on:click.self=\"doThat\">...</div>\n```\n\n14. 表单输入绑定（v-model）\nv-model\n\n```\n// 文本\n<input v-model=\"message\" />\n<p>Message is: {{message}}</p>\n\n// 复选框\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n<label for=\"checkbox\">{{ checked }}</label>\n```\n\n修饰符：\n.lazy   在“change”时而非“input”时更新\n.trim   自动过滤用户输入的首尾空白字符\n.number 将用户的输入值转为数值类型\n```\n<input v-model.lazy=\"msg\">\n\n<input v-model.number=\"age\" type=\"number\">\n\n<input v-model.trim=\"msg\">\n```\n\n15. 组件\n（1）组件命名\n- 使用 kebab-case\n\n```\nVue.component('my-component-name', { /* ... */ })\n\n/*\n当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 <my-component-name>\n*/ \n```\n\n- 使用 PascalCase\n\n```\nVue.component('MyComponentName', { /* ... */ })\n\n/*\n当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <my-component-name> 和 <MyComponentName> 都是可接受的\n*/\n```\n\n（2）通过props向子组件传递数据\n- Prop命名\n\n```\nVue.component('blog-post', {\n  // 在 JavaScript 中是 camelCase 的\n  props: ['postTitle'],\n  template: '<h3>{{ postTitle }}</h3>'\n})\n\n<!-- 在 HTML 中是 kebab-case 的 -->\n<blog-post post-title=\"hello!\"></blog-post>\n```\n\n- Prop类型\n通常你希望每个 prop 都有指定的值类型，这时，你可以以对象形式列出 prop\n\n```\nprops: ['title', 'likes', 'isPublished', 'commentIds', 'author']\n\nprops: {\n  title: String,\n  likes: Number,\n  isPublished: Boolean,\n  commentIds: Array,\n  author: Object,\n  callback: Function,\n  contactsPromise: Promise // or any other constructor\n}\n```\n\n- 传递静态或动态Prop\n静态Prop\n\n```\n<blog-post title=\"My journey with Vue\"></blog-post>\n```\n\n动态Prop\n\n```\n<!-- 动态赋予一个变量的值 -->\n<blog-post v-bind:title=\"post.title\"></blog-post>\n\n<!-- 动态赋予一个复杂表达式的值 -->\n<blog-post\n  v-bind:title=\"post.title + ' by ' + post.author.name\"\n></blog-post>\n```\n\n传入数字\n\n```\n<!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post v-bind:likes=\"42\"></blog-post\n```\n\n传入布尔值\n\n```\n<!-- 包含该 prop 没有值的情况在内，都意味着 `true`。-->\n<blog-post is-published></blog-post>\n\n<!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post v-bind:is-published=\"false\"></blog-post>\n```\n\n传入数组\n\n```\n<!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post v-bind:comment-ids=\"[234, 266, 273]\"></blog-post>\n```\n\n传入对象\n\n```\n<!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post\n  v-bind:author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n></blog-post>\n```\n\n\n- 单向数据流\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理，你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告\n\n- Prop验证\ntype类型：String、Number、Boolean、Array、Object、Date、Function、Symbol\n\n```\nVue.component('my-component', {\n  props: {\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\n    propA: Number,\n    // 多个可能的类型\n    propB: [String, Number],\n    // 必填的字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 带有默认值的数字\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 带有默认值的对象\n    propE: {\n      type: Object,\n      // 对象或数组默认值必须从一个工厂函数获取\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        // 这个值必须匹配下列字符串中的一个\n        return ['success', 'warning', 'danger'].indexOf(value) !== -1\n      }\n    }\n  }\n})\n```\n\n（2）通过$emit监听子组件事件\n\n```\n// 父组件\n<blog-post\n  ...\n  v-on:enlarge-text=\"postFontSize += 0.1\"\n></blog-post>\n\n// 子组件\n<button v-on:click=\"$emit('enlarge-text')\">\n  Enlarge text\n</button>\n```\n\n- $emit参数\n\n```\n// 父组件\n<blog-post\n  ...\n  v-on:enlarge-text=\"onEnlargeText\"\n></blog-post>\n\nmethods: {\n    onEnlargeText (enlargeAmount) {\n        this.postFontSize += enlargeAmount\n    }\n}\n\n// 子组件\n<button v-on:click=\"$emit('enlarge-text', 0.1)\">\n  Enlarge text\n</button>\n```\n\n（3）插槽slot\n一套内容分发的 API\n\n```\n<navigation-link url=\"/profile\">\n  Your Profile\n</navigation-link>\n\n// navigation-link\n<a\n  v-bind:href=\"url\"\n  class=\"nav-link\"\n>\n  <slot></slot>\n</a>\n\n// 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。\n```\n\n- 具名插槽\n\n```\n// 定义插槽\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n\n// 使用插槽\n<base-layout>\n  <template v-slot:header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template v-slot:footer>\n    <p>Here's some contact info</p>\n  </template>\n</base-layout>\n```\n\n- 作用域插槽\n\n```\n// 子组件\n<span>\n  <slot v-bind:user=\"user\">\n    {{ user.lastName }}\n  </slot>\n</span>\n\n// 父组件\n<current-user>\n  <template v-slot:default=\"slotProps\">\n    {{ slotProps.user.firstName }}\n  </template>\n</current-user>\n```\n\n\n（4）动态组件\n总结：\n（1）组件的data必须一个函数\n\n16. 自定义事件\n\n17. 进入离开列表过渡\n\n18. 混入\n\n```\nvar myMixin = {\n    created: function () {\n        this.hello()\n    },\n    methods: {\n        hello: function () {\n            console.log('hello')\n        }\n    }\n}\n\nvar Component = Vue.extend({\n    mixins: [myMixin]\n})\n```\n\n19. 自定义指令\n\n```\nVue.directive('focus', {\n    // / 当被绑定的元素插入到 DOM 中时……\n    inserted: function (el) {\n        // 聚焦元素\n    el.focus()\n        el.focus()\n    }\n})\n```\n\n钩子函数：\nbind    只调用一次，指令第一次绑定到元素时调用\ninserted    被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)\nupdate  所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前\ncomponentUpdated    指令所在组件的 VNode 及其子 VNode 全部更新后调用\nunbind  只调用一次，指令与元素解绑时调用\n\n钩子函数参数\nel：指令所绑定的元素，可以用来直接操作 DOM\nbinding：一个对象，包含以下 property\n    name：指令名，不包括 v- 前缀\n    value：指令绑定的值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2\n    oldValue：指定绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用\n    expression：字符串形式的指定表达式，例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"\n    arg：传给指令的参数，例如 v-my-directive:foo 中，参数为 \"foo\"\n    modifers：一个包含修饰符的对象，如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }\nvnode：Vue 编译生成的虚拟节点\noldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用\n\n一个例子\n\n```\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"></div>\n\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +   //demo\n      'value: '      + s(binding.value) + '<br>' +  // hello\n      'expression: ' + s(binding.expression) + '<br>' + // message\n      'argument: '   + s(binding.arg) + '<br>' +    //foo\n      'modifiers: '  + s(binding.modifiers) + '<br>' +  //{\"a\": true, \"b\": true}\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\n\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n```\n\n\n##### 20. Render & JSX\nVue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用渲染函数，它比模板更接近编译器\n\n```\nVue.component('anchored-heading', {\n  render: function (createElement) {\n    return createElement(\n      'h' + this.level,   // 标签名称\n      this.$slots.default // 子节点数组\n    )\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\n- 节点、树以及虚拟 DOM\n\n```\n<h1>{{ blogTitle }}</h1>\n\n渲染函数\n\nrender: function (createElement) {\n  return createElement('h1', this.blogTitle)\n}\n```\n\n- createElement 参数\n\n```\n// @returns {VNode}\ncreateElement(\n  // {String | Object | Function}\n  // 一个 HTML 标签名、组件选项对象，或者\n  // resolve 了上述任何一种的一个 async 函数。必填项。\n  'div',\n\n  // {Object}\n  // 一个与模板中 attribute 对应的数据对象。可选。\n  {\n    // (详情见下一节)\n  },\n\n  // {String | Array}\n  // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，\n  // 也可以使用字符串来生成“文本虚拟节点”。可选。\n  [\n    '先写一些文字',\n    createElement('h1', '一则头条'),\n    createElement(MyComponent, {\n      props: {\n        someProp: 'foobar'\n      }\n    })\n  ]\n)\n```\n\n##### 21. 插件\n（1）插件是什么？\n    插件通常用来为 Vue 添加全局功能\n（2）怎么用？\n    通过全局方法 Vue.use() 使用插件，它需要在你调用 new Vue() 启动应用之前完成\n\n```\n// 调用 `MyPlugin.install(Vue)`\nVue.use(MyPlugin)\n\nnew Vue({\n  // ...组件选项\n})\n```\n\n（3）开发插件\nVue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：\n\n```\nMyPlugin.install = function (Vue, options) {\n  // 1. 添加全局方法或 property\n  Vue.myGlobalMethod = function () {\n    // 逻辑...\n  }\n\n  // 2. 添加全局资源\n  Vue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 3. 注入组件选项\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function (methodOptions) {\n    // 逻辑...\n  }\n}\n```\n\n##### 22. 过滤器\nVue.js 允许你自定义过滤器，可被用于一些常见的文本格式化\n\n```\n<!-- 在双花括号中 -->\n{{ message | capitalize}}\n\n<!-- 在 `v-bind` 中 -->\n<div v-bind:id=\"rawId | formatId\"></div>\n\nfilters: {\n    capitalize: function (value) {\n        if (!value) {\n            value = value.toString()\n            return value.chartAt(0).toUpperCase() + value.slice(1)\n        }\n    }\n}\n```\n全局注册过滤器\nVue.filter('capitalize', function (value) {\n    if (!value) {\n        value = value.toString()\n        return value.chartAt(0).toUpperCase() + value.slice(1)\n    }\n})\n\n##### 23. 响应式原理\n![vue](vue.png)\n每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染\n\n##### 24. 测试\n（1）官方推荐测试框架Vue Testing Library (@testing-library/vue)\n\n（2）安装\n\n```\nnpm install --save-dev jest @vue/test-utils\n```\n\n（3）添加脚本\n```\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\n\n##### 25. Vue API\n- 实例\n（1）vm.$data\n（2）vm.$props\n（3）vm.$el\n    Vue 实例使用的根 DOM 元素\n（3）vm.$options\n    用于当前 Vue 实例的初始化选项\n\n```\nnew Vue({\n  customOption: 'foo',\n  created: function () {\n    console.log(this.$options.customOption) // => 'foo'\n  }\n})\n```\n\n（4）vm.$parent\n    父实例，如果当前实例有的话\n（5）vm.$root\n    当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己\n（6）$children\n    当前实例的直接子组件\n（7）vm.$slots\n    用来访问被插槽分发的内容\n\n    ```\n    <blog-post>\n        <template v-slot:header>\n            <h1>About Me</h1>\n        </template>\n\n        <p>Here's some page content, which will be included in vm.$slots.default,   because it's not inside a named slot.\n        </p>\n\n        <template v-slot:footer>\n            <p>Copyright 2016 Evan You</p>\n        </template>\n\n        <p>If I have some content down here, it will also be included in            vm.$slots.default.\n        </p>\n    </blog-post>\n    ```\n\n    ```\n    Vue.component('blog-post', {\n        render: function (createElement) {\n            var header = this.$slots.header\n            var body   = this.$slots.default\n            var footer = this.$slots.footer\n            return createElement('div', [\n            createElement('header', header),\n            createElement('main', body),\n            createElement('footer', footer)\n            ])\n        }\n     })\n    ```\n（8）vm.$scopedSlots\n    用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。\n（9）vm.$refs\n    一个对象，持有注册过 ref attribute 的所有 DOM 元素和组件实例\n（10）vm.$isServer\n    当前 Vue 实例是否运行于服务器\n（11）vm.$attrs\n    包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=\"$attrs\" 传入内部组件——在创建高级别的组件时非常有用\n（12）vm.$listeners\n    包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件——在创建更高层次的组件时非常有用\n\n\n- 实例方法\n（1）vm.$watch( expOrFn, callback, [options] )\n    观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。表达式只接受简单的键路径。对于更复杂的表达式，用一个函数取代\n    ```\n        // 键路径\n        vm.$watch('a.b.c', function (newVal, oldVal) {\n        // 做点什么\n        })\n\n        // 函数\n        vm.$watch(\n        function () {\n            // 表达式 `this.a + this.b` 每次得出一个不同的结果时\n            // 处理函数都会被调用。\n            // 这就像监听一个未被定义的计算属性\n            return this.a + this.b\n        },\n        function (newVal, oldVal) {\n            // 做点什么\n        }\n        )\n    ```\n\n    vm.$watch 返回一个取消观察函数，用来停止触发回调：\n\n    ```\n    var unwatch = vm.$watch('a', cb)\n    // 之后取消观察\n    unwatch()\n    ```\n\n    选项：deep\n        为了发现对象内部值的变化，可以在选项参数中指定 deep: true。注意监听数组的变更不需要这么做。\n    ```\n        vm.$watch('someObject', callback, {\n            deep: true\n        })\n        vm.someObject.nestedValue = 123\n        // callback is fired\n    ```\n\n\n    选项：immediate\n        在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调：\n\n    ```\n        vm.$watch('a', callback, {\n            immediate: true\n        })\n        // 立即以 `a` 的当前值触发回调\n    ```\n\n\n（2）vm.$set( target, propertyName/index, value )\n    这是全局 Vue.set 的别名\n\n（3）vm.$delete( target, propertyName/index )\n    这是全局 Vue.delete 的别名\n\n（4）vm.$on( event, callback )\n    监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数\n\n    ```\n    vm.$on('test', function (msg) {\n        console.log(msg)\n    })\n    vm.$emit('test', 'hi')\n    // => \"hi\"\n    ```\n\n（5）$once\n    监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除\n（6）vm.$off( [event, callback] )\n    移除自定义事件监听器\n    - 如果没有提供参数，则移除所有的事件监听器；\n\n    - 如果只提供了事件，则移除该事件所有的监听器；\n\n    - 如果同时提供了事件与回调，则只移除这个回调的监听器。\n\n（7）vm.$emit( eventName, […args] )\n    触发当前实例上的事件。附加参数都会传给监听器回调\n    ```\n    Vue.component('welcome-button', {\n        template: `\n            <button v-on:click=\"$emit('welcome')\">\n                Click me to be welcomed\n            </button>`\n    })\n    ```\n\n    ```\n    <div id=\"emit-example-simple\">\n        <welcome-button @welcome=\"sayHi\"></welcome-button>\n    </div>\n    ```\n\n    ```\n    new Vue({\n        el: '#emit-example-simple',\n        methods: {\n            sayHi: function () {\n            alert('Hi!')\n            }\n        }\n    })\n    ```\n（8）vm.$mount( [elementOrSelector] )\n    如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素可以使用 vm.$mount() 手动地挂载一个未挂载的实例\n\n（9）vm.$nextTick( [callback] )\n    将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上\n\n（10）vm.$destroy()\n     完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器  \n\n（11）vm.$forceUpdate()\n    迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件\n\n","source":"_posts/快速入门vue.md","raw":"---\ntitle: 快速入门vue\ndate: 2021-10-31 21:19:30\ntags:\n---\n\n1. vue简介\n    Vue是一套用于构建用户界面的渐进式框架，Vue能够为复杂的单页面应用提供驱动\n\n2. 安装\n（1）CDN引入\n```\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2\"></script>\n```\n\n（2）脚手架工具vue-cli\n```\n// 全局安装vue-cli\nnpm install vue-cli -g\n\n// create vue project\nvue init wepack demo-name   // for vue-cli@2.x\n\nor\n\nvue create  // for vue-cli@3.x\n```\n\n3. Vue实例\n```\nvar data = {a: 1}\nvar vm = new Vue({\n    data: data\n})\n```\n\n4. 生命周期\n![vue生命周期](lifecycle.png)\n\n5. 插值（Mustache）\n数据绑定最常见的形式就是使用'Mustache'语法（双大括号）的文本插值\n```\n<span>{{Message: {{msg}}}}</span>\n```\n\n6. 指令\n指定（Directives）是带有v-前缀的特殊attribute，指令的指责是，当表达式的值改变时，\n将其产生的连带影响，响应式的用于DOM\nv-on    // 缩写 :\nv-bind  // 缩写 @\nv-if\nv-else\nv-else-if\nv-html\nv-for\nv-show\n\n7. 修饰符\n.prevent\n\n8. 计算属性(computed)\n计算属性\n```\nvar vm = new Vue({\n    el: '#app',\n    data: {\n        message: 'Hello'\n    },\n    computed: {\n        reversedMessage: function () {\n            // this指向vm实例\n            return this.message.split('').reverse().join('')\n        }\n    }\n})\n```\n\n9. 侦听器\n\n```\n<div id=\"app\">\n    <p>\n        Ask a yes/no question\n        <input v-model=\"question\" />\n    </p>\n</div>\n\nvar vm = new Vue({\n    el: '#app',\n    data () {\n        return {\n            question: '',\n            answer: 'I cannot give you an answer until you ask a question!'\n        }\n    },\n    created () {\n        this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n    },\n    watch: {\n        question: function (newQuestion, oldQuestion) {\n            this.answer = 'Waiting for you to stop typing...'\n            this.debouncedGetAnswer()\n        }\n    },\n    methods: {\n        getAnsswer: function () {\n            if (this.question.indexOf('?') === -1) {\n                this.answer = ''Questions usually contain a question mark. ;-)'\n                return \n            }\n            this.answer = 'Thinking...'\n            var vm = this\n            axios.get('').then(res => {\n                vm.answer = _.capitalize(response.data.answer)\n            }).catch(error => {\n                vm.answer = 'Error! Could not reach the API. ' + error\n            })\n        }\n    }\n})\n```\n\n10. class与style绑定\n内联\n\n```\n<div :class=\"{active: isActive}\"></div>\n\ndata: {\n    isActive: true\n}\n```\n\n对象\n\n```\n<div :class=\"classObject\"></div>\n\ndata: {\n    classObject: {\n        active\" true,\n        'text-danger': false\n    }\n}\n```\n\n计算属性\n\n```\n<div :class=\"classObject\"></div>\n\ndata: {\n    isActive: true,\n    error: null\n}\n\ncomputed: {\n    classObject: function () {\n        return {\n            active: this.isActive && !this.error,\n            'text-danger': this.error && this.error.type === 'fatal'\n        }\n    }\n}\n\n```\n\n数组\n\n```\n<div v-bind:class=\"[activeClass, errorClass]\"></div>\n\ndata: {\n    activeClass: 'active',\n    errorClass: 'text-danger'\n}\n```\n\n三元表达式\n\n```\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n数组中使用对象\n```\n<div v-bind:class=\"[{ active: isActive }, errorClass]\"></div>\n```\n\n\n11. 条件渲染\nv-if指令用于条件性地渲染一块内容\n\n```\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\n```\n\n总结：\n    不建议v-if与v-for一起使用，v-for具有比v-if更高的优先级，\n\n\n12. 列表渲染\n\n```\n<ul>\n    <li v-for=\"item in items\" :key=\"item.message\">\n        {{item.message}}\n    </li>\n</ul>\n```\n\n总结：\n（1）建议给每个遍历项添加一个唯一的key，且不是下标\n（2）不建议v-for, v-if在上同一个元素上同时使用\n（3）v-for的优先级高于v-if\n\n13. 事件处理（v-on）\n用v-on指令监听DOM事件\n\n```\n<div id=\"app\">\n    <button v-on:click=\"greet\">Greet</button>\n</div>\n\nvar app = new Vue({\n    el: '#app',\n    data: {\n        name: 'Vue.js'\n    },\n    methods: {\n        greet: function (event) {\n            if (event) {\n                alert(event.target.tagName)\n            }\n        }\n    }\n})\n```\n\n事件修饰符：\n.stop\n.prevent\n.capture\n.self\n.once\n.passive\n.enter\n.tab\n.delete\n.esc\n.space\n.up\n.down\n.left\n.right\n\n```\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n\n<!-- 修饰符可以串联 -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n\n<!-- 添加事件监听器时使用事件捕获模式 -->\n<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->\n<div v-on:click.capture=\"doThis\">...</div>\n\n<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->\n<!-- 即事件不是从内部元素触发的 -->\n<div v-on:click.self=\"doThat\">...</div>\n```\n\n14. 表单输入绑定（v-model）\nv-model\n\n```\n// 文本\n<input v-model=\"message\" />\n<p>Message is: {{message}}</p>\n\n// 复选框\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n<label for=\"checkbox\">{{ checked }}</label>\n```\n\n修饰符：\n.lazy   在“change”时而非“input”时更新\n.trim   自动过滤用户输入的首尾空白字符\n.number 将用户的输入值转为数值类型\n```\n<input v-model.lazy=\"msg\">\n\n<input v-model.number=\"age\" type=\"number\">\n\n<input v-model.trim=\"msg\">\n```\n\n15. 组件\n（1）组件命名\n- 使用 kebab-case\n\n```\nVue.component('my-component-name', { /* ... */ })\n\n/*\n当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 <my-component-name>\n*/ \n```\n\n- 使用 PascalCase\n\n```\nVue.component('MyComponentName', { /* ... */ })\n\n/*\n当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <my-component-name> 和 <MyComponentName> 都是可接受的\n*/\n```\n\n（2）通过props向子组件传递数据\n- Prop命名\n\n```\nVue.component('blog-post', {\n  // 在 JavaScript 中是 camelCase 的\n  props: ['postTitle'],\n  template: '<h3>{{ postTitle }}</h3>'\n})\n\n<!-- 在 HTML 中是 kebab-case 的 -->\n<blog-post post-title=\"hello!\"></blog-post>\n```\n\n- Prop类型\n通常你希望每个 prop 都有指定的值类型，这时，你可以以对象形式列出 prop\n\n```\nprops: ['title', 'likes', 'isPublished', 'commentIds', 'author']\n\nprops: {\n  title: String,\n  likes: Number,\n  isPublished: Boolean,\n  commentIds: Array,\n  author: Object,\n  callback: Function,\n  contactsPromise: Promise // or any other constructor\n}\n```\n\n- 传递静态或动态Prop\n静态Prop\n\n```\n<blog-post title=\"My journey with Vue\"></blog-post>\n```\n\n动态Prop\n\n```\n<!-- 动态赋予一个变量的值 -->\n<blog-post v-bind:title=\"post.title\"></blog-post>\n\n<!-- 动态赋予一个复杂表达式的值 -->\n<blog-post\n  v-bind:title=\"post.title + ' by ' + post.author.name\"\n></blog-post>\n```\n\n传入数字\n\n```\n<!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post v-bind:likes=\"42\"></blog-post\n```\n\n传入布尔值\n\n```\n<!-- 包含该 prop 没有值的情况在内，都意味着 `true`。-->\n<blog-post is-published></blog-post>\n\n<!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post v-bind:is-published=\"false\"></blog-post>\n```\n\n传入数组\n\n```\n<!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post v-bind:comment-ids=\"[234, 266, 273]\"></blog-post>\n```\n\n传入对象\n\n```\n<!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post\n  v-bind:author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n></blog-post>\n```\n\n\n- 单向数据流\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理，你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告\n\n- Prop验证\ntype类型：String、Number、Boolean、Array、Object、Date、Function、Symbol\n\n```\nVue.component('my-component', {\n  props: {\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\n    propA: Number,\n    // 多个可能的类型\n    propB: [String, Number],\n    // 必填的字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 带有默认值的数字\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 带有默认值的对象\n    propE: {\n      type: Object,\n      // 对象或数组默认值必须从一个工厂函数获取\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        // 这个值必须匹配下列字符串中的一个\n        return ['success', 'warning', 'danger'].indexOf(value) !== -1\n      }\n    }\n  }\n})\n```\n\n（2）通过$emit监听子组件事件\n\n```\n// 父组件\n<blog-post\n  ...\n  v-on:enlarge-text=\"postFontSize += 0.1\"\n></blog-post>\n\n// 子组件\n<button v-on:click=\"$emit('enlarge-text')\">\n  Enlarge text\n</button>\n```\n\n- $emit参数\n\n```\n// 父组件\n<blog-post\n  ...\n  v-on:enlarge-text=\"onEnlargeText\"\n></blog-post>\n\nmethods: {\n    onEnlargeText (enlargeAmount) {\n        this.postFontSize += enlargeAmount\n    }\n}\n\n// 子组件\n<button v-on:click=\"$emit('enlarge-text', 0.1)\">\n  Enlarge text\n</button>\n```\n\n（3）插槽slot\n一套内容分发的 API\n\n```\n<navigation-link url=\"/profile\">\n  Your Profile\n</navigation-link>\n\n// navigation-link\n<a\n  v-bind:href=\"url\"\n  class=\"nav-link\"\n>\n  <slot></slot>\n</a>\n\n// 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。\n```\n\n- 具名插槽\n\n```\n// 定义插槽\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n\n// 使用插槽\n<base-layout>\n  <template v-slot:header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template v-slot:footer>\n    <p>Here's some contact info</p>\n  </template>\n</base-layout>\n```\n\n- 作用域插槽\n\n```\n// 子组件\n<span>\n  <slot v-bind:user=\"user\">\n    {{ user.lastName }}\n  </slot>\n</span>\n\n// 父组件\n<current-user>\n  <template v-slot:default=\"slotProps\">\n    {{ slotProps.user.firstName }}\n  </template>\n</current-user>\n```\n\n\n（4）动态组件\n总结：\n（1）组件的data必须一个函数\n\n16. 自定义事件\n\n17. 进入离开列表过渡\n\n18. 混入\n\n```\nvar myMixin = {\n    created: function () {\n        this.hello()\n    },\n    methods: {\n        hello: function () {\n            console.log('hello')\n        }\n    }\n}\n\nvar Component = Vue.extend({\n    mixins: [myMixin]\n})\n```\n\n19. 自定义指令\n\n```\nVue.directive('focus', {\n    // / 当被绑定的元素插入到 DOM 中时……\n    inserted: function (el) {\n        // 聚焦元素\n    el.focus()\n        el.focus()\n    }\n})\n```\n\n钩子函数：\nbind    只调用一次，指令第一次绑定到元素时调用\ninserted    被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)\nupdate  所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前\ncomponentUpdated    指令所在组件的 VNode 及其子 VNode 全部更新后调用\nunbind  只调用一次，指令与元素解绑时调用\n\n钩子函数参数\nel：指令所绑定的元素，可以用来直接操作 DOM\nbinding：一个对象，包含以下 property\n    name：指令名，不包括 v- 前缀\n    value：指令绑定的值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2\n    oldValue：指定绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用\n    expression：字符串形式的指定表达式，例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"\n    arg：传给指令的参数，例如 v-my-directive:foo 中，参数为 \"foo\"\n    modifers：一个包含修饰符的对象，如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }\nvnode：Vue 编译生成的虚拟节点\noldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用\n\n一个例子\n\n```\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"></div>\n\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +   //demo\n      'value: '      + s(binding.value) + '<br>' +  // hello\n      'expression: ' + s(binding.expression) + '<br>' + // message\n      'argument: '   + s(binding.arg) + '<br>' +    //foo\n      'modifiers: '  + s(binding.modifiers) + '<br>' +  //{\"a\": true, \"b\": true}\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\n\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n```\n\n\n##### 20. Render & JSX\nVue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用渲染函数，它比模板更接近编译器\n\n```\nVue.component('anchored-heading', {\n  render: function (createElement) {\n    return createElement(\n      'h' + this.level,   // 标签名称\n      this.$slots.default // 子节点数组\n    )\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\n- 节点、树以及虚拟 DOM\n\n```\n<h1>{{ blogTitle }}</h1>\n\n渲染函数\n\nrender: function (createElement) {\n  return createElement('h1', this.blogTitle)\n}\n```\n\n- createElement 参数\n\n```\n// @returns {VNode}\ncreateElement(\n  // {String | Object | Function}\n  // 一个 HTML 标签名、组件选项对象，或者\n  // resolve 了上述任何一种的一个 async 函数。必填项。\n  'div',\n\n  // {Object}\n  // 一个与模板中 attribute 对应的数据对象。可选。\n  {\n    // (详情见下一节)\n  },\n\n  // {String | Array}\n  // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，\n  // 也可以使用字符串来生成“文本虚拟节点”。可选。\n  [\n    '先写一些文字',\n    createElement('h1', '一则头条'),\n    createElement(MyComponent, {\n      props: {\n        someProp: 'foobar'\n      }\n    })\n  ]\n)\n```\n\n##### 21. 插件\n（1）插件是什么？\n    插件通常用来为 Vue 添加全局功能\n（2）怎么用？\n    通过全局方法 Vue.use() 使用插件，它需要在你调用 new Vue() 启动应用之前完成\n\n```\n// 调用 `MyPlugin.install(Vue)`\nVue.use(MyPlugin)\n\nnew Vue({\n  // ...组件选项\n})\n```\n\n（3）开发插件\nVue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：\n\n```\nMyPlugin.install = function (Vue, options) {\n  // 1. 添加全局方法或 property\n  Vue.myGlobalMethod = function () {\n    // 逻辑...\n  }\n\n  // 2. 添加全局资源\n  Vue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 3. 注入组件选项\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function (methodOptions) {\n    // 逻辑...\n  }\n}\n```\n\n##### 22. 过滤器\nVue.js 允许你自定义过滤器，可被用于一些常见的文本格式化\n\n```\n<!-- 在双花括号中 -->\n{{ message | capitalize}}\n\n<!-- 在 `v-bind` 中 -->\n<div v-bind:id=\"rawId | formatId\"></div>\n\nfilters: {\n    capitalize: function (value) {\n        if (!value) {\n            value = value.toString()\n            return value.chartAt(0).toUpperCase() + value.slice(1)\n        }\n    }\n}\n```\n全局注册过滤器\nVue.filter('capitalize', function (value) {\n    if (!value) {\n        value = value.toString()\n        return value.chartAt(0).toUpperCase() + value.slice(1)\n    }\n})\n\n##### 23. 响应式原理\n![vue](vue.png)\n每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染\n\n##### 24. 测试\n（1）官方推荐测试框架Vue Testing Library (@testing-library/vue)\n\n（2）安装\n\n```\nnpm install --save-dev jest @vue/test-utils\n```\n\n（3）添加脚本\n```\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```\n\n##### 25. Vue API\n- 实例\n（1）vm.$data\n（2）vm.$props\n（3）vm.$el\n    Vue 实例使用的根 DOM 元素\n（3）vm.$options\n    用于当前 Vue 实例的初始化选项\n\n```\nnew Vue({\n  customOption: 'foo',\n  created: function () {\n    console.log(this.$options.customOption) // => 'foo'\n  }\n})\n```\n\n（4）vm.$parent\n    父实例，如果当前实例有的话\n（5）vm.$root\n    当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己\n（6）$children\n    当前实例的直接子组件\n（7）vm.$slots\n    用来访问被插槽分发的内容\n\n    ```\n    <blog-post>\n        <template v-slot:header>\n            <h1>About Me</h1>\n        </template>\n\n        <p>Here's some page content, which will be included in vm.$slots.default,   because it's not inside a named slot.\n        </p>\n\n        <template v-slot:footer>\n            <p>Copyright 2016 Evan You</p>\n        </template>\n\n        <p>If I have some content down here, it will also be included in            vm.$slots.default.\n        </p>\n    </blog-post>\n    ```\n\n    ```\n    Vue.component('blog-post', {\n        render: function (createElement) {\n            var header = this.$slots.header\n            var body   = this.$slots.default\n            var footer = this.$slots.footer\n            return createElement('div', [\n            createElement('header', header),\n            createElement('main', body),\n            createElement('footer', footer)\n            ])\n        }\n     })\n    ```\n（8）vm.$scopedSlots\n    用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。\n（9）vm.$refs\n    一个对象，持有注册过 ref attribute 的所有 DOM 元素和组件实例\n（10）vm.$isServer\n    当前 Vue 实例是否运行于服务器\n（11）vm.$attrs\n    包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=\"$attrs\" 传入内部组件——在创建高级别的组件时非常有用\n（12）vm.$listeners\n    包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件——在创建更高层次的组件时非常有用\n\n\n- 实例方法\n（1）vm.$watch( expOrFn, callback, [options] )\n    观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。表达式只接受简单的键路径。对于更复杂的表达式，用一个函数取代\n    ```\n        // 键路径\n        vm.$watch('a.b.c', function (newVal, oldVal) {\n        // 做点什么\n        })\n\n        // 函数\n        vm.$watch(\n        function () {\n            // 表达式 `this.a + this.b` 每次得出一个不同的结果时\n            // 处理函数都会被调用。\n            // 这就像监听一个未被定义的计算属性\n            return this.a + this.b\n        },\n        function (newVal, oldVal) {\n            // 做点什么\n        }\n        )\n    ```\n\n    vm.$watch 返回一个取消观察函数，用来停止触发回调：\n\n    ```\n    var unwatch = vm.$watch('a', cb)\n    // 之后取消观察\n    unwatch()\n    ```\n\n    选项：deep\n        为了发现对象内部值的变化，可以在选项参数中指定 deep: true。注意监听数组的变更不需要这么做。\n    ```\n        vm.$watch('someObject', callback, {\n            deep: true\n        })\n        vm.someObject.nestedValue = 123\n        // callback is fired\n    ```\n\n\n    选项：immediate\n        在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调：\n\n    ```\n        vm.$watch('a', callback, {\n            immediate: true\n        })\n        // 立即以 `a` 的当前值触发回调\n    ```\n\n\n（2）vm.$set( target, propertyName/index, value )\n    这是全局 Vue.set 的别名\n\n（3）vm.$delete( target, propertyName/index )\n    这是全局 Vue.delete 的别名\n\n（4）vm.$on( event, callback )\n    监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数\n\n    ```\n    vm.$on('test', function (msg) {\n        console.log(msg)\n    })\n    vm.$emit('test', 'hi')\n    // => \"hi\"\n    ```\n\n（5）$once\n    监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除\n（6）vm.$off( [event, callback] )\n    移除自定义事件监听器\n    - 如果没有提供参数，则移除所有的事件监听器；\n\n    - 如果只提供了事件，则移除该事件所有的监听器；\n\n    - 如果同时提供了事件与回调，则只移除这个回调的监听器。\n\n（7）vm.$emit( eventName, […args] )\n    触发当前实例上的事件。附加参数都会传给监听器回调\n    ```\n    Vue.component('welcome-button', {\n        template: `\n            <button v-on:click=\"$emit('welcome')\">\n                Click me to be welcomed\n            </button>`\n    })\n    ```\n\n    ```\n    <div id=\"emit-example-simple\">\n        <welcome-button @welcome=\"sayHi\"></welcome-button>\n    </div>\n    ```\n\n    ```\n    new Vue({\n        el: '#emit-example-simple',\n        methods: {\n            sayHi: function () {\n            alert('Hi!')\n            }\n        }\n    })\n    ```\n（8）vm.$mount( [elementOrSelector] )\n    如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素可以使用 vm.$mount() 手动地挂载一个未挂载的实例\n\n（9）vm.$nextTick( [callback] )\n    将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上\n\n（10）vm.$destroy()\n     完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器  \n\n（11）vm.$forceUpdate()\n    迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件\n\n","slug":"快速入门vue","published":1,"updated":"2021-12-20T08:01:23.692Z","_id":"ckxedwl5b0003w5183tmz5v70","comments":1,"layout":"post","photos":[],"link":"","content":"<ol>\n<li><p>vue简介<br> Vue是一套用于构建用户界面的渐进式框架，Vue能够为复杂的单页面应用提供驱动</p>\n</li>\n<li><p>安装<br>（1）CDN引入</p>\n<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;&gt;&lt;/script&gt;\n</code></pre>\n</li>\n</ol>\n<p>（2）脚手架工具vue-cli</p>\n<pre><code>// 全局安装vue-cli\nnpm install vue-cli -g\n\n// create vue project\nvue init wepack demo-name   // for vue-cli@2.x\n\nor\n\nvue create  // for vue-cli@3.x\n</code></pre>\n<ol start=\"3\">\n<li><p>Vue实例</p>\n<pre><code>var data = &#123;a: 1&#125;\nvar vm = new Vue(&#123;\n data: data\n&#125;)\n</code></pre>\n</li>\n<li><p>生命周期<br><img src=\"/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/lifecycle.png\" alt=\"vue生命周期\"></p>\n</li>\n<li><p>插值（Mustache）<br>数据绑定最常见的形式就是使用’Mustache’语法（双大括号）的文本插值</p>\n<pre><code>&lt;span&gt;&#123;&#123;Message: &#123;&#123;msg&#125;&#125;&#125;&#125;&lt;/span&gt;\n</code></pre>\n</li>\n<li><p>指令<br>指定（Directives）是带有v-前缀的特殊attribute，指令的指责是，当表达式的值改变时，<br>将其产生的连带影响，响应式的用于DOM<br>v-on    // 缩写 :<br>v-bind  // 缩写 @<br>v-if<br>v-else<br>v-else-if<br>v-html<br>v-for<br>v-show</p>\n</li>\n<li><p>修饰符<br>.prevent</p>\n</li>\n<li><p>计算属性(computed)<br>计算属性</p>\n<pre><code>var vm = new Vue(&#123;\n el: &#39;#app&#39;,\n data: &#123;\n     message: &#39;Hello&#39;\n &#125;,\n computed: &#123;\n     reversedMessage: function () &#123;\n         // this指向vm实例\n         return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)\n     &#125;\n &#125;\n&#125;)\n</code></pre>\n</li>\n<li><p>侦听器</p>\n</li>\n</ol>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    &lt;p&gt;\n        Ask a yes/no question\n        &lt;input v-model=&quot;question&quot; /&gt;\n    &lt;/p&gt;\n&lt;/div&gt;\n\nvar vm = new Vue(&#123;\n    el: &#39;#app&#39;,\n    data () &#123;\n        return &#123;\n            question: &#39;&#39;,\n            answer: &#39;I cannot give you an answer until you ask a question!&#39;\n        &#125;\n    &#125;,\n    created () &#123;\n        this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n    &#125;,\n    watch: &#123;\n        question: function (newQuestion, oldQuestion) &#123;\n            this.answer = &#39;Waiting for you to stop typing...&#39;\n            this.debouncedGetAnswer()\n        &#125;\n    &#125;,\n    methods: &#123;\n        getAnsswer: function () &#123;\n            if (this.question.indexOf(&#39;?&#39;) === -1) &#123;\n                this.answer = &#39;&#39;Questions usually contain a question mark. ;-)&#39;\n                return \n            &#125;\n            this.answer = &#39;Thinking...&#39;\n            var vm = this\n            axios.get(&#39;&#39;).then(res =&gt; &#123;\n                vm.answer = _.capitalize(response.data.answer)\n            &#125;).catch(error =&gt; &#123;\n                vm.answer = &#39;Error! Could not reach the API. &#39; + error\n            &#125;)\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n<ol start=\"10\">\n<li>class与style绑定<br>内联</li>\n</ol>\n<pre><code>&lt;div :class=&quot;&#123;active: isActive&#125;&quot;&gt;&lt;/div&gt;\n\ndata: &#123;\n    isActive: true\n&#125;\n</code></pre>\n<p>对象</p>\n<pre><code>&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;\n\ndata: &#123;\n    classObject: &#123;\n        active&quot; true,\n        &#39;text-danger&#39;: false\n    &#125;\n&#125;\n</code></pre>\n<p>计算属性</p>\n<pre><code>&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;\n\ndata: &#123;\n    isActive: true,\n    error: null\n&#125;\n\ncomputed: &#123;\n    classObject: function () &#123;\n        return &#123;\n            active: this.isActive &amp;&amp; !this.error,\n            &#39;text-danger&#39;: this.error &amp;&amp; this.error.type === &#39;fatal&#39;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>数组</p>\n<pre><code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;\n\ndata: &#123;\n    activeClass: &#39;active&#39;,\n    errorClass: &#39;text-danger&#39;\n&#125;\n</code></pre>\n<p>三元表达式</p>\n<pre><code>&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>数组中使用对象</p>\n<pre><code>&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;\n</code></pre>\n<ol start=\"11\">\n<li>条件渲染<br>v-if指令用于条件性地渲染一块内容</li>\n</ol>\n<pre><code>&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;\n&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;\n</code></pre>\n<p>总结：<br>    不建议v-if与v-for一起使用，v-for具有比v-if更高的优先级，</p>\n<ol start=\"12\">\n<li>列表渲染</li>\n</ol>\n<pre><code>&lt;ul&gt;\n    &lt;li v-for=&quot;item in items&quot; :key=&quot;item.message&quot;&gt;\n        &#123;&#123;item.message&#125;&#125;\n    &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>总结：<br>（1）建议给每个遍历项添加一个唯一的key，且不是下标<br>（2）不建议v-for, v-if在上同一个元素上同时使用<br>（3）v-for的优先级高于v-if</p>\n<ol start=\"13\">\n<li>事件处理（v-on）<br>用v-on指令监听DOM事件</li>\n</ol>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;\n&lt;/div&gt;\n\nvar app = new Vue(&#123;\n    el: &#39;#app&#39;,\n    data: &#123;\n        name: &#39;Vue.js&#39;\n    &#125;,\n    methods: &#123;\n        greet: function (event) &#123;\n            if (event) &#123;\n                alert(event.target.tagName)\n            &#125;\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n<p>事件修饰符：<br>.stop<br>.prevent<br>.capture<br>.self<br>.once<br>.passive<br>.enter<br>.tab<br>.delete<br>.esc<br>.space<br>.up<br>.down<br>.left<br>.right</p>\n<pre><code>&lt;!-- 提交事件不再重载页面 --&gt;\n&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;\n\n&lt;!-- 修饰符可以串联 --&gt;\n&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;\n\n&lt;!-- 只有修饰符 --&gt;\n&lt;form v-on:submit.prevent&gt;&lt;/form&gt;\n\n&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;\n&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;\n&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;\n\n&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;\n&lt;!-- 即事件不是从内部元素触发的 --&gt;\n&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;\n</code></pre>\n<ol start=\"14\">\n<li>表单输入绑定（v-model）<br>v-model</li>\n</ol>\n<pre><code>// 文本\n&lt;input v-model=&quot;message&quot; /&gt;\n&lt;p&gt;Message is: &#123;&#123;message&#125;&#125;&lt;/p&gt;\n\n// 复选框\n&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;\n&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;\n</code></pre>\n<p>修饰符：<br>.lazy   在“change”时而非“input”时更新<br>.trim   自动过滤用户输入的首尾空白字符<br>.number 将用户的输入值转为数值类型</p>\n<pre><code>&lt;input v-model.lazy=&quot;msg&quot;&gt;\n\n&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;\n\n&lt;input v-model.trim=&quot;msg&quot;&gt;\n</code></pre>\n<ol start=\"15\">\n<li>组件<br>（1）组件命名</li>\n</ol>\n<ul>\n<li>使用 kebab-case</li>\n</ul>\n<pre><code>Vue.component(&#39;my-component-name&#39;, &#123; /* ... */ &#125;)\n\n/*\n当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 &lt;my-component-name&gt;\n*/ \n</code></pre>\n<ul>\n<li>使用 PascalCase</li>\n</ul>\n<pre><code>Vue.component(&#39;MyComponentName&#39;, &#123; /* ... */ &#125;)\n\n/*\n当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 &lt;my-component-name&gt; 和 &lt;MyComponentName&gt; 都是可接受的\n*/\n</code></pre>\n<p>（2）通过props向子组件传递数据</p>\n<ul>\n<li>Prop命名</li>\n</ul>\n<pre><code>Vue.component(&#39;blog-post&#39;, &#123;\n  // 在 JavaScript 中是 camelCase 的\n  props: [&#39;postTitle&#39;],\n  template: &#39;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#39;\n&#125;)\n\n&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;\n&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;\n</code></pre>\n<ul>\n<li>Prop类型<br>通常你希望每个 prop 都有指定的值类型，这时，你可以以对象形式列出 prop</li>\n</ul>\n<pre><code>props: [&#39;title&#39;, &#39;likes&#39;, &#39;isPublished&#39;, &#39;commentIds&#39;, &#39;author&#39;]\n\nprops: &#123;\n  title: String,\n  likes: Number,\n  isPublished: Boolean,\n  commentIds: Array,\n  author: Object,\n  callback: Function,\n  contactsPromise: Promise // or any other constructor\n&#125;\n</code></pre>\n<ul>\n<li>传递静态或动态Prop<br>静态Prop</li>\n</ul>\n<pre><code>&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;\n</code></pre>\n<p>动态Prop</p>\n<pre><code>&lt;!-- 动态赋予一个变量的值 --&gt;\n&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;\n\n&lt;!-- 动态赋予一个复杂表达式的值 --&gt;\n&lt;blog-post\n  v-bind:title=&quot;post.title + &#39; by &#39; + post.author.name&quot;\n&gt;&lt;/blog-post&gt;\n</code></pre>\n<p>传入数字</p>\n<pre><code>&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;\n&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;\n&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post\n</code></pre>\n<p>传入布尔值</p>\n<pre><code>&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;\n&lt;blog-post is-published&gt;&lt;/blog-post&gt;\n\n&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;\n&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;\n&lt;blog-post v-bind:is-published=&quot;false&quot;&gt;&lt;/blog-post&gt;\n</code></pre>\n<p>传入数组</p>\n<pre><code>&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;\n&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;\n&lt;blog-post v-bind:comment-ids=&quot;[234, 266, 273]&quot;&gt;&lt;/blog-post&gt;\n</code></pre>\n<p>传入对象</p>\n<pre><code>&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;\n&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;\n&lt;blog-post\n  v-bind:author=&quot;&#123;\n    name: &#39;Veronica&#39;,\n    company: &#39;Veridian Dynamics&#39;\n  &#125;&quot;\n&gt;&lt;/blog-post&gt;\n</code></pre>\n<ul>\n<li><p>单向数据流<br>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理，你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告</p>\n</li>\n<li><p>Prop验证<br>type类型：String、Number、Boolean、Array、Object、Date、Function、Symbol</p>\n</li>\n</ul>\n<pre><code>Vue.component(&#39;my-component&#39;, &#123;\n  props: &#123;\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\n    propA: Number,\n    // 多个可能的类型\n    propB: [String, Number],\n    // 必填的字符串\n    propC: &#123;\n      type: String,\n      required: true\n    &#125;,\n    // 带有默认值的数字\n    propD: &#123;\n      type: Number,\n      default: 100\n    &#125;,\n    // 带有默认值的对象\n    propE: &#123;\n      type: Object,\n      // 对象或数组默认值必须从一个工厂函数获取\n      default: function () &#123;\n        return &#123; message: &#39;hello&#39; &#125;\n      &#125;\n    &#125;,\n    // 自定义验证函数\n    propF: &#123;\n      validator: function (value) &#123;\n        // 这个值必须匹配下列字符串中的一个\n        return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !== -1\n      &#125;\n    &#125;\n  &#125;\n&#125;)\n</code></pre>\n<p>（2）通过$emit监听子组件事件</p>\n<pre><code>// 父组件\n&lt;blog-post\n  ...\n  v-on:enlarge-text=&quot;postFontSize += 0.1&quot;\n&gt;&lt;/blog-post&gt;\n\n// 子组件\n&lt;button v-on:click=&quot;$emit(&#39;enlarge-text&#39;)&quot;&gt;\n  Enlarge text\n&lt;/button&gt;\n</code></pre>\n<ul>\n<li>$emit参数</li>\n</ul>\n<pre><code>// 父组件\n&lt;blog-post\n  ...\n  v-on:enlarge-text=&quot;onEnlargeText&quot;\n&gt;&lt;/blog-post&gt;\n\nmethods: &#123;\n    onEnlargeText (enlargeAmount) &#123;\n        this.postFontSize += enlargeAmount\n    &#125;\n&#125;\n\n// 子组件\n&lt;button v-on:click=&quot;$emit(&#39;enlarge-text&#39;, 0.1)&quot;&gt;\n  Enlarge text\n&lt;/button&gt;\n</code></pre>\n<p>（3）插槽slot<br>一套内容分发的 API</p>\n<pre><code>&lt;navigation-link url=&quot;/profile&quot;&gt;\n  Your Profile\n&lt;/navigation-link&gt;\n\n// navigation-link\n&lt;a\n  v-bind:href=&quot;url&quot;\n  class=&quot;nav-link&quot;\n&gt;\n  &lt;slot&gt;&lt;/slot&gt;\n&lt;/a&gt;\n\n// 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。\n</code></pre>\n<ul>\n<li>具名插槽</li>\n</ul>\n<pre><code>// 定义插槽\n&lt;div class=&quot;container&quot;&gt;\n  &lt;header&gt;\n    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;slot&gt;&lt;/slot&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;\n  &lt;/footer&gt;\n&lt;/div&gt;\n\n// 使用插槽\n&lt;base-layout&gt;\n  &lt;template v-slot:header&gt;\n    &lt;h1&gt;Here might be a page title&lt;/h1&gt;\n  &lt;/template&gt;\n\n  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n  &lt;p&gt;And another one.&lt;/p&gt;\n\n  &lt;template v-slot:footer&gt;\n    &lt;p&gt;Here&#39;s some contact info&lt;/p&gt;\n  &lt;/template&gt;\n&lt;/base-layout&gt;\n</code></pre>\n<ul>\n<li>作用域插槽</li>\n</ul>\n<pre><code>// 子组件\n&lt;span&gt;\n  &lt;slot v-bind:user=&quot;user&quot;&gt;\n    &#123;&#123; user.lastName &#125;&#125;\n  &lt;/slot&gt;\n&lt;/span&gt;\n\n// 父组件\n&lt;current-user&gt;\n  &lt;template v-slot:default=&quot;slotProps&quot;&gt;\n    &#123;&#123; slotProps.user.firstName &#125;&#125;\n  &lt;/template&gt;\n&lt;/current-user&gt;\n</code></pre>\n<p>（4）动态组件<br>总结：<br>（1）组件的data必须一个函数</p>\n<ol start=\"16\">\n<li><p>自定义事件</p>\n</li>\n<li><p>进入离开列表过渡</p>\n</li>\n<li><p>混入</p>\n</li>\n</ol>\n<pre><code>var myMixin = &#123;\n    created: function () &#123;\n        this.hello()\n    &#125;,\n    methods: &#123;\n        hello: function () &#123;\n            console.log(&#39;hello&#39;)\n        &#125;\n    &#125;\n&#125;\n\nvar Component = Vue.extend(&#123;\n    mixins: [myMixin]\n&#125;)\n</code></pre>\n<ol start=\"19\">\n<li>自定义指令</li>\n</ol>\n<pre><code>Vue.directive(&#39;focus&#39;, &#123;\n    // / 当被绑定的元素插入到 DOM 中时……\n    inserted: function (el) &#123;\n        // 聚焦元素\n    el.focus()\n        el.focus()\n    &#125;\n&#125;)\n</code></pre>\n<p>钩子函数：<br>bind    只调用一次，指令第一次绑定到元素时调用<br>inserted    被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)<br>update  所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前<br>componentUpdated    指令所在组件的 VNode 及其子 VNode 全部更新后调用<br>unbind  只调用一次，指令与元素解绑时调用</p>\n<p>钩子函数参数<br>el：指令所绑定的元素，可以用来直接操作 DOM<br>binding：一个对象，包含以下 property<br>    name：指令名，不包括 v- 前缀<br>    value：指令绑定的值，例如：v-my-directive=”1 + 1” 中，绑定值为 2<br>    oldValue：指定绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用<br>    expression：字符串形式的指定表达式，例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”<br>    arg：传给指令的参数，例如 v-my-directive:foo 中，参数为 “foo”<br>    modifers：一个包含修饰符的对象，如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }<br>vnode：Vue 编译生成的虚拟节点<br>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用</p>\n<p>一个例子</p>\n<pre><code>&lt;div id=&quot;hook-arguments-example&quot; v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt;\n\nVue.directive(&#39;demo&#39;, &#123;\n  bind: function (el, binding, vnode) &#123;\n    var s = JSON.stringify\n    el.innerHTML =\n      &#39;name: &#39;       + s(binding.name) + &#39;&lt;br&gt;&#39; +   //demo\n      &#39;value: &#39;      + s(binding.value) + &#39;&lt;br&gt;&#39; +  // hello\n      &#39;expression: &#39; + s(binding.expression) + &#39;&lt;br&gt;&#39; + // message\n      &#39;argument: &#39;   + s(binding.arg) + &#39;&lt;br&gt;&#39; +    //foo\n      &#39;modifiers: &#39;  + s(binding.modifiers) + &#39;&lt;br&gt;&#39; +  //&#123;&quot;a&quot;: true, &quot;b&quot;: true&#125;\n      &#39;vnode keys: &#39; + Object.keys(vnode).join(&#39;, &#39;)\n  &#125;\n&#125;)\n\nnew Vue(&#123;\n  el: &#39;#hook-arguments-example&#39;,\n  data: &#123;\n    message: &#39;hello!&#39;\n  &#125;\n&#125;)\n</code></pre>\n<h5 id=\"20-Render-amp-JSX\"><a href=\"#20-Render-amp-JSX\" class=\"headerlink\" title=\"20. Render &amp; JSX\"></a>20. Render &amp; JSX</h5><p>Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用渲染函数，它比模板更接近编译器</p>\n<pre><code>Vue.component(&#39;anchored-heading&#39;, &#123;\n  render: function (createElement) &#123;\n    return createElement(\n      &#39;h&#39; + this.level,   // 标签名称\n      this.$slots.default // 子节点数组\n    )\n  &#125;,\n  props: &#123;\n    level: &#123;\n      type: Number,\n      required: true\n    &#125;\n  &#125;\n&#125;)\n</code></pre>\n<ul>\n<li>节点、树以及虚拟 DOM</li>\n</ul>\n<pre><code>&lt;h1&gt;&#123;&#123; blogTitle &#125;&#125;&lt;/h1&gt;\n\n渲染函数\n\nrender: function (createElement) &#123;\n  return createElement(&#39;h1&#39;, this.blogTitle)\n&#125;\n</code></pre>\n<ul>\n<li>createElement 参数</li>\n</ul>\n<pre><code>// @returns &#123;VNode&#125;\ncreateElement(\n  // &#123;String | Object | Function&#125;\n  // 一个 HTML 标签名、组件选项对象，或者\n  // resolve 了上述任何一种的一个 async 函数。必填项。\n  &#39;div&#39;,\n\n  // &#123;Object&#125;\n  // 一个与模板中 attribute 对应的数据对象。可选。\n  &#123;\n    // (详情见下一节)\n  &#125;,\n\n  // &#123;String | Array&#125;\n  // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，\n  // 也可以使用字符串来生成“文本虚拟节点”。可选。\n  [\n    &#39;先写一些文字&#39;,\n    createElement(&#39;h1&#39;, &#39;一则头条&#39;),\n    createElement(MyComponent, &#123;\n      props: &#123;\n        someProp: &#39;foobar&#39;\n      &#125;\n    &#125;)\n  ]\n)\n</code></pre>\n<h5 id=\"21-插件\"><a href=\"#21-插件\" class=\"headerlink\" title=\"21. 插件\"></a>21. 插件</h5><p>（1）插件是什么？<br>    插件通常用来为 Vue 添加全局功能<br>（2）怎么用？<br>    通过全局方法 Vue.use() 使用插件，它需要在你调用 new Vue() 启动应用之前完成</p>\n<pre><code>// 调用 `MyPlugin.install(Vue)`\nVue.use(MyPlugin)\n\nnew Vue(&#123;\n  // ...组件选项\n&#125;)\n</code></pre>\n<p>（3）开发插件<br>Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：</p>\n<pre><code>MyPlugin.install = function (Vue, options) &#123;\n  // 1. 添加全局方法或 property\n  Vue.myGlobalMethod = function () &#123;\n    // 逻辑...\n  &#125;\n\n  // 2. 添加全局资源\n  Vue.directive(&#39;my-directive&#39;, &#123;\n    bind (el, binding, vnode, oldVnode) &#123;\n      // 逻辑...\n    &#125;\n    ...\n  &#125;)\n\n  // 3. 注入组件选项\n  Vue.mixin(&#123;\n    created: function () &#123;\n      // 逻辑...\n    &#125;\n    ...\n  &#125;)\n\n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function (methodOptions) &#123;\n    // 逻辑...\n  &#125;\n&#125;\n</code></pre>\n<h5 id=\"22-过滤器\"><a href=\"#22-过滤器\" class=\"headerlink\" title=\"22. 过滤器\"></a>22. 过滤器</h5><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化</p>\n<pre><code>&lt;!-- 在双花括号中 --&gt;\n&#123;&#123; message | capitalize&#125;&#125;\n\n&lt;!-- 在 `v-bind` 中 --&gt;\n&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;\n\nfilters: &#123;\n    capitalize: function (value) &#123;\n        if (!value) &#123;\n            value = value.toString()\n            return value.chartAt(0).toUpperCase() + value.slice(1)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>全局注册过滤器<br>Vue.filter(‘capitalize’, function (value) {<br>    if (!value) {<br>        value = value.toString()<br>        return value.chartAt(0).toUpperCase() + value.slice(1)<br>    }<br>})</p>\n<h5 id=\"23-响应式原理\"><a href=\"#23-响应式原理\" class=\"headerlink\" title=\"23. 响应式原理\"></a>23. 响应式原理</h5><p><img src=\"/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/vue.png\" alt=\"vue\"><br>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染</p>\n<h5 id=\"24-测试\"><a href=\"#24-测试\" class=\"headerlink\" title=\"24. 测试\"></a>24. 测试</h5><p>（1）官方推荐测试框架Vue Testing Library (@testing-library/vue)</p>\n<p>（2）安装</p>\n<pre><code>npm install --save-dev jest @vue/test-utils\n</code></pre>\n<p>（3）添加脚本</p>\n<pre><code>// package.json\n&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;jest&quot;\n  &#125;\n&#125;\n</code></pre>\n<h5 id=\"25-Vue-API\"><a href=\"#25-Vue-API\" class=\"headerlink\" title=\"25. Vue API\"></a>25. Vue API</h5><ul>\n<li>实例<br>（1）vm.$data<br>（2）vm.$props<br>（3）vm.$el<br>  Vue 实例使用的根 DOM 元素<br>（3）vm.$options<br>  用于当前 Vue 实例的初始化选项</li>\n</ul>\n<pre><code>new Vue(&#123;\n  customOption: &#39;foo&#39;,\n  created: function () &#123;\n    console.log(this.$options.customOption) // =&gt; &#39;foo&#39;\n  &#125;\n&#125;)\n</code></pre>\n<p>（4）vm.$parent<br>    父实例，如果当前实例有的话<br>（5）vm.$root<br>    当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己<br>（6）$children<br>    当前实例的直接子组件<br>（7）vm.$slots<br>    用来访问被插槽分发的内容</p>\n<pre><code>```\n&lt;blog-post&gt;\n    &lt;template v-slot:header&gt;\n        &lt;h1&gt;About Me&lt;/h1&gt;\n    &lt;/template&gt;\n\n    &lt;p&gt;Here&#39;s some page content, which will be included in vm.$slots.default,   because it&#39;s not inside a named slot.\n    &lt;/p&gt;\n\n    &lt;template v-slot:footer&gt;\n        &lt;p&gt;Copyright 2016 Evan You&lt;/p&gt;\n    &lt;/template&gt;\n\n    &lt;p&gt;If I have some content down here, it will also be included in            vm.$slots.default.\n    &lt;/p&gt;\n&lt;/blog-post&gt;\n```\n\n```\nVue.component(&#39;blog-post&#39;, &#123;\n    render: function (createElement) &#123;\n        var header = this.$slots.header\n        var body   = this.$slots.default\n        var footer = this.$slots.footer\n        return createElement(&#39;div&#39;, [\n        createElement(&#39;header&#39;, header),\n        createElement(&#39;main&#39;, body),\n        createElement(&#39;footer&#39;, footer)\n        ])\n    &#125;\n &#125;)\n```\n</code></pre>\n<p>（8）vm.$scopedSlots<br>    用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。<br>（9）vm.$refs<br>    一个对象，持有注册过 ref attribute 的所有 DOM 元素和组件实例<br>（10）vm.$isServer<br>    当前 Vue 实例是否运行于服务器<br>（11）vm.$attrs<br>    包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用<br>（12）vm.$listeners<br>    包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件——在创建更高层次的组件时非常有用</p>\n<ul>\n<li><p>实例方法<br>（1）vm.$watch( expOrFn, callback, [options] )<br>  观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。表达式只接受简单的键路径。对于更复杂的表达式，用一个函数取代</p>\n<pre><code>    // 键路径\n    vm.$watch(&#39;a.b.c&#39;, function (newVal, oldVal) &#123;\n    // 做点什么\n    &#125;)\n\n    // 函数\n    vm.$watch(\n    function () &#123;\n        // 表达式 `this.a + this.b` 每次得出一个不同的结果时\n        // 处理函数都会被调用。\n        // 这就像监听一个未被定义的计算属性\n        return this.a + this.b\n    &#125;,\n    function (newVal, oldVal) &#123;\n        // 做点什么\n    &#125;\n    )\n</code></pre>\n<p>  vm.$watch 返回一个取消观察函数，用来停止触发回调：</p>\n<pre><code>var unwatch = vm.$watch(&#39;a&#39;, cb)\n// 之后取消观察\nunwatch()\n</code></pre>\n<p>  选项：deep</p>\n<pre><code>  为了发现对象内部值的变化，可以在选项参数中指定 deep: true。注意监听数组的变更不需要这么做。\n</code></pre>\n<pre><code>    vm.$watch(&#39;someObject&#39;, callback, &#123;\n        deep: true\n    &#125;)\n    vm.someObject.nestedValue = 123\n    // callback is fired\n</code></pre>\n</li>\n</ul>\n<pre><code>选项：immediate\n    在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调：\n\n```\n    vm.$watch(&#39;a&#39;, callback, &#123;\n        immediate: true\n    &#125;)\n    // 立即以 `a` 的当前值触发回调\n```\n</code></pre>\n<p>（2）vm.$set( target, propertyName/index, value )<br>    这是全局 Vue.set 的别名</p>\n<p>（3）vm.$delete( target, propertyName/index )<br>    这是全局 Vue.delete 的别名</p>\n<p>（4）vm.$on( event, callback )<br>    监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数</p>\n<pre><code>```\nvm.$on(&#39;test&#39;, function (msg) &#123;\n    console.log(msg)\n&#125;)\nvm.$emit(&#39;test&#39;, &#39;hi&#39;)\n// =&gt; &quot;hi&quot;\n```\n</code></pre>\n<p>（5）$once<br>    监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除<br>（6）vm.$off( [event, callback] )<br>    移除自定义事件监听器<br>    - 如果没有提供参数，则移除所有的事件监听器；</p>\n<pre><code>- 如果只提供了事件，则移除该事件所有的监听器；\n\n- 如果同时提供了事件与回调，则只移除这个回调的监听器。\n</code></pre>\n<p>（7）vm.$emit( eventName, […args] )<br>    触发当前实例上的事件。附加参数都会传给监听器回调<br>    <code>    Vue.component(&#39;welcome-button&#39;, &#123;         template: `             &lt;button v-on:click=&quot;$emit(&#39;welcome&#39;)&quot;&gt;                 Click me to be welcomed             &lt;/button&gt;`     &#125;)    </code></p>\n<pre><code>```\n&lt;div id=&quot;emit-example-simple&quot;&gt;\n    &lt;welcome-button @welcome=&quot;sayHi&quot;&gt;&lt;/welcome-button&gt;\n&lt;/div&gt;\n```\n\n```\nnew Vue(&#123;\n    el: &#39;#emit-example-simple&#39;,\n    methods: &#123;\n        sayHi: function () &#123;\n        alert(&#39;Hi!&#39;)\n        &#125;\n    &#125;\n&#125;)\n```\n</code></pre>\n<p>（8）vm.$mount( [elementOrSelector] )<br>    如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素可以使用 vm.$mount() 手动地挂载一个未挂载的实例</p>\n<p>（9）vm.$nextTick( [callback] )<br>    将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上</p>\n<p>（10）vm.$destroy()<br>     完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器  </p>\n<p>（11）vm.$forceUpdate()<br>    迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>vue简介<br> Vue是一套用于构建用户界面的渐进式框架，Vue能够为复杂的单页面应用提供驱动</p>\n</li>\n<li><p>安装<br>（1）CDN引入</p>\n<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;&gt;&lt;/script&gt;\n</code></pre>\n</li>\n</ol>\n<p>（2）脚手架工具vue-cli</p>\n<pre><code>// 全局安装vue-cli\nnpm install vue-cli -g\n\n// create vue project\nvue init wepack demo-name   // for vue-cli@2.x\n\nor\n\nvue create  // for vue-cli@3.x\n</code></pre>\n<ol start=\"3\">\n<li><p>Vue实例</p>\n<pre><code>var data = &#123;a: 1&#125;\nvar vm = new Vue(&#123;\n data: data\n&#125;)\n</code></pre>\n</li>\n<li><p>生命周期<br><img src=\"/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/lifecycle.png\" alt=\"vue生命周期\"></p>\n</li>\n<li><p>插值（Mustache）<br>数据绑定最常见的形式就是使用’Mustache’语法（双大括号）的文本插值</p>\n<pre><code>&lt;span&gt;&#123;&#123;Message: &#123;&#123;msg&#125;&#125;&#125;&#125;&lt;/span&gt;\n</code></pre>\n</li>\n<li><p>指令<br>指定（Directives）是带有v-前缀的特殊attribute，指令的指责是，当表达式的值改变时，<br>将其产生的连带影响，响应式的用于DOM<br>v-on    // 缩写 :<br>v-bind  // 缩写 @<br>v-if<br>v-else<br>v-else-if<br>v-html<br>v-for<br>v-show</p>\n</li>\n<li><p>修饰符<br>.prevent</p>\n</li>\n<li><p>计算属性(computed)<br>计算属性</p>\n<pre><code>var vm = new Vue(&#123;\n el: &#39;#app&#39;,\n data: &#123;\n     message: &#39;Hello&#39;\n &#125;,\n computed: &#123;\n     reversedMessage: function () &#123;\n         // this指向vm实例\n         return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)\n     &#125;\n &#125;\n&#125;)\n</code></pre>\n</li>\n<li><p>侦听器</p>\n</li>\n</ol>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    &lt;p&gt;\n        Ask a yes/no question\n        &lt;input v-model=&quot;question&quot; /&gt;\n    &lt;/p&gt;\n&lt;/div&gt;\n\nvar vm = new Vue(&#123;\n    el: &#39;#app&#39;,\n    data () &#123;\n        return &#123;\n            question: &#39;&#39;,\n            answer: &#39;I cannot give you an answer until you ask a question!&#39;\n        &#125;\n    &#125;,\n    created () &#123;\n        this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n    &#125;,\n    watch: &#123;\n        question: function (newQuestion, oldQuestion) &#123;\n            this.answer = &#39;Waiting for you to stop typing...&#39;\n            this.debouncedGetAnswer()\n        &#125;\n    &#125;,\n    methods: &#123;\n        getAnsswer: function () &#123;\n            if (this.question.indexOf(&#39;?&#39;) === -1) &#123;\n                this.answer = &#39;&#39;Questions usually contain a question mark. ;-)&#39;\n                return \n            &#125;\n            this.answer = &#39;Thinking...&#39;\n            var vm = this\n            axios.get(&#39;&#39;).then(res =&gt; &#123;\n                vm.answer = _.capitalize(response.data.answer)\n            &#125;).catch(error =&gt; &#123;\n                vm.answer = &#39;Error! Could not reach the API. &#39; + error\n            &#125;)\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n<ol start=\"10\">\n<li>class与style绑定<br>内联</li>\n</ol>\n<pre><code>&lt;div :class=&quot;&#123;active: isActive&#125;&quot;&gt;&lt;/div&gt;\n\ndata: &#123;\n    isActive: true\n&#125;\n</code></pre>\n<p>对象</p>\n<pre><code>&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;\n\ndata: &#123;\n    classObject: &#123;\n        active&quot; true,\n        &#39;text-danger&#39;: false\n    &#125;\n&#125;\n</code></pre>\n<p>计算属性</p>\n<pre><code>&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;\n\ndata: &#123;\n    isActive: true,\n    error: null\n&#125;\n\ncomputed: &#123;\n    classObject: function () &#123;\n        return &#123;\n            active: this.isActive &amp;&amp; !this.error,\n            &#39;text-danger&#39;: this.error &amp;&amp; this.error.type === &#39;fatal&#39;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>数组</p>\n<pre><code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;\n\ndata: &#123;\n    activeClass: &#39;active&#39;,\n    errorClass: &#39;text-danger&#39;\n&#125;\n</code></pre>\n<p>三元表达式</p>\n<pre><code>&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>数组中使用对象</p>\n<pre><code>&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;\n</code></pre>\n<ol start=\"11\">\n<li>条件渲染<br>v-if指令用于条件性地渲染一块内容</li>\n</ol>\n<pre><code>&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;\n&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;\n</code></pre>\n<p>总结：<br>    不建议v-if与v-for一起使用，v-for具有比v-if更高的优先级，</p>\n<ol start=\"12\">\n<li>列表渲染</li>\n</ol>\n<pre><code>&lt;ul&gt;\n    &lt;li v-for=&quot;item in items&quot; :key=&quot;item.message&quot;&gt;\n        &#123;&#123;item.message&#125;&#125;\n    &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<p>总结：<br>（1）建议给每个遍历项添加一个唯一的key，且不是下标<br>（2）不建议v-for, v-if在上同一个元素上同时使用<br>（3）v-for的优先级高于v-if</p>\n<ol start=\"13\">\n<li>事件处理（v-on）<br>用v-on指令监听DOM事件</li>\n</ol>\n<pre><code>&lt;div id=&quot;app&quot;&gt;\n    &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;\n&lt;/div&gt;\n\nvar app = new Vue(&#123;\n    el: &#39;#app&#39;,\n    data: &#123;\n        name: &#39;Vue.js&#39;\n    &#125;,\n    methods: &#123;\n        greet: function (event) &#123;\n            if (event) &#123;\n                alert(event.target.tagName)\n            &#125;\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n<p>事件修饰符：<br>.stop<br>.prevent<br>.capture<br>.self<br>.once<br>.passive<br>.enter<br>.tab<br>.delete<br>.esc<br>.space<br>.up<br>.down<br>.left<br>.right</p>\n<pre><code>&lt;!-- 提交事件不再重载页面 --&gt;\n&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;\n\n&lt;!-- 修饰符可以串联 --&gt;\n&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;\n\n&lt;!-- 只有修饰符 --&gt;\n&lt;form v-on:submit.prevent&gt;&lt;/form&gt;\n\n&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;\n&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;\n&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;\n\n&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;\n&lt;!-- 即事件不是从内部元素触发的 --&gt;\n&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;\n</code></pre>\n<ol start=\"14\">\n<li>表单输入绑定（v-model）<br>v-model</li>\n</ol>\n<pre><code>// 文本\n&lt;input v-model=&quot;message&quot; /&gt;\n&lt;p&gt;Message is: &#123;&#123;message&#125;&#125;&lt;/p&gt;\n\n// 复选框\n&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;\n&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;\n</code></pre>\n<p>修饰符：<br>.lazy   在“change”时而非“input”时更新<br>.trim   自动过滤用户输入的首尾空白字符<br>.number 将用户的输入值转为数值类型</p>\n<pre><code>&lt;input v-model.lazy=&quot;msg&quot;&gt;\n\n&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;\n\n&lt;input v-model.trim=&quot;msg&quot;&gt;\n</code></pre>\n<ol start=\"15\">\n<li>组件<br>（1）组件命名</li>\n</ol>\n<ul>\n<li>使用 kebab-case</li>\n</ul>\n<pre><code>Vue.component(&#39;my-component-name&#39;, &#123; /* ... */ &#125;)\n\n/*\n当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 &lt;my-component-name&gt;\n*/ \n</code></pre>\n<ul>\n<li>使用 PascalCase</li>\n</ul>\n<pre><code>Vue.component(&#39;MyComponentName&#39;, &#123; /* ... */ &#125;)\n\n/*\n当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 &lt;my-component-name&gt; 和 &lt;MyComponentName&gt; 都是可接受的\n*/\n</code></pre>\n<p>（2）通过props向子组件传递数据</p>\n<ul>\n<li>Prop命名</li>\n</ul>\n<pre><code>Vue.component(&#39;blog-post&#39;, &#123;\n  // 在 JavaScript 中是 camelCase 的\n  props: [&#39;postTitle&#39;],\n  template: &#39;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#39;\n&#125;)\n\n&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;\n&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;\n</code></pre>\n<ul>\n<li>Prop类型<br>通常你希望每个 prop 都有指定的值类型，这时，你可以以对象形式列出 prop</li>\n</ul>\n<pre><code>props: [&#39;title&#39;, &#39;likes&#39;, &#39;isPublished&#39;, &#39;commentIds&#39;, &#39;author&#39;]\n\nprops: &#123;\n  title: String,\n  likes: Number,\n  isPublished: Boolean,\n  commentIds: Array,\n  author: Object,\n  callback: Function,\n  contactsPromise: Promise // or any other constructor\n&#125;\n</code></pre>\n<ul>\n<li>传递静态或动态Prop<br>静态Prop</li>\n</ul>\n<pre><code>&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;\n</code></pre>\n<p>动态Prop</p>\n<pre><code>&lt;!-- 动态赋予一个变量的值 --&gt;\n&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;\n\n&lt;!-- 动态赋予一个复杂表达式的值 --&gt;\n&lt;blog-post\n  v-bind:title=&quot;post.title + &#39; by &#39; + post.author.name&quot;\n&gt;&lt;/blog-post&gt;\n</code></pre>\n<p>传入数字</p>\n<pre><code>&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;\n&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;\n&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post\n</code></pre>\n<p>传入布尔值</p>\n<pre><code>&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;\n&lt;blog-post is-published&gt;&lt;/blog-post&gt;\n\n&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;\n&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;\n&lt;blog-post v-bind:is-published=&quot;false&quot;&gt;&lt;/blog-post&gt;\n</code></pre>\n<p>传入数组</p>\n<pre><code>&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;\n&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;\n&lt;blog-post v-bind:comment-ids=&quot;[234, 266, 273]&quot;&gt;&lt;/blog-post&gt;\n</code></pre>\n<p>传入对象</p>\n<pre><code>&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;\n&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;\n&lt;blog-post\n  v-bind:author=&quot;&#123;\n    name: &#39;Veronica&#39;,\n    company: &#39;Veridian Dynamics&#39;\n  &#125;&quot;\n&gt;&lt;/blog-post&gt;\n</code></pre>\n<ul>\n<li><p>单向数据流<br>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理，你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告</p>\n</li>\n<li><p>Prop验证<br>type类型：String、Number、Boolean、Array、Object、Date、Function、Symbol</p>\n</li>\n</ul>\n<pre><code>Vue.component(&#39;my-component&#39;, &#123;\n  props: &#123;\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\n    propA: Number,\n    // 多个可能的类型\n    propB: [String, Number],\n    // 必填的字符串\n    propC: &#123;\n      type: String,\n      required: true\n    &#125;,\n    // 带有默认值的数字\n    propD: &#123;\n      type: Number,\n      default: 100\n    &#125;,\n    // 带有默认值的对象\n    propE: &#123;\n      type: Object,\n      // 对象或数组默认值必须从一个工厂函数获取\n      default: function () &#123;\n        return &#123; message: &#39;hello&#39; &#125;\n      &#125;\n    &#125;,\n    // 自定义验证函数\n    propF: &#123;\n      validator: function (value) &#123;\n        // 这个值必须匹配下列字符串中的一个\n        return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !== -1\n      &#125;\n    &#125;\n  &#125;\n&#125;)\n</code></pre>\n<p>（2）通过$emit监听子组件事件</p>\n<pre><code>// 父组件\n&lt;blog-post\n  ...\n  v-on:enlarge-text=&quot;postFontSize += 0.1&quot;\n&gt;&lt;/blog-post&gt;\n\n// 子组件\n&lt;button v-on:click=&quot;$emit(&#39;enlarge-text&#39;)&quot;&gt;\n  Enlarge text\n&lt;/button&gt;\n</code></pre>\n<ul>\n<li>$emit参数</li>\n</ul>\n<pre><code>// 父组件\n&lt;blog-post\n  ...\n  v-on:enlarge-text=&quot;onEnlargeText&quot;\n&gt;&lt;/blog-post&gt;\n\nmethods: &#123;\n    onEnlargeText (enlargeAmount) &#123;\n        this.postFontSize += enlargeAmount\n    &#125;\n&#125;\n\n// 子组件\n&lt;button v-on:click=&quot;$emit(&#39;enlarge-text&#39;, 0.1)&quot;&gt;\n  Enlarge text\n&lt;/button&gt;\n</code></pre>\n<p>（3）插槽slot<br>一套内容分发的 API</p>\n<pre><code>&lt;navigation-link url=&quot;/profile&quot;&gt;\n  Your Profile\n&lt;/navigation-link&gt;\n\n// navigation-link\n&lt;a\n  v-bind:href=&quot;url&quot;\n  class=&quot;nav-link&quot;\n&gt;\n  &lt;slot&gt;&lt;/slot&gt;\n&lt;/a&gt;\n\n// 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。\n</code></pre>\n<ul>\n<li>具名插槽</li>\n</ul>\n<pre><code>// 定义插槽\n&lt;div class=&quot;container&quot;&gt;\n  &lt;header&gt;\n    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;\n  &lt;/header&gt;\n  &lt;main&gt;\n    &lt;slot&gt;&lt;/slot&gt;\n  &lt;/main&gt;\n  &lt;footer&gt;\n    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;\n  &lt;/footer&gt;\n&lt;/div&gt;\n\n// 使用插槽\n&lt;base-layout&gt;\n  &lt;template v-slot:header&gt;\n    &lt;h1&gt;Here might be a page title&lt;/h1&gt;\n  &lt;/template&gt;\n\n  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;\n  &lt;p&gt;And another one.&lt;/p&gt;\n\n  &lt;template v-slot:footer&gt;\n    &lt;p&gt;Here&#39;s some contact info&lt;/p&gt;\n  &lt;/template&gt;\n&lt;/base-layout&gt;\n</code></pre>\n<ul>\n<li>作用域插槽</li>\n</ul>\n<pre><code>// 子组件\n&lt;span&gt;\n  &lt;slot v-bind:user=&quot;user&quot;&gt;\n    &#123;&#123; user.lastName &#125;&#125;\n  &lt;/slot&gt;\n&lt;/span&gt;\n\n// 父组件\n&lt;current-user&gt;\n  &lt;template v-slot:default=&quot;slotProps&quot;&gt;\n    &#123;&#123; slotProps.user.firstName &#125;&#125;\n  &lt;/template&gt;\n&lt;/current-user&gt;\n</code></pre>\n<p>（4）动态组件<br>总结：<br>（1）组件的data必须一个函数</p>\n<ol start=\"16\">\n<li><p>自定义事件</p>\n</li>\n<li><p>进入离开列表过渡</p>\n</li>\n<li><p>混入</p>\n</li>\n</ol>\n<pre><code>var myMixin = &#123;\n    created: function () &#123;\n        this.hello()\n    &#125;,\n    methods: &#123;\n        hello: function () &#123;\n            console.log(&#39;hello&#39;)\n        &#125;\n    &#125;\n&#125;\n\nvar Component = Vue.extend(&#123;\n    mixins: [myMixin]\n&#125;)\n</code></pre>\n<ol start=\"19\">\n<li>自定义指令</li>\n</ol>\n<pre><code>Vue.directive(&#39;focus&#39;, &#123;\n    // / 当被绑定的元素插入到 DOM 中时……\n    inserted: function (el) &#123;\n        // 聚焦元素\n    el.focus()\n        el.focus()\n    &#125;\n&#125;)\n</code></pre>\n<p>钩子函数：<br>bind    只调用一次，指令第一次绑定到元素时调用<br>inserted    被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)<br>update  所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前<br>componentUpdated    指令所在组件的 VNode 及其子 VNode 全部更新后调用<br>unbind  只调用一次，指令与元素解绑时调用</p>\n<p>钩子函数参数<br>el：指令所绑定的元素，可以用来直接操作 DOM<br>binding：一个对象，包含以下 property<br>    name：指令名，不包括 v- 前缀<br>    value：指令绑定的值，例如：v-my-directive=”1 + 1” 中，绑定值为 2<br>    oldValue：指定绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用<br>    expression：字符串形式的指定表达式，例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”<br>    arg：传给指令的参数，例如 v-my-directive:foo 中，参数为 “foo”<br>    modifers：一个包含修饰符的对象，如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }<br>vnode：Vue 编译生成的虚拟节点<br>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用</p>\n<p>一个例子</p>\n<pre><code>&lt;div id=&quot;hook-arguments-example&quot; v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt;\n\nVue.directive(&#39;demo&#39;, &#123;\n  bind: function (el, binding, vnode) &#123;\n    var s = JSON.stringify\n    el.innerHTML =\n      &#39;name: &#39;       + s(binding.name) + &#39;&lt;br&gt;&#39; +   //demo\n      &#39;value: &#39;      + s(binding.value) + &#39;&lt;br&gt;&#39; +  // hello\n      &#39;expression: &#39; + s(binding.expression) + &#39;&lt;br&gt;&#39; + // message\n      &#39;argument: &#39;   + s(binding.arg) + &#39;&lt;br&gt;&#39; +    //foo\n      &#39;modifiers: &#39;  + s(binding.modifiers) + &#39;&lt;br&gt;&#39; +  //&#123;&quot;a&quot;: true, &quot;b&quot;: true&#125;\n      &#39;vnode keys: &#39; + Object.keys(vnode).join(&#39;, &#39;)\n  &#125;\n&#125;)\n\nnew Vue(&#123;\n  el: &#39;#hook-arguments-example&#39;,\n  data: &#123;\n    message: &#39;hello!&#39;\n  &#125;\n&#125;)\n</code></pre>\n<h5 id=\"20-Render-amp-JSX\"><a href=\"#20-Render-amp-JSX\" class=\"headerlink\" title=\"20. Render &amp; JSX\"></a>20. Render &amp; JSX</h5><p>Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用渲染函数，它比模板更接近编译器</p>\n<pre><code>Vue.component(&#39;anchored-heading&#39;, &#123;\n  render: function (createElement) &#123;\n    return createElement(\n      &#39;h&#39; + this.level,   // 标签名称\n      this.$slots.default // 子节点数组\n    )\n  &#125;,\n  props: &#123;\n    level: &#123;\n      type: Number,\n      required: true\n    &#125;\n  &#125;\n&#125;)\n</code></pre>\n<ul>\n<li>节点、树以及虚拟 DOM</li>\n</ul>\n<pre><code>&lt;h1&gt;&#123;&#123; blogTitle &#125;&#125;&lt;/h1&gt;\n\n渲染函数\n\nrender: function (createElement) &#123;\n  return createElement(&#39;h1&#39;, this.blogTitle)\n&#125;\n</code></pre>\n<ul>\n<li>createElement 参数</li>\n</ul>\n<pre><code>// @returns &#123;VNode&#125;\ncreateElement(\n  // &#123;String | Object | Function&#125;\n  // 一个 HTML 标签名、组件选项对象，或者\n  // resolve 了上述任何一种的一个 async 函数。必填项。\n  &#39;div&#39;,\n\n  // &#123;Object&#125;\n  // 一个与模板中 attribute 对应的数据对象。可选。\n  &#123;\n    // (详情见下一节)\n  &#125;,\n\n  // &#123;String | Array&#125;\n  // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，\n  // 也可以使用字符串来生成“文本虚拟节点”。可选。\n  [\n    &#39;先写一些文字&#39;,\n    createElement(&#39;h1&#39;, &#39;一则头条&#39;),\n    createElement(MyComponent, &#123;\n      props: &#123;\n        someProp: &#39;foobar&#39;\n      &#125;\n    &#125;)\n  ]\n)\n</code></pre>\n<h5 id=\"21-插件\"><a href=\"#21-插件\" class=\"headerlink\" title=\"21. 插件\"></a>21. 插件</h5><p>（1）插件是什么？<br>    插件通常用来为 Vue 添加全局功能<br>（2）怎么用？<br>    通过全局方法 Vue.use() 使用插件，它需要在你调用 new Vue() 启动应用之前完成</p>\n<pre><code>// 调用 `MyPlugin.install(Vue)`\nVue.use(MyPlugin)\n\nnew Vue(&#123;\n  // ...组件选项\n&#125;)\n</code></pre>\n<p>（3）开发插件<br>Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：</p>\n<pre><code>MyPlugin.install = function (Vue, options) &#123;\n  // 1. 添加全局方法或 property\n  Vue.myGlobalMethod = function () &#123;\n    // 逻辑...\n  &#125;\n\n  // 2. 添加全局资源\n  Vue.directive(&#39;my-directive&#39;, &#123;\n    bind (el, binding, vnode, oldVnode) &#123;\n      // 逻辑...\n    &#125;\n    ...\n  &#125;)\n\n  // 3. 注入组件选项\n  Vue.mixin(&#123;\n    created: function () &#123;\n      // 逻辑...\n    &#125;\n    ...\n  &#125;)\n\n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function (methodOptions) &#123;\n    // 逻辑...\n  &#125;\n&#125;\n</code></pre>\n<h5 id=\"22-过滤器\"><a href=\"#22-过滤器\" class=\"headerlink\" title=\"22. 过滤器\"></a>22. 过滤器</h5><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化</p>\n<pre><code>&lt;!-- 在双花括号中 --&gt;\n&#123;&#123; message | capitalize&#125;&#125;\n\n&lt;!-- 在 `v-bind` 中 --&gt;\n&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;\n\nfilters: &#123;\n    capitalize: function (value) &#123;\n        if (!value) &#123;\n            value = value.toString()\n            return value.chartAt(0).toUpperCase() + value.slice(1)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>全局注册过滤器<br>Vue.filter(‘capitalize’, function (value) {<br>    if (!value) {<br>        value = value.toString()<br>        return value.chartAt(0).toUpperCase() + value.slice(1)<br>    }<br>})</p>\n<h5 id=\"23-响应式原理\"><a href=\"#23-响应式原理\" class=\"headerlink\" title=\"23. 响应式原理\"></a>23. 响应式原理</h5><p><img src=\"/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/vue.png\" alt=\"vue\"><br>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染</p>\n<h5 id=\"24-测试\"><a href=\"#24-测试\" class=\"headerlink\" title=\"24. 测试\"></a>24. 测试</h5><p>（1）官方推荐测试框架Vue Testing Library (@testing-library/vue)</p>\n<p>（2）安装</p>\n<pre><code>npm install --save-dev jest @vue/test-utils\n</code></pre>\n<p>（3）添加脚本</p>\n<pre><code>// package.json\n&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;jest&quot;\n  &#125;\n&#125;\n</code></pre>\n<h5 id=\"25-Vue-API\"><a href=\"#25-Vue-API\" class=\"headerlink\" title=\"25. Vue API\"></a>25. Vue API</h5><ul>\n<li>实例<br>（1）vm.$data<br>（2）vm.$props<br>（3）vm.$el<br>  Vue 实例使用的根 DOM 元素<br>（3）vm.$options<br>  用于当前 Vue 实例的初始化选项</li>\n</ul>\n<pre><code>new Vue(&#123;\n  customOption: &#39;foo&#39;,\n  created: function () &#123;\n    console.log(this.$options.customOption) // =&gt; &#39;foo&#39;\n  &#125;\n&#125;)\n</code></pre>\n<p>（4）vm.$parent<br>    父实例，如果当前实例有的话<br>（5）vm.$root<br>    当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己<br>（6）$children<br>    当前实例的直接子组件<br>（7）vm.$slots<br>    用来访问被插槽分发的内容</p>\n<pre><code>```\n&lt;blog-post&gt;\n    &lt;template v-slot:header&gt;\n        &lt;h1&gt;About Me&lt;/h1&gt;\n    &lt;/template&gt;\n\n    &lt;p&gt;Here&#39;s some page content, which will be included in vm.$slots.default,   because it&#39;s not inside a named slot.\n    &lt;/p&gt;\n\n    &lt;template v-slot:footer&gt;\n        &lt;p&gt;Copyright 2016 Evan You&lt;/p&gt;\n    &lt;/template&gt;\n\n    &lt;p&gt;If I have some content down here, it will also be included in            vm.$slots.default.\n    &lt;/p&gt;\n&lt;/blog-post&gt;\n```\n\n```\nVue.component(&#39;blog-post&#39;, &#123;\n    render: function (createElement) &#123;\n        var header = this.$slots.header\n        var body   = this.$slots.default\n        var footer = this.$slots.footer\n        return createElement(&#39;div&#39;, [\n        createElement(&#39;header&#39;, header),\n        createElement(&#39;main&#39;, body),\n        createElement(&#39;footer&#39;, footer)\n        ])\n    &#125;\n &#125;)\n```\n</code></pre>\n<p>（8）vm.$scopedSlots<br>    用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。<br>（9）vm.$refs<br>    一个对象，持有注册过 ref attribute 的所有 DOM 元素和组件实例<br>（10）vm.$isServer<br>    当前 Vue 实例是否运行于服务器<br>（11）vm.$attrs<br>    包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用<br>（12）vm.$listeners<br>    包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件——在创建更高层次的组件时非常有用</p>\n<ul>\n<li><p>实例方法<br>（1）vm.$watch( expOrFn, callback, [options] )<br>  观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。表达式只接受简单的键路径。对于更复杂的表达式，用一个函数取代</p>\n<pre><code>    // 键路径\n    vm.$watch(&#39;a.b.c&#39;, function (newVal, oldVal) &#123;\n    // 做点什么\n    &#125;)\n\n    // 函数\n    vm.$watch(\n    function () &#123;\n        // 表达式 `this.a + this.b` 每次得出一个不同的结果时\n        // 处理函数都会被调用。\n        // 这就像监听一个未被定义的计算属性\n        return this.a + this.b\n    &#125;,\n    function (newVal, oldVal) &#123;\n        // 做点什么\n    &#125;\n    )\n</code></pre>\n<p>  vm.$watch 返回一个取消观察函数，用来停止触发回调：</p>\n<pre><code>var unwatch = vm.$watch(&#39;a&#39;, cb)\n// 之后取消观察\nunwatch()\n</code></pre>\n<p>  选项：deep</p>\n<pre><code>  为了发现对象内部值的变化，可以在选项参数中指定 deep: true。注意监听数组的变更不需要这么做。\n</code></pre>\n<pre><code>    vm.$watch(&#39;someObject&#39;, callback, &#123;\n        deep: true\n    &#125;)\n    vm.someObject.nestedValue = 123\n    // callback is fired\n</code></pre>\n</li>\n</ul>\n<pre><code>选项：immediate\n    在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调：\n\n```\n    vm.$watch(&#39;a&#39;, callback, &#123;\n        immediate: true\n    &#125;)\n    // 立即以 `a` 的当前值触发回调\n```\n</code></pre>\n<p>（2）vm.$set( target, propertyName/index, value )<br>    这是全局 Vue.set 的别名</p>\n<p>（3）vm.$delete( target, propertyName/index )<br>    这是全局 Vue.delete 的别名</p>\n<p>（4）vm.$on( event, callback )<br>    监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数</p>\n<pre><code>```\nvm.$on(&#39;test&#39;, function (msg) &#123;\n    console.log(msg)\n&#125;)\nvm.$emit(&#39;test&#39;, &#39;hi&#39;)\n// =&gt; &quot;hi&quot;\n```\n</code></pre>\n<p>（5）$once<br>    监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除<br>（6）vm.$off( [event, callback] )<br>    移除自定义事件监听器<br>    - 如果没有提供参数，则移除所有的事件监听器；</p>\n<pre><code>- 如果只提供了事件，则移除该事件所有的监听器；\n\n- 如果同时提供了事件与回调，则只移除这个回调的监听器。\n</code></pre>\n<p>（7）vm.$emit( eventName, […args] )<br>    触发当前实例上的事件。附加参数都会传给监听器回调<br>    <code>    Vue.component(&#39;welcome-button&#39;, &#123;         template: `             &lt;button v-on:click=&quot;$emit(&#39;welcome&#39;)&quot;&gt;                 Click me to be welcomed             &lt;/button&gt;`     &#125;)    </code></p>\n<pre><code>```\n&lt;div id=&quot;emit-example-simple&quot;&gt;\n    &lt;welcome-button @welcome=&quot;sayHi&quot;&gt;&lt;/welcome-button&gt;\n&lt;/div&gt;\n```\n\n```\nnew Vue(&#123;\n    el: &#39;#emit-example-simple&#39;,\n    methods: &#123;\n        sayHi: function () &#123;\n        alert(&#39;Hi!&#39;)\n        &#125;\n    &#125;\n&#125;)\n```\n</code></pre>\n<p>（8）vm.$mount( [elementOrSelector] )<br>    如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素可以使用 vm.$mount() 手动地挂载一个未挂载的实例</p>\n<p>（9）vm.$nextTick( [callback] )<br>    将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上</p>\n<p>（10）vm.$destroy()<br>     完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器  </p>\n<p>（11）vm.$forceUpdate()<br>    迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件</p>\n"},{"title":"快速入门react","date":"2021-10-31T13:22:53.000Z","_content":"1. React是什么？\nReact 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库\n\n2. JSX\nreact提供的语法糖，可以在js文件中插入html片段\n（1）jsx中的class应该写成className\n```\n<input className=\"username\" />\n```\n\n（2）注释\n```\n{/* 注释内容 */}\n```\n\n3. 组件和props\n（1）类组件\n```\nimport React from 'react'\nclass MyComponent extends Ract.Component {\n    render () {\n        return {\n            <div>Hello React</div>\n        }\n    }\n}\n```\n\n（2）函数组件\n```\nfunction MyComponent () {\n    return <div>Hello React</div>\n}\n```\n\n（3）组件状态\n```\nimport React from 'react'\nclass MyComponent extends React.Component {\n    this.state = {\n        num: 0\n    }\n    render () {\n        return {\n            <p>{this.state.num}</p>\n        }\n    }\n}\n```\n\n3. 生命周期\ncomponentDidMount   在组件已经被渲染到 DOM 中后运行\ncomponentWillUnmount\n\n4. state\n```\nclass Clock extends React.Component {\n    constructor (props) {\n        super(props)\n        this.state = {date: new Date()}\n    }\n    componentDidMount () {\n        this.timerID = setInterval(() => {\n            this.tick()\n        },1000)\n    }\n    componentWillUnmount () {\n        clearInterval(this.timerID)\n    }\n    tick () {\n        this.setState({\n            date: new Date()\n        })\n    }\n    render () {\n        return {\n            <div>\n                <h2>{this.state.date}</h2>\n            </div>\n        }\n    }\n}\n```\n总结：\n1）不要直接修改State\n2) State的更新可能是异步的\n3）State的更新会被合并\n\n5. 事件处理\n```\nclass Toggle extends React.Component {\n    constructor (props) {\n        super(props)\n        this.state = {isToggleOn: true}\n        // 为了在回调中使用 `this`，这个绑定是必不可少的\n        this.handlerClick = this.handleClick.bind(this)\n    }\n    handlerClick () {\n        this.setState(state => {\n            isToggleOn: !state.isToggleOn\n        })\n    }\n    render () {\n        return {\n            <button onClick={}></button>\n        }\n    }\n}\n```\n在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined\n\n解决this绑定问题的两种方法：\n方法一：\n```\nclass LoginButton extends React.Component {\n    // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n    // 注意: 这是 *实验性* 语法。\n    handlerClick = () => {\n        console.log(this)\n    }\n    render () {\n        return {\n            <button onClick={this.handlerClick}>\n                {this.state.isToggleOn ? 'ON' : 'OFF'}\n            </button>\n        }\n    }\n}\n```\n方法二：\n```\nclass LoggingButton extends React.Component {\n  handleClick() {\n    console.log('this is:', this);\n  }\n\n  render() {\n    // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n    return (\n      <button onClick={() => this.handleClick()}>\n        Click me\n      </button>\n    );\n  }\n}\n```\n\n向事件处理程序传递参数\n```\n<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>\n<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>\n```\n\n注意事项：\n1）React 事件的命名采用小驼峰式（camelCase），而不是纯小写\n2）使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串\n\n8. 条件渲染\n\n9. 列表\n\n10. 高阶组件\n\n11. 状态提升\n\n12. 表单\n\n13. context\n\n","source":"_posts/快速入门react.md","raw":"---\ntitle: 快速入门react\ndate: 2021-10-31 21:22:53\ntags:\n---\n1. React是什么？\nReact 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库\n\n2. JSX\nreact提供的语法糖，可以在js文件中插入html片段\n（1）jsx中的class应该写成className\n```\n<input className=\"username\" />\n```\n\n（2）注释\n```\n{/* 注释内容 */}\n```\n\n3. 组件和props\n（1）类组件\n```\nimport React from 'react'\nclass MyComponent extends Ract.Component {\n    render () {\n        return {\n            <div>Hello React</div>\n        }\n    }\n}\n```\n\n（2）函数组件\n```\nfunction MyComponent () {\n    return <div>Hello React</div>\n}\n```\n\n（3）组件状态\n```\nimport React from 'react'\nclass MyComponent extends React.Component {\n    this.state = {\n        num: 0\n    }\n    render () {\n        return {\n            <p>{this.state.num}</p>\n        }\n    }\n}\n```\n\n3. 生命周期\ncomponentDidMount   在组件已经被渲染到 DOM 中后运行\ncomponentWillUnmount\n\n4. state\n```\nclass Clock extends React.Component {\n    constructor (props) {\n        super(props)\n        this.state = {date: new Date()}\n    }\n    componentDidMount () {\n        this.timerID = setInterval(() => {\n            this.tick()\n        },1000)\n    }\n    componentWillUnmount () {\n        clearInterval(this.timerID)\n    }\n    tick () {\n        this.setState({\n            date: new Date()\n        })\n    }\n    render () {\n        return {\n            <div>\n                <h2>{this.state.date}</h2>\n            </div>\n        }\n    }\n}\n```\n总结：\n1）不要直接修改State\n2) State的更新可能是异步的\n3）State的更新会被合并\n\n5. 事件处理\n```\nclass Toggle extends React.Component {\n    constructor (props) {\n        super(props)\n        this.state = {isToggleOn: true}\n        // 为了在回调中使用 `this`，这个绑定是必不可少的\n        this.handlerClick = this.handleClick.bind(this)\n    }\n    handlerClick () {\n        this.setState(state => {\n            isToggleOn: !state.isToggleOn\n        })\n    }\n    render () {\n        return {\n            <button onClick={}></button>\n        }\n    }\n}\n```\n在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined\n\n解决this绑定问题的两种方法：\n方法一：\n```\nclass LoginButton extends React.Component {\n    // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n    // 注意: 这是 *实验性* 语法。\n    handlerClick = () => {\n        console.log(this)\n    }\n    render () {\n        return {\n            <button onClick={this.handlerClick}>\n                {this.state.isToggleOn ? 'ON' : 'OFF'}\n            </button>\n        }\n    }\n}\n```\n方法二：\n```\nclass LoggingButton extends React.Component {\n  handleClick() {\n    console.log('this is:', this);\n  }\n\n  render() {\n    // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n    return (\n      <button onClick={() => this.handleClick()}>\n        Click me\n      </button>\n    );\n  }\n}\n```\n\n向事件处理程序传递参数\n```\n<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>\n<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>\n```\n\n注意事项：\n1）React 事件的命名采用小驼峰式（camelCase），而不是纯小写\n2）使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串\n\n8. 条件渲染\n\n9. 列表\n\n10. 高阶组件\n\n11. 状态提升\n\n12. 表单\n\n13. context\n\n","slug":"快速入门react","published":1,"updated":"2021-12-20T08:01:54.221Z","_id":"ckxee3qmg0004w5186tes87hk","comments":1,"layout":"post","photos":[],"link":"","content":"<ol>\n<li><p>React是什么？<br>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库</p>\n</li>\n<li><p>JSX<br>react提供的语法糖，可以在js文件中插入html片段<br>（1）jsx中的class应该写成className</p>\n<pre><code>&lt;input className=&quot;username&quot; /&gt;\n</code></pre>\n</li>\n</ol>\n<p>（2）注释</p>\n<pre><code>&#123;/* 注释内容 */&#125;\n</code></pre>\n<ol start=\"3\">\n<li>组件和props<br>（1）类组件<pre><code>import React from &#39;react&#39;\nclass MyComponent extends Ract.Component &#123;\n render () &#123;\n     return &#123;\n         &lt;div&gt;Hello React&lt;/div&gt;\n     &#125;\n &#125;\n&#125;\n</code></pre>\n</li>\n</ol>\n<p>（2）函数组件</p>\n<pre><code>function MyComponent () &#123;\n    return &lt;div&gt;Hello React&lt;/div&gt;\n&#125;\n</code></pre>\n<p>（3）组件状态</p>\n<pre><code>import React from &#39;react&#39;\nclass MyComponent extends React.Component &#123;\n    this.state = &#123;\n        num: 0\n    &#125;\n    render () &#123;\n        return &#123;\n            &lt;p&gt;&#123;this.state.num&#125;&lt;/p&gt;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li><p>生命周期<br>componentDidMount   在组件已经被渲染到 DOM 中后运行<br>componentWillUnmount</p>\n</li>\n<li><p>state</p>\n<pre><code>class Clock extends React.Component &#123;\n constructor (props) &#123;\n     super(props)\n     this.state = &#123;date: new Date()&#125;\n &#125;\n componentDidMount () &#123;\n     this.timerID = setInterval(() =&gt; &#123;\n         this.tick()\n     &#125;,1000)\n &#125;\n componentWillUnmount () &#123;\n     clearInterval(this.timerID)\n &#125;\n tick () &#123;\n     this.setState(&#123;\n         date: new Date()\n     &#125;)\n &#125;\n render () &#123;\n     return &#123;\n         &lt;div&gt;\n             &lt;h2&gt;&#123;this.state.date&#125;&lt;/h2&gt;\n         &lt;/div&gt;\n     &#125;\n &#125;\n&#125;\n</code></pre>\n<p>总结：<br>1）不要直接修改State</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>State的更新可能是异步的<br>3）State的更新会被合并</li>\n</ol>\n<ol start=\"5\">\n<li>事件处理<pre><code>class Toggle extends React.Component &#123;\n constructor (props) &#123;\n     super(props)\n     this.state = &#123;isToggleOn: true&#125;\n     // 为了在回调中使用 `this`，这个绑定是必不可少的\n     this.handlerClick = this.handleClick.bind(this)\n &#125;\n handlerClick () &#123;\n     this.setState(state =&gt; &#123;\n         isToggleOn: !state.isToggleOn\n     &#125;)\n &#125;\n render () &#123;\n     return &#123;\n         &lt;button onClick=&#123;&#125;&gt;&lt;/button&gt;\n     &#125;\n &#125;\n&#125;\n</code></pre>\n在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined</li>\n</ol>\n<p>解决this绑定问题的两种方法：<br>方法一：</p>\n<pre><code>class LoginButton extends React.Component &#123;\n    // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n    // 注意: 这是 *实验性* 语法。\n    handlerClick = () =&gt; &#123;\n        console.log(this)\n    &#125;\n    render () &#123;\n        return &#123;\n            &lt;button onClick=&#123;this.handlerClick&#125;&gt;\n                &#123;this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;&#125;\n            &lt;/button&gt;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>方法二：</p>\n<pre><code>class LoggingButton extends React.Component &#123;\n  handleClick() &#123;\n    console.log(&#39;this is:&#39;, this);\n  &#125;\n\n  render() &#123;\n    // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n    return (\n      &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;\n        Click me\n      &lt;/button&gt;\n    );\n  &#125;\n&#125;\n</code></pre>\n<p>向事件处理程序传递参数</p>\n<pre><code>&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;\n&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;\n</code></pre>\n<p>注意事项：<br>1）React 事件的命名采用小驼峰式（camelCase），而不是纯小写<br>2）使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串</p>\n<ol start=\"8\">\n<li><p>条件渲染</p>\n</li>\n<li><p>列表</p>\n</li>\n<li><p>高阶组件</p>\n</li>\n<li><p>状态提升</p>\n</li>\n<li><p>表单</p>\n</li>\n<li><p>context</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>React是什么？<br>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库</p>\n</li>\n<li><p>JSX<br>react提供的语法糖，可以在js文件中插入html片段<br>（1）jsx中的class应该写成className</p>\n<pre><code>&lt;input className=&quot;username&quot; /&gt;\n</code></pre>\n</li>\n</ol>\n<p>（2）注释</p>\n<pre><code>&#123;/* 注释内容 */&#125;\n</code></pre>\n<ol start=\"3\">\n<li>组件和props<br>（1）类组件<pre><code>import React from &#39;react&#39;\nclass MyComponent extends Ract.Component &#123;\n render () &#123;\n     return &#123;\n         &lt;div&gt;Hello React&lt;/div&gt;\n     &#125;\n &#125;\n&#125;\n</code></pre>\n</li>\n</ol>\n<p>（2）函数组件</p>\n<pre><code>function MyComponent () &#123;\n    return &lt;div&gt;Hello React&lt;/div&gt;\n&#125;\n</code></pre>\n<p>（3）组件状态</p>\n<pre><code>import React from &#39;react&#39;\nclass MyComponent extends React.Component &#123;\n    this.state = &#123;\n        num: 0\n    &#125;\n    render () &#123;\n        return &#123;\n            &lt;p&gt;&#123;this.state.num&#125;&lt;/p&gt;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li><p>生命周期<br>componentDidMount   在组件已经被渲染到 DOM 中后运行<br>componentWillUnmount</p>\n</li>\n<li><p>state</p>\n<pre><code>class Clock extends React.Component &#123;\n constructor (props) &#123;\n     super(props)\n     this.state = &#123;date: new Date()&#125;\n &#125;\n componentDidMount () &#123;\n     this.timerID = setInterval(() =&gt; &#123;\n         this.tick()\n     &#125;,1000)\n &#125;\n componentWillUnmount () &#123;\n     clearInterval(this.timerID)\n &#125;\n tick () &#123;\n     this.setState(&#123;\n         date: new Date()\n     &#125;)\n &#125;\n render () &#123;\n     return &#123;\n         &lt;div&gt;\n             &lt;h2&gt;&#123;this.state.date&#125;&lt;/h2&gt;\n         &lt;/div&gt;\n     &#125;\n &#125;\n&#125;\n</code></pre>\n<p>总结：<br>1）不要直接修改State</p>\n</li>\n</ol>\n<ol start=\"2\">\n<li>State的更新可能是异步的<br>3）State的更新会被合并</li>\n</ol>\n<ol start=\"5\">\n<li>事件处理<pre><code>class Toggle extends React.Component &#123;\n constructor (props) &#123;\n     super(props)\n     this.state = &#123;isToggleOn: true&#125;\n     // 为了在回调中使用 `this`，这个绑定是必不可少的\n     this.handlerClick = this.handleClick.bind(this)\n &#125;\n handlerClick () &#123;\n     this.setState(state =&gt; &#123;\n         isToggleOn: !state.isToggleOn\n     &#125;)\n &#125;\n render () &#123;\n     return &#123;\n         &lt;button onClick=&#123;&#125;&gt;&lt;/button&gt;\n     &#125;\n &#125;\n&#125;\n</code></pre>\n在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined</li>\n</ol>\n<p>解决this绑定问题的两种方法：<br>方法一：</p>\n<pre><code>class LoginButton extends React.Component &#123;\n    // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n    // 注意: 这是 *实验性* 语法。\n    handlerClick = () =&gt; &#123;\n        console.log(this)\n    &#125;\n    render () &#123;\n        return &#123;\n            &lt;button onClick=&#123;this.handlerClick&#125;&gt;\n                &#123;this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;&#125;\n            &lt;/button&gt;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>方法二：</p>\n<pre><code>class LoggingButton extends React.Component &#123;\n  handleClick() &#123;\n    console.log(&#39;this is:&#39;, this);\n  &#125;\n\n  render() &#123;\n    // 此语法确保 `handleClick` 内的 `this` 已被绑定。\n    return (\n      &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;\n        Click me\n      &lt;/button&gt;\n    );\n  &#125;\n&#125;\n</code></pre>\n<p>向事件处理程序传递参数</p>\n<pre><code>&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;\n&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;\n</code></pre>\n<p>注意事项：<br>1）React 事件的命名采用小驼峰式（camelCase），而不是纯小写<br>2）使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串</p>\n<ol start=\"8\">\n<li><p>条件渲染</p>\n</li>\n<li><p>列表</p>\n</li>\n<li><p>高阶组件</p>\n</li>\n<li><p>状态提升</p>\n</li>\n<li><p>表单</p>\n</li>\n<li><p>context</p>\n</li>\n</ol>\n"},{"title":"快速学会echarts","date":"2021-02-20T06:49:37.000Z","_content":"1. 使用步骤\n(1）引入echarts.js文件\n(2) 准备一个呈现图表的盒子\n(3）初始化echarts实例对象\n(4）准备配置项\n(5）将配置设置给echarts实例对象\n\n2.演示代码\n```\n<html>\n<head>\n<meta chartset=\"utf-8\">\n// 步骤1:引入echarts.js文件\n<script src=“lib/echarts.js\"></script>\n</head>\n<body>\n<!— 步骤2:准备一个呈现图标的盒子 -->\n<div id=\"app\" style=\"width: 600px; height: 400px\"></div>\n<script>\n    <!--步骤3: 初始化实例对象-->\n    var mCharts = echarts.init(document.getElementById(‘app’)\n    <!--步骤4: 准备配置—>\n    var options = {\n        xAxis: {\n            type: ‘category’,\n            data: [‘carr’, ‘jack’, ‘lily']\n        },\n        yAxis: {\n            type: ‘value'\n        },\n        series: [\n            {\n                name: ‘语文’,\n                type: ‘bar’,\n                data: [90, 80, 70]\n            }\n        ]\n    }\n    <!—步骤5: 将配置项设置给echarts实例—>\n    mCharts.setOption(option)\n</script>\n</body>\n</html>\n```\n\n3. 配置说明\nxAxis   // 类目轴\nyAxis   // 数值轴\nseries  // 系列列表\ntitle   // 图表标题\ntooltip // 鼠标滑过或点击柱时的提示\ntoolbox // 导出、重置、视图\nlegend  // 图例\n\n// 配置演示\n```\n// 图表标题\ntitle: {\n    text: '成绩展示',\n    textStyle: {\n        color: 'red',\n    },\n    borderWidth: 5,\n    left: 30,\n    top: 10\n}\n\n// 鼠标滑过或点击柱时的提示\ntooltip: {\n    trigger: 'item' | 'axis',   // 触发类型\n    triggerOn: 'mouseover' | 'click'    // 触发时机\n    formatter: '{a}的成绩是{b}' // 自定义显示类容\n}\n\n// 图例\nlegend: {\n    data: [‘语文’, '数学']\n}\n```\n4. 配置柱状图\n```\nvar options = {\n    title: {\n        text: '柱状图'\n    },\n    tooltip: {},\n    legend: {\n        data:['销量']\n    },\n    xAxis: {\n        data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"]\n    },\n    yAxis: {},\n    series: [{\n        name: '销量',\n        type: 'bar',\n        data: [5, 20, 36, 10, 10, 20]\n    }]\n}\n```\n![效果展示](bar.png)\n\n5. 配置折线图\n```\nvar options = {\n    title: {\n        text: '折线图'\n    },\n    xAxis: {\n        type: 'category',\n        // 是否贴紧Y轴边缘\n        boundaryGap: false,\n        data: ['一月', '二月', '三月']\n    },\n    yAxis: {\n        // 对与值比较大，而相差又比较小的值，会显得折线波动不明显，将scale设为true，会以最小值作为起始值\n        scale: true\n    },\n    series: [\n        {\n            type: 'line',\n            data: [3000, 2880, 4000],\n            markPoint: {\n                // 显示最大最小值\n                data: [\n                    {\n                        type: 'max'\n                    },\n                    {\n                        type: 'min'\n                    }\n                ]\n            },\n            markLine: {\n                // 显示平均值\n                data: [\n                    {\n                        type: 'average'\n                    }\n                ]\n            },\n            // 标记指定区间\n            markArea: {\n                data: [\n                    [\n                        {\n                            xAxis: '一月'\n                        },\n                        {\n                            xAxis: '二月'\n                        }\n                    ]\n                ]\n            },\n            // 将折线变为平滑曲线\n            smooth: true,\n            // 折现样式 color: 颜色 type: solid 实线 dashed 点线 \n            lineStyle: {\n                color: 'green',\n                type: 'dashed'\n            },\n            // 折线区间填充样式\n            areaStyle: {\n                color: 'pink'\n            }\n        }\n    ]\n}\n```\n![效果展示](line.png)\n\n6. 配置散点图\n```\n\n```\n\n7. 配置饼图\n```\nvar options = {\n    title: {\n        text: '饼图'\n    },\n    series: [\n        {\n            type: 'pie',\n            data: [\n                {\n                    name: '淘宝',\n                    value: 1000\n                },\n                {\n                    name: '京东',\n                    value: 1300\n                },\n                {\n                    name: '拼多多',\n                    value: 1200\n                },\n            ],\n            laebl: {\n\n            },\n            // radius: 20,\n            // radius: ['50%', '70%'],  // 设为圆环图，第一个是内圆半径，第二个是外圆半径\n            roseType: 'radius'  // 设为南丁格尔图\n        }\n    ]\n}\n```\n![效果展示](pie.png)\n\n8. 配置雷达图\n```\n\n```\n\n9. 配置仪表盘\n```\n\n```\n","source":"_posts/快速学会echarts.md","raw":"---\ntitle: 快速学会echarts\n\ndate: 2021-2-20 14:49:37\ntags:\n---\n1. 使用步骤\n(1）引入echarts.js文件\n(2) 准备一个呈现图表的盒子\n(3）初始化echarts实例对象\n(4）准备配置项\n(5）将配置设置给echarts实例对象\n\n2.演示代码\n```\n<html>\n<head>\n<meta chartset=\"utf-8\">\n// 步骤1:引入echarts.js文件\n<script src=“lib/echarts.js\"></script>\n</head>\n<body>\n<!— 步骤2:准备一个呈现图标的盒子 -->\n<div id=\"app\" style=\"width: 600px; height: 400px\"></div>\n<script>\n    <!--步骤3: 初始化实例对象-->\n    var mCharts = echarts.init(document.getElementById(‘app’)\n    <!--步骤4: 准备配置—>\n    var options = {\n        xAxis: {\n            type: ‘category’,\n            data: [‘carr’, ‘jack’, ‘lily']\n        },\n        yAxis: {\n            type: ‘value'\n        },\n        series: [\n            {\n                name: ‘语文’,\n                type: ‘bar’,\n                data: [90, 80, 70]\n            }\n        ]\n    }\n    <!—步骤5: 将配置项设置给echarts实例—>\n    mCharts.setOption(option)\n</script>\n</body>\n</html>\n```\n\n3. 配置说明\nxAxis   // 类目轴\nyAxis   // 数值轴\nseries  // 系列列表\ntitle   // 图表标题\ntooltip // 鼠标滑过或点击柱时的提示\ntoolbox // 导出、重置、视图\nlegend  // 图例\n\n// 配置演示\n```\n// 图表标题\ntitle: {\n    text: '成绩展示',\n    textStyle: {\n        color: 'red',\n    },\n    borderWidth: 5,\n    left: 30,\n    top: 10\n}\n\n// 鼠标滑过或点击柱时的提示\ntooltip: {\n    trigger: 'item' | 'axis',   // 触发类型\n    triggerOn: 'mouseover' | 'click'    // 触发时机\n    formatter: '{a}的成绩是{b}' // 自定义显示类容\n}\n\n// 图例\nlegend: {\n    data: [‘语文’, '数学']\n}\n```\n4. 配置柱状图\n```\nvar options = {\n    title: {\n        text: '柱状图'\n    },\n    tooltip: {},\n    legend: {\n        data:['销量']\n    },\n    xAxis: {\n        data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"]\n    },\n    yAxis: {},\n    series: [{\n        name: '销量',\n        type: 'bar',\n        data: [5, 20, 36, 10, 10, 20]\n    }]\n}\n```\n![效果展示](bar.png)\n\n5. 配置折线图\n```\nvar options = {\n    title: {\n        text: '折线图'\n    },\n    xAxis: {\n        type: 'category',\n        // 是否贴紧Y轴边缘\n        boundaryGap: false,\n        data: ['一月', '二月', '三月']\n    },\n    yAxis: {\n        // 对与值比较大，而相差又比较小的值，会显得折线波动不明显，将scale设为true，会以最小值作为起始值\n        scale: true\n    },\n    series: [\n        {\n            type: 'line',\n            data: [3000, 2880, 4000],\n            markPoint: {\n                // 显示最大最小值\n                data: [\n                    {\n                        type: 'max'\n                    },\n                    {\n                        type: 'min'\n                    }\n                ]\n            },\n            markLine: {\n                // 显示平均值\n                data: [\n                    {\n                        type: 'average'\n                    }\n                ]\n            },\n            // 标记指定区间\n            markArea: {\n                data: [\n                    [\n                        {\n                            xAxis: '一月'\n                        },\n                        {\n                            xAxis: '二月'\n                        }\n                    ]\n                ]\n            },\n            // 将折线变为平滑曲线\n            smooth: true,\n            // 折现样式 color: 颜色 type: solid 实线 dashed 点线 \n            lineStyle: {\n                color: 'green',\n                type: 'dashed'\n            },\n            // 折线区间填充样式\n            areaStyle: {\n                color: 'pink'\n            }\n        }\n    ]\n}\n```\n![效果展示](line.png)\n\n6. 配置散点图\n```\n\n```\n\n7. 配置饼图\n```\nvar options = {\n    title: {\n        text: '饼图'\n    },\n    series: [\n        {\n            type: 'pie',\n            data: [\n                {\n                    name: '淘宝',\n                    value: 1000\n                },\n                {\n                    name: '京东',\n                    value: 1300\n                },\n                {\n                    name: '拼多多',\n                    value: 1200\n                },\n            ],\n            laebl: {\n\n            },\n            // radius: 20,\n            // radius: ['50%', '70%'],  // 设为圆环图，第一个是内圆半径，第二个是外圆半径\n            roseType: 'radius'  // 设为南丁格尔图\n        }\n    ]\n}\n```\n![效果展示](pie.png)\n\n8. 配置雷达图\n```\n\n```\n\n9. 配置仪表盘\n```\n\n```\n","slug":"快速学会echarts","published":1,"updated":"2021-12-20T08:23:38.927Z","_id":"ckxeevf440000y5wn7f729ji2","comments":1,"layout":"post","photos":[],"link":"","content":"<ol>\n<li>使用步骤<br>(1）引入echarts.js文件<br>(2) 准备一个呈现图表的盒子<br>(3）初始化echarts实例对象<br>(4）准备配置项<br>(5）将配置设置给echarts实例对象</li>\n</ol>\n<p>2.演示代码</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;meta chartset=&quot;utf-8&quot;&gt;\n// 步骤1:引入echarts.js文件\n&lt;script src=“lib/echarts.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;!— 步骤2:准备一个呈现图标的盒子 --&gt;\n&lt;div id=&quot;app&quot; style=&quot;width: 600px; height: 400px&quot;&gt;&lt;/div&gt;\n&lt;script&gt;\n    &lt;!--步骤3: 初始化实例对象--&gt;\n    var mCharts = echarts.init(document.getElementById(‘app’)\n    &lt;!--步骤4: 准备配置—&gt;\n    var options = &#123;\n        xAxis: &#123;\n            type: ‘category’,\n            data: [‘carr’, ‘jack’, ‘lily&#39;]\n        &#125;,\n        yAxis: &#123;\n            type: ‘value&#39;\n        &#125;,\n        series: [\n            &#123;\n                name: ‘语文’,\n                type: ‘bar’,\n                data: [90, 80, 70]\n            &#125;\n        ]\n    &#125;\n    &lt;!—步骤5: 将配置项设置给echarts实例—&gt;\n    mCharts.setOption(option)\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ol start=\"3\">\n<li>配置说明<br>xAxis   // 类目轴<br>yAxis   // 数值轴<br>series  // 系列列表<br>title   // 图表标题<br>tooltip // 鼠标滑过或点击柱时的提示<br>toolbox // 导出、重置、视图<br>legend  // 图例</li>\n</ol>\n<p>// 配置演示</p>\n<pre><code>// 图表标题\ntitle: &#123;\n    text: &#39;成绩展示&#39;,\n    textStyle: &#123;\n        color: &#39;red&#39;,\n    &#125;,\n    borderWidth: 5,\n    left: 30,\n    top: 10\n&#125;\n\n// 鼠标滑过或点击柱时的提示\ntooltip: &#123;\n    trigger: &#39;item&#39; | &#39;axis&#39;,   // 触发类型\n    triggerOn: &#39;mouseover&#39; | &#39;click&#39;    // 触发时机\n    formatter: &#39;&#123;a&#125;的成绩是&#123;b&#125;&#39; // 自定义显示类容\n&#125;\n\n// 图例\nlegend: &#123;\n    data: [‘语文’, &#39;数学&#39;]\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li><p>配置柱状图</p>\n<pre><code>var options = &#123;\n title: &#123;\n     text: &#39;柱状图&#39;\n &#125;,\n tooltip: &#123;&#125;,\n legend: &#123;\n     data:[&#39;销量&#39;]\n &#125;,\n xAxis: &#123;\n     data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]\n &#125;,\n yAxis: &#123;&#125;,\n series: [&#123;\n     name: &#39;销量&#39;,\n     type: &#39;bar&#39;,\n     data: [5, 20, 36, 10, 10, 20]\n &#125;]\n&#125;\n</code></pre>\n<p><img src=\"/2021/02/20/%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%BC%9Aecharts/bar.png\" alt=\"效果展示\"></p>\n</li>\n<li><p>配置折线图</p>\n<pre><code>var options = &#123;\n title: &#123;\n     text: &#39;折线图&#39;\n &#125;,\n xAxis: &#123;\n     type: &#39;category&#39;,\n     // 是否贴紧Y轴边缘\n     boundaryGap: false,\n     data: [&#39;一月&#39;, &#39;二月&#39;, &#39;三月&#39;]\n &#125;,\n yAxis: &#123;\n     // 对与值比较大，而相差又比较小的值，会显得折线波动不明显，将scale设为true，会以最小值作为起始值\n     scale: true\n &#125;,\n series: [\n     &#123;\n         type: &#39;line&#39;,\n         data: [3000, 2880, 4000],\n         markPoint: &#123;\n             // 显示最大最小值\n             data: [\n                 &#123;\n                     type: &#39;max&#39;\n                 &#125;,\n                 &#123;\n                     type: &#39;min&#39;\n                 &#125;\n             ]\n         &#125;,\n         markLine: &#123;\n             // 显示平均值\n             data: [\n                 &#123;\n                     type: &#39;average&#39;\n                 &#125;\n             ]\n         &#125;,\n         // 标记指定区间\n         markArea: &#123;\n             data: [\n                 [\n                     &#123;\n                         xAxis: &#39;一月&#39;\n                     &#125;,\n                     &#123;\n                         xAxis: &#39;二月&#39;\n                     &#125;\n                 ]\n             ]\n         &#125;,\n         // 将折线变为平滑曲线\n         smooth: true,\n         // 折现样式 color: 颜色 type: solid 实线 dashed 点线 \n         lineStyle: &#123;\n             color: &#39;green&#39;,\n             type: &#39;dashed&#39;\n         &#125;,\n         // 折线区间填充样式\n         areaStyle: &#123;\n             color: &#39;pink&#39;\n         &#125;\n     &#125;\n ]\n&#125;\n</code></pre>\n<p><img src=\"/2021/02/20/%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%BC%9Aecharts/line.png\" alt=\"效果展示\"></p>\n</li>\n<li><p>配置散点图<br>```</p>\n</li>\n</ol>\n<pre><code>\n7. 配置饼图\n</code></pre>\n<p>var options = {<br>    title: {<br>        text: ‘饼图’<br>    },<br>    series: [<br>        {<br>            type: ‘pie’,<br>            data: [<br>                {<br>                    name: ‘淘宝’,<br>                    value: 1000<br>                },<br>                {<br>                    name: ‘京东’,<br>                    value: 1300<br>                },<br>                {<br>                    name: ‘拼多多’,<br>                    value: 1200<br>                },<br>            ],<br>            laebl: {</p>\n<pre><code>        &#125;,\n        // radius: 20,\n        // radius: [&#39;50%&#39;, &#39;70%&#39;],  // 设为圆环图，第一个是内圆半径，第二个是外圆半径\n        roseType: &#39;radius&#39;  // 设为南丁格尔图\n    &#125;\n]\n</code></pre>\n<p>}</p>\n<pre><code>![效果展示](pie.png)\n\n8. 配置雷达图\n</code></pre>\n<pre><code>\n9. 配置仪表盘\n</code></pre>\n<pre><code>\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>使用步骤<br>(1）引入echarts.js文件<br>(2) 准备一个呈现图表的盒子<br>(3）初始化echarts实例对象<br>(4）准备配置项<br>(5）将配置设置给echarts实例对象</li>\n</ol>\n<p>2.演示代码</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n&lt;meta chartset=&quot;utf-8&quot;&gt;\n// 步骤1:引入echarts.js文件\n&lt;script src=“lib/echarts.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;!— 步骤2:准备一个呈现图标的盒子 --&gt;\n&lt;div id=&quot;app&quot; style=&quot;width: 600px; height: 400px&quot;&gt;&lt;/div&gt;\n&lt;script&gt;\n    &lt;!--步骤3: 初始化实例对象--&gt;\n    var mCharts = echarts.init(document.getElementById(‘app’)\n    &lt;!--步骤4: 准备配置—&gt;\n    var options = &#123;\n        xAxis: &#123;\n            type: ‘category’,\n            data: [‘carr’, ‘jack’, ‘lily&#39;]\n        &#125;,\n        yAxis: &#123;\n            type: ‘value&#39;\n        &#125;,\n        series: [\n            &#123;\n                name: ‘语文’,\n                type: ‘bar’,\n                data: [90, 80, 70]\n            &#125;\n        ]\n    &#125;\n    &lt;!—步骤5: 将配置项设置给echarts实例—&gt;\n    mCharts.setOption(option)\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ol start=\"3\">\n<li>配置说明<br>xAxis   // 类目轴<br>yAxis   // 数值轴<br>series  // 系列列表<br>title   // 图表标题<br>tooltip // 鼠标滑过或点击柱时的提示<br>toolbox // 导出、重置、视图<br>legend  // 图例</li>\n</ol>\n<p>// 配置演示</p>\n<pre><code>// 图表标题\ntitle: &#123;\n    text: &#39;成绩展示&#39;,\n    textStyle: &#123;\n        color: &#39;red&#39;,\n    &#125;,\n    borderWidth: 5,\n    left: 30,\n    top: 10\n&#125;\n\n// 鼠标滑过或点击柱时的提示\ntooltip: &#123;\n    trigger: &#39;item&#39; | &#39;axis&#39;,   // 触发类型\n    triggerOn: &#39;mouseover&#39; | &#39;click&#39;    // 触发时机\n    formatter: &#39;&#123;a&#125;的成绩是&#123;b&#125;&#39; // 自定义显示类容\n&#125;\n\n// 图例\nlegend: &#123;\n    data: [‘语文’, &#39;数学&#39;]\n&#125;\n</code></pre>\n<ol start=\"4\">\n<li><p>配置柱状图</p>\n<pre><code>var options = &#123;\n title: &#123;\n     text: &#39;柱状图&#39;\n &#125;,\n tooltip: &#123;&#125;,\n legend: &#123;\n     data:[&#39;销量&#39;]\n &#125;,\n xAxis: &#123;\n     data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]\n &#125;,\n yAxis: &#123;&#125;,\n series: [&#123;\n     name: &#39;销量&#39;,\n     type: &#39;bar&#39;,\n     data: [5, 20, 36, 10, 10, 20]\n &#125;]\n&#125;\n</code></pre>\n<p><img src=\"/2021/02/20/%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%BC%9Aecharts/bar.png\" alt=\"效果展示\"></p>\n</li>\n<li><p>配置折线图</p>\n<pre><code>var options = &#123;\n title: &#123;\n     text: &#39;折线图&#39;\n &#125;,\n xAxis: &#123;\n     type: &#39;category&#39;,\n     // 是否贴紧Y轴边缘\n     boundaryGap: false,\n     data: [&#39;一月&#39;, &#39;二月&#39;, &#39;三月&#39;]\n &#125;,\n yAxis: &#123;\n     // 对与值比较大，而相差又比较小的值，会显得折线波动不明显，将scale设为true，会以最小值作为起始值\n     scale: true\n &#125;,\n series: [\n     &#123;\n         type: &#39;line&#39;,\n         data: [3000, 2880, 4000],\n         markPoint: &#123;\n             // 显示最大最小值\n             data: [\n                 &#123;\n                     type: &#39;max&#39;\n                 &#125;,\n                 &#123;\n                     type: &#39;min&#39;\n                 &#125;\n             ]\n         &#125;,\n         markLine: &#123;\n             // 显示平均值\n             data: [\n                 &#123;\n                     type: &#39;average&#39;\n                 &#125;\n             ]\n         &#125;,\n         // 标记指定区间\n         markArea: &#123;\n             data: [\n                 [\n                     &#123;\n                         xAxis: &#39;一月&#39;\n                     &#125;,\n                     &#123;\n                         xAxis: &#39;二月&#39;\n                     &#125;\n                 ]\n             ]\n         &#125;,\n         // 将折线变为平滑曲线\n         smooth: true,\n         // 折现样式 color: 颜色 type: solid 实线 dashed 点线 \n         lineStyle: &#123;\n             color: &#39;green&#39;,\n             type: &#39;dashed&#39;\n         &#125;,\n         // 折线区间填充样式\n         areaStyle: &#123;\n             color: &#39;pink&#39;\n         &#125;\n     &#125;\n ]\n&#125;\n</code></pre>\n<p><img src=\"/2021/02/20/%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%BC%9Aecharts/line.png\" alt=\"效果展示\"></p>\n</li>\n<li><p>配置散点图<br>```</p>\n</li>\n</ol>\n<pre><code>\n7. 配置饼图\n</code></pre>\n<p>var options = {<br>    title: {<br>        text: ‘饼图’<br>    },<br>    series: [<br>        {<br>            type: ‘pie’,<br>            data: [<br>                {<br>                    name: ‘淘宝’,<br>                    value: 1000<br>                },<br>                {<br>                    name: ‘京东’,<br>                    value: 1300<br>                },<br>                {<br>                    name: ‘拼多多’,<br>                    value: 1200<br>                },<br>            ],<br>            laebl: {</p>\n<pre><code>        &#125;,\n        // radius: 20,\n        // radius: [&#39;50%&#39;, &#39;70%&#39;],  // 设为圆环图，第一个是内圆半径，第二个是外圆半径\n        roseType: &#39;radius&#39;  // 设为南丁格尔图\n    &#125;\n]\n</code></pre>\n<p>}</p>\n<pre><code>![效果展示](pie.png)\n\n8. 配置雷达图\n</code></pre>\n<pre><code>\n9. 配置仪表盘\n</code></pre>\n<pre><code>\n</code></pre>\n"},{"title":"三分钟了解Github Actions","date":"2021-12-01T06:48:44.000Z","_content":"\n##### 1. 何为Github Actions?\n简单解释就是在Github中可以直接引用别人写好的集成脚本，使自己的项目快速实现持续集成\n\n##### 2. 配置字段\n- workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow\n- job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务\n- step（步骤）：每个 job 由多个 step 构成，一步步完成\n- action （动作）：每个 step 可以依次执行一个或多个命令（action）\n\n##### 3. 最佳实践\n需求：每次触发更新机制后将代码自动打包并上传部署到服务器\n\n```\nname: deploy for dev\non:\n    push: \n        branchs:\n            - master\n        paths:\n            - '.github/workflows'\n            - 'src/**'\njobs:\n    test:\n        runs-on: ubuntu-lastest\n        steps:\n            - users: actions/checkout\n            - name: set ssh key\n                run: |\n                    mkdir -p ~/.ssh/\n                    echo \"${{secrets.MAC_LOCAL}}\" > ~/.ssh/id_rsa\n                    chmod 600 ~/.ssh/id_rsa\n                    ssh-keyscan \"39.100.253.134\" >> ~/.ssh/known_hosts\n            - name: deploy\n                ssh carr@39.100.253.134\n                cd /home/carr\n                git remote add origin https://github.com:${{secrets.MAC_LOCAL}}@github.com/lzjdp/automation\n                git pull origin master\n                git remote remove origin\n```","source":"_posts/三分钟了解gitactions.md","raw":"---\ntitle: 三分钟了解Github Actions\ndate: 2021-12-1 14:48:44\ntags:\n---\n\n##### 1. 何为Github Actions?\n简单解释就是在Github中可以直接引用别人写好的集成脚本，使自己的项目快速实现持续集成\n\n##### 2. 配置字段\n- workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow\n- job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务\n- step（步骤）：每个 job 由多个 step 构成，一步步完成\n- action （动作）：每个 step 可以依次执行一个或多个命令（action）\n\n##### 3. 最佳实践\n需求：每次触发更新机制后将代码自动打包并上传部署到服务器\n\n```\nname: deploy for dev\non:\n    push: \n        branchs:\n            - master\n        paths:\n            - '.github/workflows'\n            - 'src/**'\njobs:\n    test:\n        runs-on: ubuntu-lastest\n        steps:\n            - users: actions/checkout\n            - name: set ssh key\n                run: |\n                    mkdir -p ~/.ssh/\n                    echo \"${{secrets.MAC_LOCAL}}\" > ~/.ssh/id_rsa\n                    chmod 600 ~/.ssh/id_rsa\n                    ssh-keyscan \"39.100.253.134\" >> ~/.ssh/known_hosts\n            - name: deploy\n                ssh carr@39.100.253.134\n                cd /home/carr\n                git remote add origin https://github.com:${{secrets.MAC_LOCAL}}@github.com/lzjdp/automation\n                git pull origin master\n                git remote remove origin\n```","slug":"三分钟了解gitactions","published":1,"updated":"2021-12-20T09:59:20.625Z","_id":"ckxeg8wki0002y5wn5jf7ewok","comments":1,"layout":"post","photos":[],"link":"","content":"<h5 id=\"1-何为Github-Actions\"><a href=\"#1-何为Github-Actions\" class=\"headerlink\" title=\"1. 何为Github Actions?\"></a>1. 何为Github Actions?</h5><p>简单解释就是在Github中可以直接引用别人写好的集成脚本，使自己的项目快速实现持续集成</p>\n<h5 id=\"2-配置字段\"><a href=\"#2-配置字段\" class=\"headerlink\" title=\"2. 配置字段\"></a>2. 配置字段</h5><ul>\n<li>workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow</li>\n<li>job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务</li>\n<li>step（步骤）：每个 job 由多个 step 构成，一步步完成</li>\n<li>action （动作）：每个 step 可以依次执行一个或多个命令（action）</li>\n</ul>\n<h5 id=\"3-最佳实践\"><a href=\"#3-最佳实践\" class=\"headerlink\" title=\"3. 最佳实践\"></a>3. 最佳实践</h5><p>需求：每次触发更新机制后将代码自动打包并上传部署到服务器</p>\n<pre><code>name: deploy for dev\non:\n    push: \n        branchs:\n            - master\n        paths:\n            - &#39;.github/workflows&#39;\n            - &#39;src/**&#39;\njobs:\n    test:\n        runs-on: ubuntu-lastest\n        steps:\n            - users: actions/checkout\n            - name: set ssh key\n                run: |\n                    mkdir -p ~/.ssh/\n                    echo &quot;$&#123;&#123;secrets.MAC_LOCAL&#125;&#125;&quot; &gt; ~/.ssh/id_rsa\n                    chmod 600 ~/.ssh/id_rsa\n                    ssh-keyscan &quot;39.100.253.134&quot; &gt;&gt; ~/.ssh/known_hosts\n            - name: deploy\n                ssh carr@39.100.253.134\n                cd /home/carr\n                git remote add origin https://github.com:$&#123;&#123;secrets.MAC_LOCAL&#125;&#125;@github.com/lzjdp/automation\n                git pull origin master\n                git remote remove origin\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"1-何为Github-Actions\"><a href=\"#1-何为Github-Actions\" class=\"headerlink\" title=\"1. 何为Github Actions?\"></a>1. 何为Github Actions?</h5><p>简单解释就是在Github中可以直接引用别人写好的集成脚本，使自己的项目快速实现持续集成</p>\n<h5 id=\"2-配置字段\"><a href=\"#2-配置字段\" class=\"headerlink\" title=\"2. 配置字段\"></a>2. 配置字段</h5><ul>\n<li>workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow</li>\n<li>job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务</li>\n<li>step（步骤）：每个 job 由多个 step 构成，一步步完成</li>\n<li>action （动作）：每个 step 可以依次执行一个或多个命令（action）</li>\n</ul>\n<h5 id=\"3-最佳实践\"><a href=\"#3-最佳实践\" class=\"headerlink\" title=\"3. 最佳实践\"></a>3. 最佳实践</h5><p>需求：每次触发更新机制后将代码自动打包并上传部署到服务器</p>\n<pre><code>name: deploy for dev\non:\n    push: \n        branchs:\n            - master\n        paths:\n            - &#39;.github/workflows&#39;\n            - &#39;src/**&#39;\njobs:\n    test:\n        runs-on: ubuntu-lastest\n        steps:\n            - users: actions/checkout\n            - name: set ssh key\n                run: |\n                    mkdir -p ~/.ssh/\n                    echo &quot;$&#123;&#123;secrets.MAC_LOCAL&#125;&#125;&quot; &gt; ~/.ssh/id_rsa\n                    chmod 600 ~/.ssh/id_rsa\n                    ssh-keyscan &quot;39.100.253.134&quot; &gt;&gt; ~/.ssh/known_hosts\n            - name: deploy\n                ssh carr@39.100.253.134\n                cd /home/carr\n                git remote add origin https://github.com:$&#123;&#123;secrets.MAC_LOCAL&#125;&#125;@github.com/lzjdp/automation\n                git pull origin master\n                git remote remove origin\n</code></pre>\n"}],"PostAsset":[{"_id":"source/_posts/flex使用介绍/flex_1.png","slug":"flex_1.png","post":"ckwou9u5h00089hwnfku32rr6","modified":0,"renderable":0},{"_id":"source/_posts/flex使用介绍/flex_2.png","slug":"flex_2.png","post":"ckwou9u5h00089hwnfku32rr6","modified":0,"renderable":0},{"_id":"source/_posts/flex使用介绍/flex_3.png","slug":"flex_3.png","post":"ckwou9u5h00089hwnfku32rr6","modified":0,"renderable":0},{"_id":"source/_posts/flex使用介绍/flex_4.png","slug":"flex_4.png","post":"ckwou9u5h00089hwnfku32rr6","modified":0,"renderable":0},{"_id":"source/_posts/flex使用介绍/flex_5.png","slug":"flex_5.png","post":"ckwou9u5h00089hwnfku32rr6","modified":0,"renderable":0},{"_id":"source/_posts/http介绍/httpmessage.jpeg","slug":"httpmessage.jpeg","post":"ckwou9u5o000b9hwn6te2f186","modified":0,"renderable":0},{"_id":"source/_posts/前端综合面试题/csrf.jpeg","slug":"csrf.jpeg","post":"ckwou9u67000t9hwn0lwbbhk9","modified":0,"renderable":0},{"_id":"source/_posts/vue原理初探/vue原理1.png","slug":"vue原理1.png","post":"ckxedq6200001w518a8404oav","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[],"Tag":[]}}