<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>es6入门 | Carr&#39;Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. let const       (1) let用于定义变量，const用于定义常量(2) let、const存在块级作用域(3) let不与许在同作用域内重复声明(4) const一旦声明不可改变(5) const声明不可重复(6) 不存在变量提升，必须先声明再使用                     2. 解构赋值       （1）数组解构赋值">
<meta property="og:type" content="article">
<meta property="og:title" content="es6入门">
<meta property="og:url" content="http://example.com/2021/10/29/es6%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Carr&#39;Blog">
<meta property="og:description" content="1. let const       (1) let用于定义变量，const用于定义常量(2) let、const存在块级作用域(3) let不与许在同作用域内重复声明(4) const一旦声明不可改变(5) const声明不可重复(6) 不存在变量提升，必须先声明再使用                     2. 解构赋值       （1）数组解构赋值">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-10-29T06:25:17.000Z">
<meta property="article:modified_time" content="2021-11-02T10:15:28.093Z">
<meta property="article:author" content="Carr Lu">
<meta property="article:tag" content="web前端 前端开发 html css js javascript vue react 小程序 node koa express mysql">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Carr&#39;Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Carr&#39;Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-es6入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/29/es6%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2021-10-29T06:25:17.000Z" itemprop="datePublished">2021-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      es6入门
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h5 id="1-let-const">
          <a href="#1-let-const" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-let-const" class="headerlink" title="1. let const"></a>1. let const</h5>
      <p>(1) let用于定义变量，const用于定义常量<br>(2) let、const存在块级作用域<br>(3) let不与许在同作用域内重复声明<br>(4) const一旦声明不可改变<br>(5) const声明不可重复<br>(6) 不存在变量提升，必须先声明再使用</p>

        <h5 id="2-解构赋值">
          <a href="#2-解构赋值" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-解构赋值" class="headerlink" title="2. 解构赋值"></a>2. 解构赋值</h5>
      <p>（1）数组解构赋值</p>
<pre><code>let [a, b, c] = [1, 2, 3]
let [x, , y] = [1, 2, 3]
let [head, ...tail] = [1, 2, 3, 4]
</code></pre>
<p>（2）对象解构赋值</p>
<pre><code>let &#123;foo, bar&#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;
var &#123;&#125;x, y = 5&#125; = &#123;x: 1&#125;
</code></pre>
<p>（3）字符串解构赋值</p>
<pre><code>const [a, b, c, d, e] = &#39;hello&#39;
a   // &#39;h&#39;
b   // &#39;e&#39;
c   // &#39;l&#39;
d   // &#39;l&#39;
e   // &#39;o&#39;
</code></pre>
<p>（4）函数参数解构赋值</p>
<pre><code>function add ([x, y]) &#123;
    return x + y
&#125;
add([1, 2])
</code></pre>

        <h5 id="3-函数扩展">
          <a href="#3-函数扩展" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-函数扩展" class="headerlink" title="3. 函数扩展"></a>3. 函数扩展</h5>
      <p>（1）函数参数默认值</p>
<pre><code>function log (x, y = &#39;world&#39;) &#123;
    console.log(x, y)
&#125;
log(&#39;Hello&#39;)    // Hello World
log(&#39;Hello&#39;, &#39;China&#39;)   // Hello China
</code></pre>
<p>注意：</p>
<ul>
<li>不能有同名参数</li>
<li>参数变量是默认声明的，不能用let或const再次声明</li>
</ul>
<p>（2）rest参数</p>
<pre><code>function add (...values) &#123;
    let sum = 0
    for (var val of values) &#123;
        sum +=val
    &#125;
&#125;
add(2, 5, 3)
</code></pre>
<p>（3）箭头函数</p>
<pre><code>var f = v =&gt; v;

// 等同于
var f = function (v) &#123;
  return v;
&#125;;

// 没有参数
var f = () =&gt; return 200

// 一个参数
var f = v =&gt; v

// 多个参数
var sum = (num1, num2) =&gt; num1 + num2

// 代码块内有多句代码
var check = (x, y) =&gt; &#123;
    console.log(x, y)
    return x + y
&#125;
</code></pre>
<p>注意：</p>
<ul>
<li>箭头函数没有自己的this对象</li>
<li>不可以当作构造函数</li>
<li>不可以使用arguments对象</li>
<li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数</li>
</ul>

        <h5 id="4-数组扩展">
          <a href="#4-数组扩展" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-数组扩展" class="headerlink" title="4. 数组扩展"></a>4. 数组扩展</h5>
      <p>（1）复制数组</p>
<pre><code>const a1 = [1,2]
const a2 =[...a1]   // 这种复制属于深拷贝
</code></pre>
<p>（2）合并数组</p>
<pre><code>const arr1 = [&#39;a&#39;, &#39;c&#39;]
const arr2 = [&#39;d,&#39;]
[...arr1, ...arr2]  // [&#39;a&#39;, &#39;c&#39;, &#39;d&#39;]
</code></pre>
<p>（3）Array.from()<br>Array.from方法用于将两类对象转为真正的数组</p>
<p>（4）Array.of()</p>

        <h5 id="5-对象扩展">
          <a href="#5-对象扩展" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-对象扩展" class="headerlink" title="5. 对象扩展"></a>5. 对象扩展</h5>
      <p>（1）属性的简洁表示</p>
<pre><code>
</code></pre>

        <h5 id="6-扩展运算符">
          <a href="#6-扩展运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-扩展运算符" class="headerlink" title="6. 扩展运算符"></a>6. 扩展运算符</h5>
      
        <h5 id="7-symbol">
          <a href="#7-symbol" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-symbol" class="headerlink" title="7. symbol"></a>7. symbol</h5>
      
        <h5 id="8-迭代器">
          <a href="#8-迭代器" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-迭代器" class="headerlink" title="8. 迭代器"></a>8. 迭代器</h5>
      
        <h5 id="9-生成器">
          <a href="#9-生成器" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-生成器" class="headerlink" title="9. 生成器"></a>9. 生成器</h5>
      
        <h5 id="10-promise">
          <a href="#10-promise" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-promise" class="headerlink" title="10. promise"></a>10. promise</h5>
      <p>（1）含义<br>Promise 是异步编程的一种解决方案，所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果</p>
<p>（2）Promise对象有两个特点</p>
<ul>
<li><p>对象的状态不受外界影响</p>
</li>
<li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果</p>
</li>
</ul>
<p>（3）基本用法</p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
    if (/* 异步操作成功 */) &#123;
        resolve(value)
    &#125; else &#123;
        reject(error)
    &#125;
&#125;)
</code></pre>
<ul>
<li>Promise对象是一个构造函数，用来生成Promise实例</li>
<li>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject</li>
<li>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li>
<li>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>
</ul>

        <h5 id="11-set-map">
          <a href="#11-set-map" class="heading-link"><i class="fas fa-link"></i></a><a href="#11-set-map" class="headerlink" title="11. set map"></a>11. set map</h5>
      
        <h5 id="12-class">
          <a href="#12-class" class="heading-link"><i class="fas fa-link"></i></a><a href="#12-class" class="headerlink" title="12. class"></a>12. class</h5>
      <p>（1）含义<br>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已</p>
<p>（2）定义一个class</p>
<pre><code>class point &#123;
    // 构造方法
    constructor (x, y) &#123;
        this.x = x
        this.y = y
    &#125;
    toString () &#123;
        return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
    &#125;
&#125;
</code></pre>
<p>ES6 的类，完全可以看作构造函数的另一种写法</p>
<pre><code>class Point &#123;
  // ...
&#125;

typeof Point // &quot;function&quot;
Point === Point.prototype.constructor // true
</code></pre>
<p>类的数据类型就是函数，类本身就指向构造函数</p>
<pre><code>class Bar &#123;
  doStuff() &#123;
    console.log(&#39;stuff&#39;);
  &#125;
&#125;

const b = new Bar();
b.doStuff() // &quot;stuff&quot;
</code></pre>
<p>构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面</p>
<pre><code>class Point &#123;
  constructor() &#123;
    // ...
  &#125;

  toString() &#123;
    // ...
  &#125;

  toValue() &#123;
    // ...
  &#125;
&#125;

// 等同于

Point.prototype = &#123;
  constructor() &#123;&#125;,
  toString() &#123;&#125;,
  toValue() &#123;&#125;,
&#125;;
</code></pre>
<p>（2）constructor方法<br>constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加</p>
<pre><code>class Point &#123;
&#125;

// 等同于
class Point &#123;
  constructor() &#123;&#125;
&#125;
</code></pre>
<p>（3）类的实例</p>
<pre><code>/定义类
class Point &#123;

  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;

&#125;

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty(&#39;x&#39;) // true
point.hasOwnProperty(&#39;y&#39;) // true
point.hasOwnProperty(&#39;toString&#39;) // false
point.__proto__.hasOwnProperty(&#39;toString&#39;) // true
</code></pre>

        <h5 id="13-proxy">
          <a href="#13-proxy" class="heading-link"><i class="fas fa-link"></i></a><a href="#13-proxy" class="headerlink" title="13. proxy"></a>13. proxy</h5>
      <p>（1）含义<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</p>
<p>（2）Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”</p>
<pre><code>var obj = new Proxy(P&#123;&#125;, &#123;
    get: function (target, proKey, receiver) &#123;
        return Relect.get(target, propKey, receiver)
    &#125;,
    set: function (target, proKey, value, receiver) &#123;
        return Relect.set(target, propKey, receiver)
    &#125;
&#125;)
</code></pre>
<ol start="14">
<li>async函数<br>（1）含义<br>ES2017 标准引入了 async 函数，它就是 Generator 函数的语法糖<br>Generator 函数</li>
</ol>
<pre><code>const fs = require(&#39;fs&#39;);

const readFile = function (fileName) &#123;
  return new Promise(function (resolve, reject) &#123;
    fs.readFile(fileName, function(error, data) &#123;
      if (error) return reject(error);
      resolve(data);
    &#125;);
  &#125;);
&#125;;

const gen = function* () &#123;
  const f1 = yield readFile(&#39;/etc/fstab&#39;);
  const f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<p>async函数</p>
<pre><code>const asyncReadFile = async function () &#123;
  const f1 = await readFile(&#39;/etc/fstab&#39;);
  const f2 = await readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<p>（2）基本用法<br>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</p>
<p>本文参考：<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs">ECMAScript 6 入门</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/29/es6%E5%85%A5%E9%97%A8/" data-id="ckwou9u5d00069hwn88g0alou" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/10/29/koa%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          koa使用介绍
        
      </div>
    </a>
  
  
    <a href="/2021/10/29/%E5%A6%82%E4%BD%95%E7%94%A8vue%E9%80%A0%E8%BD%AE%E5%AD%90/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">vue组件库开发</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/12/01/%E4%B8%89%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3gitactions/">三分钟了解Github Actions</a>
          </li>
        
          <li>
            <a href="/2021/11/20/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">前端工程化最佳实践</a>
          </li>
        
          <li>
            <a href="/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8react/">快速入门react</a>
          </li>
        
          <li>
            <a href="/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/">快速入门vue</a>
          </li>
        
          <li>
            <a href="/2021/10/30/react-hooks/">react-hooks</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Carr Lu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>