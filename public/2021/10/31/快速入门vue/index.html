<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>快速入门vue | Carr&#39;Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="vue简介 Vue是一套用于构建用户界面的渐进式框架，Vue能够为复杂的单页面应用提供驱动  安装（1）CDN引入 &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2&quot;&gt;&lt;&#x2F;script&gt;    （2）脚手架工具vue-cli &#x2F;&#x2F; 全局安装vue-cli npm install vue-cli -g  &#x2F;&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="快速入门vue">
<meta property="og:url" content="http://example.com/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/index.html">
<meta property="og:site_name" content="Carr&#39;Blog">
<meta property="og:description" content="vue简介 Vue是一套用于构建用户界面的渐进式框架，Vue能够为复杂的单页面应用提供驱动  安装（1）CDN引入 &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue@2&quot;&gt;&lt;&#x2F;script&gt;    （2）脚手架工具vue-cli &#x2F;&#x2F; 全局安装vue-cli npm install vue-cli -g  &#x2F;&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/lifecycle.png">
<meta property="og:image" content="http://example.com/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/vue.png">
<meta property="article:published_time" content="2021-10-31T13:19:30.000Z">
<meta property="article:modified_time" content="2021-12-20T08:01:23.692Z">
<meta property="article:author" content="Carr Lu">
<meta property="article:tag" content="web前端 前端开发 html css js javascript vue react 小程序 node koa express mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/lifecycle.png">
  
    <link rel="alternate" href="/atom.xml" title="Carr&#39;Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Carr&#39;Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-快速入门vue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/" class="article-date">
  <time datetime="2021-10-31T13:19:30.000Z" itemprop="datePublished">2021-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      快速入门vue
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>vue简介<br> Vue是一套用于构建用户界面的渐进式框架，Vue能够为复杂的单页面应用提供驱动</p>
</li>
<li><p>安装<br>（1）CDN引入</p>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
</ol>
<p>（2）脚手架工具vue-cli</p>
<pre><code>// 全局安装vue-cli
npm install vue-cli -g

// create vue project
vue init wepack demo-name   // for vue-cli@2.x

or

vue create  // for vue-cli@3.x
</code></pre>
<ol start="3">
<li><p>Vue实例</p>
<pre><code>var data = &#123;a: 1&#125;
var vm = new Vue(&#123;
 data: data
&#125;)
</code></pre>
</li>
<li><p>生命周期<br><img src="/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/lifecycle.png" alt="vue生命周期"></p>
</li>
<li><p>插值（Mustache）<br>数据绑定最常见的形式就是使用’Mustache’语法（双大括号）的文本插值</p>
<pre><code>&lt;span&gt;&#123;&#123;Message: &#123;&#123;msg&#125;&#125;&#125;&#125;&lt;/span&gt;
</code></pre>
</li>
<li><p>指令<br>指定（Directives）是带有v-前缀的特殊attribute，指令的指责是，当表达式的值改变时，<br>将其产生的连带影响，响应式的用于DOM<br>v-on    // 缩写 :<br>v-bind  // 缩写 @<br>v-if<br>v-else<br>v-else-if<br>v-html<br>v-for<br>v-show</p>
</li>
<li><p>修饰符<br>.prevent</p>
</li>
<li><p>计算属性(computed)<br>计算属性</p>
<pre><code>var vm = new Vue(&#123;
 el: &#39;#app&#39;,
 data: &#123;
     message: &#39;Hello&#39;
 &#125;,
 computed: &#123;
     reversedMessage: function () &#123;
         // this指向vm实例
         return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)
     &#125;
 &#125;
&#125;)
</code></pre>
</li>
<li><p>侦听器</p>
</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;
        Ask a yes/no question
        &lt;input v-model=&quot;question&quot; /&gt;
    &lt;/p&gt;
&lt;/div&gt;

var vm = new Vue(&#123;
    el: &#39;#app&#39;,
    data () &#123;
        return &#123;
            question: &#39;&#39;,
            answer: &#39;I cannot give you an answer until you ask a question!&#39;
        &#125;
    &#125;,
    created () &#123;
        this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)
    &#125;,
    watch: &#123;
        question: function (newQuestion, oldQuestion) &#123;
            this.answer = &#39;Waiting for you to stop typing...&#39;
            this.debouncedGetAnswer()
        &#125;
    &#125;,
    methods: &#123;
        getAnsswer: function () &#123;
            if (this.question.indexOf(&#39;?&#39;) === -1) &#123;
                this.answer = &#39;&#39;Questions usually contain a question mark. ;-)&#39;
                return 
            &#125;
            this.answer = &#39;Thinking...&#39;
            var vm = this
            axios.get(&#39;&#39;).then(res =&gt; &#123;
                vm.answer = _.capitalize(response.data.answer)
            &#125;).catch(error =&gt; &#123;
                vm.answer = &#39;Error! Could not reach the API. &#39; + error
            &#125;)
        &#125;
    &#125;
&#125;)
</code></pre>
<ol start="10">
<li>class与style绑定<br>内联</li>
</ol>
<pre><code>&lt;div :class=&quot;&#123;active: isActive&#125;&quot;&gt;&lt;/div&gt;

data: &#123;
    isActive: true
&#125;
</code></pre>
<p>对象</p>
<pre><code>&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;

data: &#123;
    classObject: &#123;
        active&quot; true,
        &#39;text-danger&#39;: false
    &#125;
&#125;
</code></pre>
<p>计算属性</p>
<pre><code>&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;

data: &#123;
    isActive: true,
    error: null
&#125;

computed: &#123;
    classObject: function () &#123;
        return &#123;
            active: this.isActive &amp;&amp; !this.error,
            &#39;text-danger&#39;: this.error &amp;&amp; this.error.type === &#39;fatal&#39;
        &#125;
    &#125;
&#125;
</code></pre>
<p>数组</p>
<pre><code>&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;

data: &#123;
    activeClass: &#39;active&#39;,
    errorClass: &#39;text-danger&#39;
&#125;
</code></pre>
<p>三元表达式</p>
<pre><code>&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;
</code></pre>
<p>数组中使用对象</p>
<pre><code>&lt;div v-bind:class=&quot;[&#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;
</code></pre>
<ol start="11">
<li>条件渲染<br>v-if指令用于条件性地渲染一块内容</li>
</ol>
<pre><code>&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;
&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;
</code></pre>
<p>总结：<br>    不建议v-if与v-for一起使用，v-for具有比v-if更高的优先级，</p>
<ol start="12">
<li>列表渲染</li>
</ol>
<pre><code>&lt;ul&gt;
    &lt;li v-for=&quot;item in items&quot; :key=&quot;item.message&quot;&gt;
        &#123;&#123;item.message&#125;&#125;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>总结：<br>（1）建议给每个遍历项添加一个唯一的key，且不是下标<br>（2）不建议v-for, v-if在上同一个元素上同时使用<br>（3）v-for的优先级高于v-if</p>
<ol start="13">
<li>事件处理（v-on）<br>用v-on指令监听DOM事件</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;
&lt;/div&gt;

var app = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        name: &#39;Vue.js&#39;
    &#125;,
    methods: &#123;
        greet: function (event) &#123;
            if (event) &#123;
                alert(event.target.tagName)
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>
<p>事件修饰符：<br>.stop<br>.prevent<br>.capture<br>.self<br>.once<br>.passive<br>.enter<br>.tab<br>.delete<br>.esc<br>.space<br>.up<br>.down<br>.left<br>.right</p>
<pre><code>&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰符可以串联 --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;

&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;

&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;
&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;
&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;

&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;
&lt;!-- 即事件不是从内部元素触发的 --&gt;
&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;
</code></pre>
<ol start="14">
<li>表单输入绑定（v-model）<br>v-model</li>
</ol>
<pre><code>// 文本
&lt;input v-model=&quot;message&quot; /&gt;
&lt;p&gt;Message is: &#123;&#123;message&#125;&#125;&lt;/p&gt;

// 复选框
&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;
</code></pre>
<p>修饰符：<br>.lazy   在“change”时而非“input”时更新<br>.trim   自动过滤用户输入的首尾空白字符<br>.number 将用户的输入值转为数值类型</p>
<pre><code>&lt;input v-model.lazy=&quot;msg&quot;&gt;

&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;

&lt;input v-model.trim=&quot;msg&quot;&gt;
</code></pre>
<ol start="15">
<li>组件<br>（1）组件命名</li>
</ol>
<ul>
<li>使用 kebab-case</li>
</ul>
<pre><code>Vue.component(&#39;my-component-name&#39;, &#123; /* ... */ &#125;)

/*
当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 &lt;my-component-name&gt;
*/ 
</code></pre>
<ul>
<li>使用 PascalCase</li>
</ul>
<pre><code>Vue.component(&#39;MyComponentName&#39;, &#123; /* ... */ &#125;)

/*
当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 &lt;my-component-name&gt; 和 &lt;MyComponentName&gt; 都是可接受的
*/
</code></pre>
<p>（2）通过props向子组件传递数据</p>
<ul>
<li>Prop命名</li>
</ul>
<pre><code>Vue.component(&#39;blog-post&#39;, &#123;
  // 在 JavaScript 中是 camelCase 的
  props: [&#39;postTitle&#39;],
  template: &#39;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#39;
&#125;)

&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;
&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;
</code></pre>
<ul>
<li>Prop类型<br>通常你希望每个 prop 都有指定的值类型，这时，你可以以对象形式列出 prop</li>
</ul>
<pre><code>props: [&#39;title&#39;, &#39;likes&#39;, &#39;isPublished&#39;, &#39;commentIds&#39;, &#39;author&#39;]

props: &#123;
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // or any other constructor
&#125;
</code></pre>
<ul>
<li>传递静态或动态Prop<br>静态Prop</li>
</ul>
<pre><code>&lt;blog-post title=&quot;My journey with Vue&quot;&gt;&lt;/blog-post&gt;
</code></pre>
<p>动态Prop</p>
<pre><code>&lt;!-- 动态赋予一个变量的值 --&gt;
&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;

&lt;!-- 动态赋予一个复杂表达式的值 --&gt;
&lt;blog-post
  v-bind:title=&quot;post.title + &#39; by &#39; + post.author.name&quot;
&gt;&lt;/blog-post&gt;
</code></pre>
<p>传入数字</p>
<pre><code>&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;
&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;
&lt;blog-post v-bind:likes=&quot;42&quot;&gt;&lt;/blog-post
</code></pre>
<p>传入布尔值</p>
<pre><code>&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;
&lt;blog-post is-published&gt;&lt;/blog-post&gt;

&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;
&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;
&lt;blog-post v-bind:is-published=&quot;false&quot;&gt;&lt;/blog-post&gt;
</code></pre>
<p>传入数组</p>
<pre><code>&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;
&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;
&lt;blog-post v-bind:comment-ids=&quot;[234, 266, 273]&quot;&gt;&lt;/blog-post&gt;
</code></pre>
<p>传入对象</p>
<pre><code>&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;
&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;
&lt;blog-post
  v-bind:author=&quot;&#123;
    name: &#39;Veronica&#39;,
    company: &#39;Veridian Dynamics&#39;
  &#125;&quot;
&gt;&lt;/blog-post&gt;
</code></pre>
<ul>
<li><p>单向数据流<br>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理，你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告</p>
</li>
<li><p>Prop验证<br>type类型：String、Number、Boolean、Array、Object、Date、Function、Symbol</p>
</li>
</ul>
<pre><code>Vue.component(&#39;my-component&#39;, &#123;
  props: &#123;
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: &#123;
      type: String,
      required: true
    &#125;,
    // 带有默认值的数字
    propD: &#123;
      type: Number,
      default: 100
    &#125;,
    // 带有默认值的对象
    propE: &#123;
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () &#123;
        return &#123; message: &#39;hello&#39; &#125;
      &#125;
    &#125;,
    // 自定义验证函数
    propF: &#123;
      validator: function (value) &#123;
        // 这个值必须匹配下列字符串中的一个
        return [&#39;success&#39;, &#39;warning&#39;, &#39;danger&#39;].indexOf(value) !== -1
      &#125;
    &#125;
  &#125;
&#125;)
</code></pre>
<p>（2）通过$emit监听子组件事件</p>
<pre><code>// 父组件
&lt;blog-post
  ...
  v-on:enlarge-text=&quot;postFontSize += 0.1&quot;
&gt;&lt;/blog-post&gt;

// 子组件
&lt;button v-on:click=&quot;$emit(&#39;enlarge-text&#39;)&quot;&gt;
  Enlarge text
&lt;/button&gt;
</code></pre>
<ul>
<li>$emit参数</li>
</ul>
<pre><code>// 父组件
&lt;blog-post
  ...
  v-on:enlarge-text=&quot;onEnlargeText&quot;
&gt;&lt;/blog-post&gt;

methods: &#123;
    onEnlargeText (enlargeAmount) &#123;
        this.postFontSize += enlargeAmount
    &#125;
&#125;

// 子组件
&lt;button v-on:click=&quot;$emit(&#39;enlarge-text&#39;, 0.1)&quot;&gt;
  Enlarge text
&lt;/button&gt;
</code></pre>
<p>（3）插槽slot<br>一套内容分发的 API</p>
<pre><code>&lt;navigation-link url=&quot;/profile&quot;&gt;
  Your Profile
&lt;/navigation-link&gt;

// navigation-link
&lt;a
  v-bind:href=&quot;url&quot;
  class=&quot;nav-link&quot;
&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/a&gt;

// 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。
</code></pre>
<ul>
<li>具名插槽</li>
</ul>
<pre><code>// 定义插槽
&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;

// 使用插槽
&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here&#39;s some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<ul>
<li>作用域插槽</li>
</ul>
<pre><code>// 子组件
&lt;span&gt;
  &lt;slot v-bind:user=&quot;user&quot;&gt;
    &#123;&#123; user.lastName &#125;&#125;
  &lt;/slot&gt;
&lt;/span&gt;

// 父组件
&lt;current-user&gt;
  &lt;template v-slot:default=&quot;slotProps&quot;&gt;
    &#123;&#123; slotProps.user.firstName &#125;&#125;
  &lt;/template&gt;
&lt;/current-user&gt;
</code></pre>
<p>（4）动态组件<br>总结：<br>（1）组件的data必须一个函数</p>
<ol start="16">
<li><p>自定义事件</p>
</li>
<li><p>进入离开列表过渡</p>
</li>
<li><p>混入</p>
</li>
</ol>
<pre><code>var myMixin = &#123;
    created: function () &#123;
        this.hello()
    &#125;,
    methods: &#123;
        hello: function () &#123;
            console.log(&#39;hello&#39;)
        &#125;
    &#125;
&#125;

var Component = Vue.extend(&#123;
    mixins: [myMixin]
&#125;)
</code></pre>
<ol start="19">
<li>自定义指令</li>
</ol>
<pre><code>Vue.directive(&#39;focus&#39;, &#123;
    // / 当被绑定的元素插入到 DOM 中时……
    inserted: function (el) &#123;
        // 聚焦元素
    el.focus()
        el.focus()
    &#125;
&#125;)
</code></pre>
<p>钩子函数：<br>bind    只调用一次，指令第一次绑定到元素时调用<br>inserted    被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)<br>update  所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前<br>componentUpdated    指令所在组件的 VNode 及其子 VNode 全部更新后调用<br>unbind  只调用一次，指令与元素解绑时调用</p>
<p>钩子函数参数<br>el：指令所绑定的元素，可以用来直接操作 DOM<br>binding：一个对象，包含以下 property<br>    name：指令名，不包括 v- 前缀<br>    value：指令绑定的值，例如：v-my-directive=”1 + 1” 中，绑定值为 2<br>    oldValue：指定绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用<br>    expression：字符串形式的指定表达式，例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”<br>    arg：传给指令的参数，例如 v-my-directive:foo 中，参数为 “foo”<br>    modifers：一个包含修饰符的对象，如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }<br>vnode：Vue 编译生成的虚拟节点<br>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用</p>
<p>一个例子</p>
<pre><code>&lt;div id=&quot;hook-arguments-example&quot; v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt;

Vue.directive(&#39;demo&#39;, &#123;
  bind: function (el, binding, vnode) &#123;
    var s = JSON.stringify
    el.innerHTML =
      &#39;name: &#39;       + s(binding.name) + &#39;&lt;br&gt;&#39; +   //demo
      &#39;value: &#39;      + s(binding.value) + &#39;&lt;br&gt;&#39; +  // hello
      &#39;expression: &#39; + s(binding.expression) + &#39;&lt;br&gt;&#39; + // message
      &#39;argument: &#39;   + s(binding.arg) + &#39;&lt;br&gt;&#39; +    //foo
      &#39;modifiers: &#39;  + s(binding.modifiers) + &#39;&lt;br&gt;&#39; +  //&#123;&quot;a&quot;: true, &quot;b&quot;: true&#125;
      &#39;vnode keys: &#39; + Object.keys(vnode).join(&#39;, &#39;)
  &#125;
&#125;)

new Vue(&#123;
  el: &#39;#hook-arguments-example&#39;,
  data: &#123;
    message: &#39;hello!&#39;
  &#125;
&#125;)
</code></pre>
<h5 id="20-Render-amp-JSX"><a href="#20-Render-amp-JSX" class="headerlink" title="20. Render &amp; JSX"></a>20. Render &amp; JSX</h5><p>Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用渲染函数，它比模板更接近编译器</p>
<pre><code>Vue.component(&#39;anchored-heading&#39;, &#123;
  render: function (createElement) &#123;
    return createElement(
      &#39;h&#39; + this.level,   // 标签名称
      this.$slots.default // 子节点数组
    )
  &#125;,
  props: &#123;
    level: &#123;
      type: Number,
      required: true
    &#125;
  &#125;
&#125;)
</code></pre>
<ul>
<li>节点、树以及虚拟 DOM</li>
</ul>
<pre><code>&lt;h1&gt;&#123;&#123; blogTitle &#125;&#125;&lt;/h1&gt;

渲染函数

render: function (createElement) &#123;
  return createElement(&#39;h1&#39;, this.blogTitle)
&#125;
</code></pre>
<ul>
<li>createElement 参数</li>
</ul>
<pre><code>// @returns &#123;VNode&#125;
createElement(
  // &#123;String | Object | Function&#125;
  // 一个 HTML 标签名、组件选项对象，或者
  // resolve 了上述任何一种的一个 async 函数。必填项。
  &#39;div&#39;,

  // &#123;Object&#125;
  // 一个与模板中 attribute 对应的数据对象。可选。
  &#123;
    // (详情见下一节)
  &#125;,

  // &#123;String | Array&#125;
  // 子级虚拟节点 (VNodes)，由 `createElement()` 构建而成，
  // 也可以使用字符串来生成“文本虚拟节点”。可选。
  [
    &#39;先写一些文字&#39;,
    createElement(&#39;h1&#39;, &#39;一则头条&#39;),
    createElement(MyComponent, &#123;
      props: &#123;
        someProp: &#39;foobar&#39;
      &#125;
    &#125;)
  ]
)
</code></pre>
<h5 id="21-插件"><a href="#21-插件" class="headerlink" title="21. 插件"></a>21. 插件</h5><p>（1）插件是什么？<br>    插件通常用来为 Vue 添加全局功能<br>（2）怎么用？<br>    通过全局方法 Vue.use() 使用插件，它需要在你调用 new Vue() 启动应用之前完成</p>
<pre><code>// 调用 `MyPlugin.install(Vue)`
Vue.use(MyPlugin)

new Vue(&#123;
  // ...组件选项
&#125;)
</code></pre>
<p>（3）开发插件<br>Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：</p>
<pre><code>MyPlugin.install = function (Vue, options) &#123;
  // 1. 添加全局方法或 property
  Vue.myGlobalMethod = function () &#123;
    // 逻辑...
  &#125;

  // 2. 添加全局资源
  Vue.directive(&#39;my-directive&#39;, &#123;
    bind (el, binding, vnode, oldVnode) &#123;
      // 逻辑...
    &#125;
    ...
  &#125;)

  // 3. 注入组件选项
  Vue.mixin(&#123;
    created: function () &#123;
      // 逻辑...
    &#125;
    ...
  &#125;)

  // 4. 添加实例方法
  Vue.prototype.$myMethod = function (methodOptions) &#123;
    // 逻辑...
  &#125;
&#125;
</code></pre>
<h5 id="22-过滤器"><a href="#22-过滤器" class="headerlink" title="22. 过滤器"></a>22. 过滤器</h5><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化</p>
<pre><code>&lt;!-- 在双花括号中 --&gt;
&#123;&#123; message | capitalize&#125;&#125;

&lt;!-- 在 `v-bind` 中 --&gt;
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;

filters: &#123;
    capitalize: function (value) &#123;
        if (!value) &#123;
            value = value.toString()
            return value.chartAt(0).toUpperCase() + value.slice(1)
        &#125;
    &#125;
&#125;
</code></pre>
<p>全局注册过滤器<br>Vue.filter(‘capitalize’, function (value) {<br>    if (!value) {<br>        value = value.toString()<br>        return value.chartAt(0).toUpperCase() + value.slice(1)<br>    }<br>})</p>
<h5 id="23-响应式原理"><a href="#23-响应式原理" class="headerlink" title="23. 响应式原理"></a>23. 响应式原理</h5><p><img src="/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/vue.png" alt="vue"><br>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染</p>
<h5 id="24-测试"><a href="#24-测试" class="headerlink" title="24. 测试"></a>24. 测试</h5><p>（1）官方推荐测试框架Vue Testing Library (@testing-library/vue)</p>
<p>（2）安装</p>
<pre><code>npm install --save-dev jest @vue/test-utils
</code></pre>
<p>（3）添加脚本</p>
<pre><code>// package.json
&#123;
  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;jest&quot;
  &#125;
&#125;
</code></pre>
<h5 id="25-Vue-API"><a href="#25-Vue-API" class="headerlink" title="25. Vue API"></a>25. Vue API</h5><ul>
<li>实例<br>（1）vm.$data<br>（2）vm.$props<br>（3）vm.$el<br>  Vue 实例使用的根 DOM 元素<br>（3）vm.$options<br>  用于当前 Vue 实例的初始化选项</li>
</ul>
<pre><code>new Vue(&#123;
  customOption: &#39;foo&#39;,
  created: function () &#123;
    console.log(this.$options.customOption) // =&gt; &#39;foo&#39;
  &#125;
&#125;)
</code></pre>
<p>（4）vm.$parent<br>    父实例，如果当前实例有的话<br>（5）vm.$root<br>    当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己<br>（6）$children<br>    当前实例的直接子组件<br>（7）vm.$slots<br>    用来访问被插槽分发的内容</p>
<pre><code>```
&lt;blog-post&gt;
    &lt;template v-slot:header&gt;
        &lt;h1&gt;About Me&lt;/h1&gt;
    &lt;/template&gt;

    &lt;p&gt;Here&#39;s some page content, which will be included in vm.$slots.default,   because it&#39;s not inside a named slot.
    &lt;/p&gt;

    &lt;template v-slot:footer&gt;
        &lt;p&gt;Copyright 2016 Evan You&lt;/p&gt;
    &lt;/template&gt;

    &lt;p&gt;If I have some content down here, it will also be included in            vm.$slots.default.
    &lt;/p&gt;
&lt;/blog-post&gt;
```

```
Vue.component(&#39;blog-post&#39;, &#123;
    render: function (createElement) &#123;
        var header = this.$slots.header
        var body   = this.$slots.default
        var footer = this.$slots.footer
        return createElement(&#39;div&#39;, [
        createElement(&#39;header&#39;, header),
        createElement(&#39;main&#39;, body),
        createElement(&#39;footer&#39;, footer)
        ])
    &#125;
 &#125;)
```
</code></pre>
<p>（8）vm.$scopedSlots<br>    用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。<br>（9）vm.$refs<br>    一个对象，持有注册过 ref attribute 的所有 DOM 元素和组件实例<br>（10）vm.$isServer<br>    当前 Vue 实例是否运行于服务器<br>（11）vm.$attrs<br>    包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用<br>（12）vm.$listeners<br>    包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件——在创建更高层次的组件时非常有用</p>
<ul>
<li><p>实例方法<br>（1）vm.$watch( expOrFn, callback, [options] )<br>  观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。表达式只接受简单的键路径。对于更复杂的表达式，用一个函数取代</p>
<pre><code>    // 键路径
    vm.$watch(&#39;a.b.c&#39;, function (newVal, oldVal) &#123;
    // 做点什么
    &#125;)

    // 函数
    vm.$watch(
    function () &#123;
        // 表达式 `this.a + this.b` 每次得出一个不同的结果时
        // 处理函数都会被调用。
        // 这就像监听一个未被定义的计算属性
        return this.a + this.b
    &#125;,
    function (newVal, oldVal) &#123;
        // 做点什么
    &#125;
    )
</code></pre>
<p>  vm.$watch 返回一个取消观察函数，用来停止触发回调：</p>
<pre><code>var unwatch = vm.$watch(&#39;a&#39;, cb)
// 之后取消观察
unwatch()
</code></pre>
<p>  选项：deep</p>
<pre><code>  为了发现对象内部值的变化，可以在选项参数中指定 deep: true。注意监听数组的变更不需要这么做。
</code></pre>
<pre><code>    vm.$watch(&#39;someObject&#39;, callback, &#123;
        deep: true
    &#125;)
    vm.someObject.nestedValue = 123
    // callback is fired
</code></pre>
</li>
</ul>
<pre><code>选项：immediate
    在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调：

```
    vm.$watch(&#39;a&#39;, callback, &#123;
        immediate: true
    &#125;)
    // 立即以 `a` 的当前值触发回调
```
</code></pre>
<p>（2）vm.$set( target, propertyName/index, value )<br>    这是全局 Vue.set 的别名</p>
<p>（3）vm.$delete( target, propertyName/index )<br>    这是全局 Vue.delete 的别名</p>
<p>（4）vm.$on( event, callback )<br>    监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数</p>
<pre><code>```
vm.$on(&#39;test&#39;, function (msg) &#123;
    console.log(msg)
&#125;)
vm.$emit(&#39;test&#39;, &#39;hi&#39;)
// =&gt; &quot;hi&quot;
```
</code></pre>
<p>（5）$once<br>    监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除<br>（6）vm.$off( [event, callback] )<br>    移除自定义事件监听器<br>    - 如果没有提供参数，则移除所有的事件监听器；</p>
<pre><code>- 如果只提供了事件，则移除该事件所有的监听器；

- 如果同时提供了事件与回调，则只移除这个回调的监听器。
</code></pre>
<p>（7）vm.$emit( eventName, […args] )<br>    触发当前实例上的事件。附加参数都会传给监听器回调<br>    <code>    Vue.component(&#39;welcome-button&#39;, &#123;         template: `             &lt;button v-on:click=&quot;$emit(&#39;welcome&#39;)&quot;&gt;                 Click me to be welcomed             &lt;/button&gt;`     &#125;)    </code></p>
<pre><code>```
&lt;div id=&quot;emit-example-simple&quot;&gt;
    &lt;welcome-button @welcome=&quot;sayHi&quot;&gt;&lt;/welcome-button&gt;
&lt;/div&gt;
```

```
new Vue(&#123;
    el: &#39;#emit-example-simple&#39;,
    methods: &#123;
        sayHi: function () &#123;
        alert(&#39;Hi!&#39;)
        &#125;
    &#125;
&#125;)
```
</code></pre>
<p>（8）vm.$mount( [elementOrSelector] )<br>    如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素可以使用 vm.$mount() 手动地挂载一个未挂载的实例</p>
<p>（9）vm.$nextTick( [callback] )<br>    将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上</p>
<p>（10）vm.$destroy()<br>     完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器  </p>
<p>（11）vm.$forceUpdate()<br>    迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/" data-id="ckxedwl5b0003w5183tmz5v70" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8react/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          快速入门react
        
      </div>
    </a>
  
  
    <a href="/2021/10/30/react-hooks/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">react-hooks</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/12/01/%E4%B8%89%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3gitactions/">三分钟了解Github Actions</a>
          </li>
        
          <li>
            <a href="/2021/11/20/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">前端工程化最佳实践</a>
          </li>
        
          <li>
            <a href="/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8react/">快速入门react</a>
          </li>
        
          <li>
            <a href="/2021/10/31/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8vue/">快速入门vue</a>
          </li>
        
          <li>
            <a href="/2021/10/30/react-hooks/">react-hooks</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Carr Lu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>